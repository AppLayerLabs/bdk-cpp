/*
Copyright (c) [2023-2024] [AppLayer Developers]

This software is distributed under the MIT License.
See the LICENSE.txt file in the project root for more information.
*/

#include "../../src/libs/catch2/catch_amalgamated.hpp"

#include "../../src/core/comet.h"

// for SDKTestSuite::getTestPort()
#include "../sdktestsuite.hpp"

// To decode the base64-encoded key strings
#include "../libs/base64.hpp"

#include "../../src/utils/uintconv.h"

#include <sys/prctl.h> // For prctl and PR_SET_PDEATHSIG
#include <signal.h>    // For SIGTERM

std::string createTestDumpPath(const std::string& testDir) {
  std::string testDumpPath = Utils::getTestDumpPath() + "/" + testDir;
  if (std::filesystem::exists(testDumpPath)) {
    std::filesystem::remove_all(testDumpPath);
  }
  std::filesystem::create_directories(testDumpPath);
  GLOGDEBUG("Test dump path: " + testDumpPath);
  return testDumpPath;
}

// a set of ports used by one running Comet instance.
// proxy_app is an unix sockets file inside comet/ (we don't support remote proxy_apps),
//   so one less net port to manage.
struct CometTestPorts {
  int p2p; // CometBFT P2P port e.g. 26656
  int rpc; // CometBFT RPC port e.g. 26657
};

// generate an array of node ports for a given number of test Comet nodes
std::vector<CometTestPorts> generateCometTestPorts(int numNodes) {
  std::vector<CometTestPorts> ports;
  for (int i = 0; i < numNodes; ++i) {
    ports.push_back( { SDKTestSuite::getTestPort(), SDKTestSuite::getTestPort() } );
  }
  return ports;
}

// key values required by one Comet node
//
// address, pub_key and priv_key are used to generate both "privValidatorKey:{..." (each for
// one comet instance) and "validators:{..." (the full validator set option for the entire
// test which is identical for all comet instances that are in the same testcase).
//
// node_priv_key is used to generate "nodeKey:{..."
//
// the node_id is not supplied in the cometBFT options json, since it is derived from the
// node_priv_key. Comet discovers its node_id dynamically after setting the node_key.json
// file (by running 'cometbft show-node-id' and capturing the output).
// nevertheless, the precomputed node_id for these test nodes is included here to allow
// testcases to specify their peer list immediately from the testcase without having to
// spawn and run Comet instances to the point they can know their node ids.
struct CometTestKeys {
  std::string address;
  std::string pub_key; // "type": "tendermint/PubKeyEd25519"
  std::string priv_key; // "type": "tendermint/PrivKeyEd25519"
  std::string node_id;
  std::string node_priv_key; // "type": "tendermint/PrivKeyEd25519"
};

// a set of 200 precomputed validator keys and addresses, plus node ids and node private keys, for use with tests
std::vector<CometTestKeys> cometTestKeys = {
  { "BA5CE019758080636A02CF8E95632186B506A3DB", "a5LlRb0lINMwQP1lzEAHY5lzCftnBG91Z5b3nyzi3KM=", "Af8Vc9KuZx/eC0ogds2dq3xBH5b3NE2wlPpZz4gGQ7trkuVFvSUg0zBA/WXMQAdjmXMJ+2cEb3VnlvefLOLcow==", "ee109bf456d8f9c8fbb6439a087da8e2d4b64595", "DJZS1+kjt1kICsxkgfKuFaBW3OYeefr75gpy1jeTZfsd6MIwWjUKJClUnfC7XZCUApoZ4GpksvGyku5aXdQeAg==" },
  { "5D5A899C26C0686963B46FC2E46924507DD94268", "hxvq/d+kPzB83IvainmMb47ZEX5BYkOpg11T/3tSmaI=", "rNLAbQD3PCNk1aUWlnGVrmRWEKWxd/6oAuvjnN6i3LiHG+r936Q/MHzci9qKeYxvjtkRfkFiQ6mDXVP/e1KZog==", "954c49d7ee7f2f0659f036be88a4c865af6ef316", "Q/0Hkzc86cZyUE4pefw5GdZ92kaoWrCR26bfIcPnsLk1U9W/UC/34/Eo5XKZkme2C3NZp1uxr1GNr3N17DyRtA==" },
  { "61C6DD5EB1E54D117F5063398469EC12B46129BD", "wQWPcD4KWs2gpIF0/lvtZRuN7YwokrU0HW7cHyhmt9w=", "ddb0/GY9jItXFjsA3i/t8ank0i/shKE7ry+GIMbl6PvBBY9wPgpazaCkgXT+W+1lG43tjCiStTQdbtwfKGa33A==", "069b0894e279a4a9185ad48ca2e1641a8605d602", "yplf14QdtPfHy5yaDPjgSMNqvQPiiQgzG9P6oE9QR5aPBY8BWN1Up3prDNyAfutflEazNKaXXth7np+N7oNsTA==" },
  { "B03E90048F570461580FB84596641E2B4B6D587A", "vCvy6VhGXL6rlP+wiJhTA7wnxYY69KUaHhEPLa077QU=", "A0a0Lu+O6iWi59Dld8Tby/IfTLHrKvi/Mhq5KvolNkO8K/LpWEZcvquU/7CImFMDvCfFhjr0pRoeEQ8trTvtBQ==", "a54c1f98f547adf69d178a64c9af77ee3bf903d8", "R5TWnCQFrGiXQbs9YxXrUMEpfEB+kVnAl2Ade0GPwLH9WIuwLe+O1or1fYAJz/sTa1nfo3HGbZqWd3d0G4e34g==" },
  { "1C9F0D1F2B0B910DF3A618DF2B0263644644BCCC", "Ej5ZCm77Z8U/wIpDgPvoMYjLVuEuzj5JEF46aKhfMY8=", "CBmhkUtbgVSOWijchPcqi0LW/c3RDmk+zxkonlDCANwSPlkKbvtnxT/AikOA++gxiMtW4S7OPkkQXjpoqF8xjw==", "acec55e97f065b8694ded20b8f542046a920e344", "wTHSBz8qZtBYI4IwMASsYNkqmRZP6Mv05yv4qfPZMU9+CAjBSZzYBxClUvIJCdEVMTZUNd2YLR/uQeR1vel16g==" },
  { "FFCACBF67FC6E6DF2424C0EA021E71C706B0374C", "UNEsaU/9Fel0YG6X4zmyElWhzu9GGQ+79pOSHNZbhHA=", "b3rGsHHej3e/sj1JqiQOSslw0nkedDjlKrhF47YTDBNQ0SxpT/0V6XRgbpfjObISVaHO70YZD7v2k5Ic1luEcA==", "e12d529fd1cf5e14efd4d7361e33c10d0af5b145", "C5QBbO9gzyDnRZRC4irhNzVaqN0iHCfY4zzEFuv7Vu8dLXDGFNAD/qgaMPOWBfDtr0ZqubmXFrffmBicBK/o1Q==" },
  { "C7CF9AFDAA40902AF51E970F04D4E9512F26FFCD", "VON3kQLMG7s6VCM+R57XrQJ/mM2PnU0x7xxkA9cqo80=", "g1oPhFwgbAj01lcpygfhDH+CQesL4bszLEknmg2qEiFU43eRAswbuzpUIz5HntetAn+YzY+dTTHvHGQD1yqjzQ==", "5a5990558bd0c545ba6be8e3284a7732450dd5de", "UruC6eUwcsHDTYJyJwyly/wYWjlwxJcXKcM5/vaJzOYFTjqFPp1oflp3lJW3aQ7rknt2Z+x222O4FXeZYRrZHA==" },
  { "38B009BA327A71187418AC92CD3AC747406E632B", "CORRtLY/XNdUOuCOx/MhANI3RnJubvqgPwJM7mMVid0=", "p0SztxcdsP1sWXzyf2yBTpTbpWPzT/M7i0eMxL/+rVoI5FG0tj9c11Q64I7H8yEA0jdGcm5u+qA/AkzuYxWJ3Q==", "4cd773ce1fa5c9495a4af991f13b8c024a1d5ea4", "UZkzgo6DSUwccTucBPamFWzAZYNCS9UcDBi43ZQVXnoUuzlCwJdFfpxHL8Q9iRvgN313DqJJGE2F0wDvBAsYRw==" },
  { "08CD22F1F4F1B0F883122BDD206B677CE4015CEE", "5GPiJSwN1IsqQJzD1EExB6AzxB9QUlI3x+VcD/5NVT4=", "DzsHxn7S9J3twatmoMQiVFWf2y2dwlgcWifczsvJFkHkY+IlLA3UiypAnMPUQTEHoDPEH1BSUjfH5VwP/k1VPg==", "5091d7013626760725e8895518936cd520a0f4c6", "AnUk+CFrr0WFZMEGGPun8q1U9rDaDmS0TNO4rp0RZTtHzpzcaWd9xHlKJUTMjz8K4LlIudr//jirdWJCNQDwwA==" },
  { "1F03D2FE8ECE3C66B4486FEE46D8458890C5621D", "Bd5CpH7m/dwkDinB/6lE5mjYN/uxtnkuOk9G+jCrhJI=", "yaitjU7/A+yT5D7JGXcg2AOoYx9EESYZHaYqxaNAaCAF3kKkfub93CQOKcH/qUTmaNg3+7G2eS46T0b6MKuEkg==", "765d9ff471f1d82a433bd8098d6d5cf2c136568f", "JdR77uj2C0zcjifRm694oSv41TafPcjRMQylZYf4bsGF1Ck3HvDlBlB3g77uCzG9xEbgA4Bpe52AZUTpW8xjDA==" },
  { "0D9FC2777DD5485EC744A358BD38E2714993FD27", "JCuCdZ+wvxLCMUYITJgWIk+ZA3jgaeUg8D4wpCHuuLc=", "VJiWv2TGufz30MjBDxHnpnNDR+kD8Ej6Y74hiX/+Z/gkK4J1n7C/EsIxRghMmBYiT5kDeOBp5SDwPjCkIe64tw==", "06cb5d7aef1634d900e0b7bce7ecfc0e1c92d567", "5M9klalStrX4DQaNgS4OmeGvb17X3uXyF1RabrALLroHcFKc7M2avSrhdKD3b25Mi2bBmxN34qQPC3sHmA29IQ==" },
  { "5E8D0FEEEF3DF17919BDF7D7BC6A951485D9F42F", "7sCn4oF0dQxWVldnu7+vq6XvcAmhDt0nqan9ozYzHdw=", "9qGHrkCF5GmAI6nmI06v5h+73EH3znTMk8ohHy1aoWfuwKfigXR1DFZWV2e7v6+rpe9wCaEO3Sepqf2jNjMd3A==", "a1cadb7ec7751622639f7a149d24546735e54fef", "/m+zpPwAZwWAXoVqgB9fekd/QVbyFMowHPVSy29L3Akz1/FY8s1DhSqIB40TBmpQkgqF2kA0ucexp6qURNH7AQ==" },
  { "B578292018FE00EDF9668087C68D6360117AD21A", "LIWPirkY3Y8Q619TtzTd0ZNNAAJ3IWL8ek/Cqm59tHs=", "vsrsNxvw3cjfLYKMrnpHhRwMcHEMVd5Ib5d5NMOrTaMshY+KuRjdjxDrX1O3NN3Rk00AAnchYvx6T8Kqbn20ew==", "236eab324ae8d87cd9de74173f613e9e80957d19", "qW7YEDYWTDOYSoovgdQshppI7GgCgFSyfsReEZleutXnvkq322Y4Ez6aMEtEoNMNM9J47jNEVEIeT4B6ARNEJA==" },
  { "886139F30D4A4FCF7160B87809078A382AAFA479", "mNIEXnVNBLO0QKKcr7aCJ/n+bTDVgzGrfb7bC7rwEns=", "YURHgAJRah+515I0NyCBfNQOX5XrT8eB0Ll3vVYNAPOY0gRedU0Es7RAopyvtoIn+f5tMNWDMat9vtsLuvASew==", "1745283fa0ba16cc397fe371eac9d7836137ca10", "GYGacHPtUs6+t3+aYmEA71/3au08ERw6kzafMGAuYNrVQ2fL4Dy1xVsUcYgm1iXEuwCm43vA4QnPziSO6wIBmA==" },
  { "ADCF0BACD351A883D7C28FA66764E4CDDD6DD99B", "THkGjxHb4RhZcS7k9wnI/UWbw0NugjMYB9M4+rNRrsA=", "Qh6gbKfHHLeGot+Uc+u0F7JGDlPOw8cuQCZHAzQHmnRMeQaPEdvhGFlxLuT3Ccj9RZvDQ26CMxgH0zj6s1GuwA==", "75c3549b333e094f7ca61a56aecb674507366aed", "5fZPjYHnX9kMba6x+C5SjU7rz5eiyGINXi/gIUTKLseuraG1bQQDd98dQdKHH6t5JktzF0UF1q4BJH/f64bXSA==" },
  { "88185A39BB5447FD437DE24EB15FC78F80A1FD88", "SY6yXuk8cKIrbFIY/2/XAsPUwfHTaXd9bnJsRh9sZyY=", "SaMbEYfB3lAt6CcCLqBAEdUdHMlehS6o9BeX6Cdk7oxJjrJe6TxwoitsUhj/b9cCw9TB8dNpd31ucmxGH2xnJg==", "70a3fc54099e55fa5d5dc1673b06d55959e73762", "pnlcVOhJTrfLO3UIIa2rN9ep7WYj/v2it3fWE7uz75oihQjSpMOlCorCnyUIxLPK603x7XcaezvaIe2H+Qs2Uw==" },
  { "001DE656C0070E0C4AF153D22EA78575C0D6C9B8", "Od3RfRT8+pxUT+itc4oM91YNtXts3fejNWKoLHjXfCE=", "xPR1y1LEfzvAvQOXx0S0ZNt/xRbzi5ZwBHaRfKp+5aw53dF9FPz6nFRP6K1zigz3Vg21e2zd96M1YqgseNd8IQ==", "3f44624525c774b320f2ecbefbe50e9f267833ab", "Z+WyKkrleOO7fkk6qyQGGwpKULXs/U9fmPAbSmbLfW7L6VQYm17cA2R52+l641mRuKmwNX6ijRnVw1YOVnfBiQ==" },
  { "B60DADFF7CE28701BD2C6ECBFEC385D2F5345B0D", "Y0pJC8HylrJE9M5Qv4BMqeCDl5/BWxxqmCW5rmXj8lg=", "BM6bw4nV+vUP2+LW9I/62szhvDJAaEzwEZCbu4PO8X9jSkkLwfKWskT0zlC/gEyp4IOXn8FbHGqYJbmuZePyWA==", "bbcf808a25aa74c29857244f79935f480b7796ab", "Chbi4KbTe+IBz6yzoS3Cyze+5d3JoIprRF9Q5l1aK5ma+dqOA92gKiR8G4P1v2BGh6Mpb5/krtAbkHDiKsnzSg==" },
  { "A629AA0BCDCC347768745C200E7A06059A3BCEB7", "8dKd2LZIkQQe8mnQJz7WXl5rgWwwFnFi75mKQPnY8pc=", "T5RDt/voRX1WRkn8QTwO4kl4+zJg3Ke2YywL9ohLF7vx0p3YtkiRBB7yadAnPtZeXmuBbDAWcWLvmYpA+djylw==", "658d83b0d0f18b05c24d2930328be8a286e0c379", "4t6NnEKOIR5iRsu4EzpU3VYqnU+pQGzDJlc1X8Adz1+1YJzis3vGHMBm1/8C3hTAmQIBOz7hz0tbeIbzEAvkMg==" },
  { "37A05A704A7AE0D1596A2E2ABB401CF6A84E23AB", "z5x6iGslnodhdF0lMUJIb3TLaLvSbBpCf2UeMlsVbdY=", "GrvXNwRTIF9wb6KE5z5m30NvNghxNeTKtHW80ld5AhrPnHqIayWeh2F0XSUxQkhvdMtou9JsGkJ/ZR4yWxVt1g==", "cc653b1c5cb3016566f511d1440c44c6adb4e56a", "o0RoVUMRWuzhHDXMbi9lJsfbdNgyoV8ikrd/sK2sZUbszyOuVHlI4ddrrFM4/T++X0DNkHu/cgZLudzOwrf89Q==" },
  { "B9FA377265D74C0FD6553DBC83EE19E1958071F8", "hb80NCcdlhXOpz5yg0mCp/Xb2lD+jr/3lzWJFJjai2g=", "EhBmvIt2eVxMnkyrbUhnYcMF+/n7bRBfd75Df30LrCCFvzQ0Jx2WFc6nPnKDSYKn9dvaUP6Ov/eXNYkUmNqLaA==", "b1ad15e52d9e458b421adbd4d7baf5e231863536", "GCsW52h5JSOr4PiI/7wcctzV/pfMt39tuhgNzYOnDt6Xt9HERUWE4yof/Wvu4Mjp0GgYCGJHhHOhFYUyPGrCbw==" },
  { "01B268DCADD55E17CD8018BCE1D78F65480C4071", "tf3a59BmPNwjM+jEZw8evZAJnOdRUsDFwc3pzHuYNjY=", "rDE6XLIL5uvx7RargEWd/TMl1yFUFqEDzrk9b9ccr+K1/drn0GY83CMz6MRnDx69kAmc51FSwMXBzenMe5g2Ng==", "918983d5f68315e62a45cb913e97e54202233fcf", "n1JnUtroIVj+jkmx4WwbtQdIwNEj8ETGGjSCPAheeoFOAeBvlxq2OuOWWr7hkDnc4zbPOteXpVoYH1LTXM8QWQ==" },
  { "AAA6B4B6A29CDE66594E573B8C920F9A6D90E054", "ikZbWZ4ZKgBrvRbh5Z1iV4lWr/xzPSvdjbLz2hlA/i4=", "yIipN8MUVqzaP/9emtUrGRva3Sw0ieEkxNm+rUahHfaKRltZnhkqAGu9FuHlnWJXiVav/HM9K92NsvPaGUD+Lg==", "01867c6896f12d71fcb0ed0368ff60ebe4b31ad3", "y/+2YgGV90rZzFOKrv/e4fzRxNn708sJZRhU7gR9k4n5Vdy+TFjGp3u5y64fAxZHAQUCTmsOTimZPeSnwnwFgA==" },
  { "D0AA726EDEA68EE4210F402532EBE44126B039EA", "5f19Jamw7YQedlGDVESYDG4ULy2KNaLzLq59xFq0wCw=", "v2e1GPiaSig/rWm784BCUtuYngH1p6/t6MGmUMDCNkjl/X0lqbDthB52UYNURJgMbhQvLYo1ovMurn3EWrTALA==", "2d8695697ffb10dade0ac7085283a92a720f6304", "JHs421jAWAQnOmzl3wm9yIdOgR0KcaqSjGY8DkrTKXgIf/ofw8T2o3d7FR9Htk22xV4sfDFLHe29pKSkbT7gkQ==" },
  { "9F41C900027DA0CBEFC9FB338B946F6A8D317034", "jlYBMEl1lMIRrOADNQnHatFtbjQq/XXZSCaB9TxMO3E=", "dWDB/vxNKT4lpGrLcbGSc4FibuO1ADnCQfYnT8PtmdGOVgEwSXWUwhGs4AM1Ccdq0W1uNCr9ddlIJoH1PEw7cQ==", "3d16591b664740abc14afeaba1a083545c584416", "J57vG/0yfyqHtAzecdskfwhyOWFHVGYjr51ShRopHRyqtrxy+V4lCJOAPUM8FOIjjJ6ki9Kj37tdMzyxIBexqg==" },
  { "D4DE1708D010F5A45EDD2602D3E7E2EA50C7A30D", "z8/zCpmEglKMoHiAyhLjOtid7ZeVTdwvl9qc9NKArd8=", "MAexyRRp05aQaNNfvVVf8JeN/7WvmczKCNG+IQrec9LPz/MKmYSCUoygeIDKEuM62J3tl5VN3C+X2pz00oCt3w==", "92ce799401005e842af69c152289601f48c466ba", "1txoAQKYgX0Kv68KPXd0G7xLE72DSG3viHpZZ17h2zsmCyOTFANPgsq9R4yZRHE6NfZEJ/UlALbJKpskm46zAQ==" },
  { "8CD5280A65E7C219CECF9F141E9F690426C3005D", "LjkyZbque21Y7kLK6we81JmIO8qqHPQIL4DTRIIdCd4=", "irsxJ70aQeyRPQqUDhYtSwPucqO3b9pX+nOvzb78Jh8uOTJluq57bVjuQsrrB7zUmYg7yqoc9AgvgNNEgh0J3g==", "751e078364f1c4c186b605876fd5f2db8ec08360", "qRz0S23yJ3KcC0gBo6LoRyKaTXOddU74461e5PQ1Oz+XTvWpJCaIJ3pTXS8IrnXoC/UXy8UYF7K8NeWSYdIU0Q==" },
  { "1C298B77FD205D9129CD8CAE78A68A089AB4E52E", "cLMWzNI7RqYyiWp9NqcISnWHqj6cwRtZodwwwRgF/+4=", "rpmjhz5DRKnZuciOzWWWmyuMW9ADelkuC9elkdMRC61wsxbM0jtGpjKJan02pwhKdYeqPpzBG1mh3DDBGAX/7g==", "6706e90ae7e9944c0afc72215ebe288cc2040225", "vnQrdXzTlJXZST3XqPi8RBjhKE2rfXc9FToCxsmbzoll0JrXLieWz7XagPUaBbu/VZz4NJmebqDEqeysOf0ZZA==" },
  { "31D12845D3EAB95520FFEE0DAB51C8E9588497CC", "klzkmOI33NFZile07YJOObOZnunMBDrcM5mVow34hDY=", "Wfwpb61EyPGZL6G6XHv45kO3KIXSMFJQkBob9C1JJ/KSXOSY4jfc0VmKV7Ttgk45s5me6cwEOtwzmZWjDfiENg==", "07446147166845cc00095b7faa72c160fda95667", "FxM/RFJGC+qjdNJy9lamwDvTuePnfWit7QEPSW6lCUwtF8/CXjRjnciNjSBQcUvoPevGcVfjdk0fK49gXUZ7rA==" },
  { "ED9BDE41FB8A9177E309A40D8E2EADCA4BD4E21F", "wSIfrVTpKQ4fWyECCNOuz8SkudTV1Rydn/CF2Z13Abc=", "1KSyRFh6Pgd/0KfbI5aG0Xh++3sJGrJWtkfOJPqeATbBIh+tVOkpDh9bIQII067PxKS51NXVHJ2f8IXZnXcBtw==", "a32153a15748c52a4de5838f4471b3a75f8e50a6", "q+TKTA41ADzFBI1U9msGwx4Z2dI9+r84ZoOm12AvBFLbPYymy1sPDIoFUzNwpwB4hNz7+4tfFihY//wR4BoMMg==" },
  { "723E009AEFB1B5C7736F5AFB9162C3329E7565F4", "+cZuwpNcnVddtu1sYrz1U7RXwhajUnApQF01a9MJzGo=", "Jwx5n35DV/TvSBXwsK1oPithep33LEkCcdBcCKFCyrX5xm7Ck1ydV1227WxivPVTtFfCFqNScClAXTVr0wnMag==", "6a9ef20f298fb9f4415f54060255cfcbcdc37e27", "sI3XmuSdpXASO0ODTzydvp2uX484weZPa1zpRTOYlb0BSnsKbK32tKdBbNrIqsxgVsq2dpfatD6sSB5uAmi3zQ==" },
  { "7D9C081C2E6C06B7B7749D90D9D92FCDAA091D19", "pTrxQbcbUaK3g+78lQp+JGFe9LUZ7ZeNFFf7HvfRTWw=", "OME3VCj3OXlFK80EYGeh6ROppqFK/IfljUFKnKj+xrulOvFBtxtRoreD7vyVCn4kYV70tRntl40UV/se99FNbA==", "93f27f03d627e477f2a026e5df9f2a46e1a024fd", "hJ7dnhVOvmrDkofvgj+DedTk9toqGtMM/YQYsPl7Bu1652Vh8S2Ub9F7+fi8v7jR6Pdyo8rnJoz2fS0A4XfXjQ==" },
  { "4C032EFD128808CD911EBBE5DB1672258931705B", "QPyjJbcwvloFczv0/VujtIb+o31zjloowdB/WZrsNRY=", "9kj+B0tIpZvx0abAMUJYqpncc6eb2UVn6XAS53HoE1JA/KMltzC+WgVzO/T9W6O0hv6jfXOOWijB0H9Zmuw1Fg==", "9fd859ea198ea82cfd9cb84901c33265bc979be6", "vJS3qPk+TG9clyoOxN97Yndzgz8bfnuc/3XsYbTTdgXhhTR8rmDdojexaZ6gN/r2yKiFkptKSpi5PRePuDzWpw==" },
  { "B576B19243FDC27B7E03DFAD9652F3D435FE7350", "bM6Z/pVkTVDwOlvwOYDCfj3L6mlQ2eNi5hQ9fzYmqW0=", "1qg7a62H8PxFcJtN7+fw+6d04Rz6DmC79Kd/hO66S5xszpn+lWRNUPA6W/A5gMJ+PcvqaVDZ42LmFD1/NiapbQ==", "8e9baa1dc033f00bddb5fb7ec7df2461343dcc46", "RlQwWQymIiWfnnCDFoHkLD4kppmyg1mPcVKw5rKlgXdmne0AYT+9gUSPL/K4V5BjOvvStF2RQG7+vxeKyZ/Slg==" },
  { "33996E9DE1FFFEE61F8A0368E0DCB6890E2D139B", "x8iiw+bzlMFY5gJndNsgUw+Q3kYyM2599SIRitDYmzY=", "agzikxJCuMjJNrY5UrfXPULV9k1wA+TFL6mTWZCQMb/HyKLD5vOUwVjmAmd02yBTD5DeRjIzbn31IhGK0NibNg==", "3efd0718e0e7b185bd4cb591077e561e6fc4e128", "SbNO06rpoOMZXx5mb47KpXJFrmbQaL6mdBhZYBHYu9yh31arzJQ+ZZOtMXLH6i/y0+g0fN2Lt+hroERVaBM+VA==" },
  { "F1AEF6D4B49DB062F0605B0A8E720B4842B5097E", "JMs26/5zh04AERCcwH8ykk/lyMu8/OMa6I1YlNelSSA=", "f7sHJrMM6vHkjCEa4hxIayDxt9MTA4ytSnSaEOVZIGAkyzbr/nOHTgAREJzAfzKST+XIy7z84xrojViU16VJIA==", "d34e2aa89a2d6438071c9c7f13a0cca7bc02aff2", "n/uZdojjkDAAbNCrBI1Tq9GwKuVlh95KlnwFxp3Tgv/jovfjxpGN4SVEkdT/jJfJ4M72hCPWv5yZT/FYp7WwxQ==" },
  { "26A58614D59FA7A6DE2DAE753D2B803336BCA32D", "UvEQVtvoRkRMSll6LoHxuMWQ6ngyakh7dmQ58fPBOMY=", "DoRlHHx/EzA1/6t9Ngdt3eCWYQ0Yr+b5U+JLXEtqJmFS8RBW2+hGRExKWXougfG4xZDqeDJqSHt2ZDnx88E4xg==", "12a64ab5a322621fef43127f54a5e6d00bd5b364", "mL990s/6bH+tchFLyNvUDTo7W+CQDn0294ankxwaeCA1jceAXNxDkATT+lIG5Wa3zSm5WzAUpFukcj260+jYiA==" },
  { "952702A017683D651FEE317A90330093EF0A3968", "f34sT8nMMC2rmTkJpmt9VSvZgf0eWRGvlwjjAV37k2s=", "5kkWRnh2a0w2wE/r0NHJLDmZA6acsmE8tKViRpkbhGR/fixPycwwLauZOQmma31VK9mB/R5ZEa+XCOMBXfuTaw==", "a14100b11e98113df4af3f165a27b02f84d4d5c5", "rY/68z49lkmM0de8O5lwckmH/X0NiIw6JuIOCt+FliXPpwRI5J8zS625c9OLHv1svUOHpdVQ8tmUH1nMNgJrtA==" },
  { "31D1C1B9568675651D703E8E3F965C041999B15C", "PrZL4PIqnFkhWse4RXTKH79UZqblXAlsFmbbUyB6g/k=", "77DRixiXtkbo9KHm9B+4zEn+exg2psMaUnPso9MftwU+tkvg8iqcWSFax7hFdMofv1RmpuVcCWwWZttTIHqD+Q==", "da83e51984e756296aa1bf128b20cc26c11942e9", "SlMcDLXuBXezO8K8tfj2tCpWoIj+J5OlhBatVvwDsrOH3rvEl29FQKAl1dgtsMELsYvnvHknCkHAvrO+5BxC4w==" },
  { "0ADF81DED49D80083DFF63E491E51E936A79ED46", "KosZKROO/W/kDibjwAE2mOplq/IpuBLlLVt/Gx3sFmM=", "i8qnPVhQ1+Q1wtNsFEtXs0w3THAXbkLVQmFX1JppsVkqixkpE479b+QOJuPAATaY6mWr8im4EuUtW38bHewWYw==", "32c4de3a5bbd6e8bcd485284e5746761f37249db", "Z+IXJSq70XCBG97uEglVHMRIwJ71YVwluOaI+drDpKYDV7YQxPLkp90NvdiScDc50xxOJIKyalja6pw2DFIczA==" },
  { "C0FE2051F798FCEA480D62B73C98FA890F84A2BF", "B/jKhOFQEG9abgABsecnxZH45eIucuGZvZW/Cm+a20s=", "rmUb/2dp2Jb+kb0UAswMf9pepH/FD83zs+oRoexTTs0H+MqE4VAQb1puAAGx5yfFkfjl4i5y4Zm9lb8Kb5rbSw==", "9b8b394fdddaa298b042110ad3a676ab6ad90bfc", "Q3A47UvmUDcfe/VKmiRGv1p+JcMbM+UGs6dRWckG18CiIxnuKqUoEvHK+hLJDY4m7ma94cyc8FCD/eI9CBn+Hw==" },
  { "AAC9135B765F3C7B9C39343C19D4A6D1E953A094", "9/TnSPJfn/nd2n10Ctvs3NtwrzPrb4r1SB7tlLpMGgs=", "xGPTtzyvRFSFvpHCFZt1WLNokhACayb7eiO9IGTFIoH39OdI8l+f+d3afXQK2+zc23CvM+tvivVIHu2UukwaCw==", "d4a1695fc8bea09602b91a406ff4ebad52d94bdd", "ebParcjf5qCGCwdhaYyiZAPlSafV22dalN6T5vREcjsv3388qwGiprXqq1hYw+En2d+633Knz9hVrBEOFCV6xA==" },
  { "4DF91AC7CE2343B8DCC7638FBC750EF47634DD64", "qFbZ93eHvkw8lOKeyIK8W4lmTOiC2REcAz1Lo6uTDVw=", "KhUHsPZ2KomObgB4/cdhlng32I6dcokmr132AZTMewGoVtn3d4e+TDyU4p7IgrxbiWZM6ILZERwDPUujq5MNXA==", "fa9c8deb793fb2d46bdba1b275890e89acab883a", "K9HaTzv8b0Qbcg3RPILqmDvqUk4JkfeF5XJcx/YnHhWiO9aVEZAm4m0Iu7IBTO5MNxn4LVocryXPZqxXqlNozw==" },
  { "122B8CDAA953D3EF7B31F13E8C92EE3EAC061FD6", "ga6zDh9/NeXHMLj4wRUJsbmQvh+ytHRrlBvLslspFfU=", "RWHIK/goVvd6laDaG4EpUMKjagX17MsCjbFmGwlGphOBrrMOH3815ccwuPjBFQmxuZC+H7K0dGuUG8uyWykV9Q==", "e796dbff7e554994ae6cbc1bccd77b8820694e54", "icEm+t8nj9CNQbXt6Y+47/xKZI3FeZi2xsSUJnn/cMWnbLxZ9ezrt65VNiGK9bFzgfbBQO7BjyHlg0S4tk/B8A==" },
  { "027524F79CAE7996854EDCA478789F20BA92E35B", "fmX6fwWGCsYzJbuhMwH6Loa+ZR9cPnHsQMszhelcXTg=", "dEZmWVLTeTWpMjUsgkIkSbbOx/9f4FyJxZ7bTsac2JR+Zfp/BYYKxjMlu6EzAfouhr5lH1w+cexAyzOF6VxdOA==", "4c6dfa33b7f203a7fb7ede202e784eca3204dd98", "80dB/dN2699OZ+D06JwjsGgHP3IfDPh5cMx188V4+Kpln9JG8INhg7J3kTffBKOB7U5V0nsuekMnlMHOta37RA==" },
  { "4F42A42755C3933C2516C3411E5108065705487E", "G0XjvYS0l4bzYdH8uM9cqgiSQ3I9qLStb1VRyOFVB30=", "Np5udpDVU8BOlZ8kg6S3RDU4cAQMZpg/MO8it0YVnf4bReO9hLSXhvNh0fy4z1yqCJJDcj2otK1vVVHI4VUHfQ==", "0767a1258dc69a5390ee2d5ffd6098edf53c596b", "wMbhcYq7ABv+UyWi3L0HXsQcx2iS+myg0nTPmn8xejmWy97yz7a6CEpsjofmy2/DnGaDzFJ+dfGzJILh02ohgw==" },
  { "379A3611616CD6FD7263E3EC08D300774C0CBAB7", "g2fIVIRZduzAcupe3GkqK2/Z5tWub/RyHjOhTKg+OPc=", "uCL3eh6QKf3sncg2xRDykb0Si28lLWmoWDTV1DtR2UyDZ8hUhFl27MBy6l7caSorb9nm1a5v9HIeM6FMqD449w==", "bd89c5c5741212926d93e49051fb34ef3d81781b", "97k9GWPSZ63eKNdMCOWfF2tTwfK+3AsVnClSZm4xwf/n4Trrpz5+OrnaM+ECqhE997pEwIYYEHNcy4dkejYIZw==" },
  { "BA803161A98BD076A033A0807582DCBBD2A399E6", "9QCxzAqka2zihq52IiBBzpJ7T4+NUCU01eq2voKVRVw=", "0O0vqLcsrg2Fyw/LaZMZfQCGw3OLIYFV2kuP7IJGxFj1ALHMCqRrbOKGrnYiIEHOkntPj41QJTTV6ra+gpVFXA==", "4a755684864470963ae3f83af6793c1c33571657", "Wweix0+u/D2DwmyjQhO5ZmFjleEbgz0o0dp2vMVOjD1zsFXugQ8/lOHDYqgqYRUTuocPiKdqBkKakZHFWkgVkQ==" },
  { "D11376B8B4F64836F87827EE4547B119A35A2A63", "YqktlZnIS5v7Oa6LcmY2762Fb80qrAH80O4uKTZg1Go=", "yWsfO9GRZZqzGV/SGUSrJ2Zo9doBQi+jC8fB2alHPuBiqS2VmchLm/s5rotyZjbvrYVvzSqsAfzQ7i4pNmDUag==", "602140567027f9d72e871c4e573c9289cbc79006", "I+4vj5zwD3bvs/yH+UT/Vd/uxw0r0pqWUNYPBqPAJShlSuFpMhwBXdfx9/2axqBm9Kd9EOvLmOsO4jEk8Hv1Hg==" },
  { "0875BE75331BE1AD2BD73D28FFDE03B87B348799", "NV9Ow8e3pREaCpyDmmbpylhKa/Z8K0rhA3d60fyiN/0=", "1vPRetk2ucAPdpNkP7Y06BzOV0vNv9uvXsoCRg1YGN01X07Dx7elERoKnIOaZunKWEpr9nwrSuEDd3rR/KI3/Q==", "de772d224ca91af72981f185baa6d1f0a9db6ad6", "5JXEvYE2DLXkWnXzCNwl2T//71gTSbbpfBEDXJfmksnATCp9ERxu8xldARnO0KKrfFijUviv/m9CwyPxTjdxNw==" },
  { "B342E358508F3E11D41F1F72C43125B3C602A0A2", "9weGZJOeEEhjGTplRtB3f9dee018BXJ92G+xCI4W01w=", "nYwZq8ejocJ1gJ3bf/D6WLDtKoVG2QJEhaJaXeIe3633B4Zkk54QSGMZOmVG0Hd/1157TXwFcn3Yb7EIjhbTXA==", "2dc3e7be8b0cf0be855e3e5c5e54f42846057ae5", "DwzZWlnJKo/LNkxb3MZZd4RKfn9fvRthWX1ddHJ/0J9Xk5wpFUy25+fyZhrE5htQHFilOWJBIJ6EQajDwXfxRQ==" },
  { "EE4E24C10C2A14450126C6FC4B21AD075465B2A5", "kUBOHdmA0c03VdSlf0ARjZ0jb2UeYT3HBvv3J0kWu+k=", "/jw78obvd3QbweWvFP77WjbsBreMFkSutT2opkrOw2ORQE4d2YDRzTdV1KV/QBGNnSNvZR5hPccG+/cnSRa76Q==", "f110bf46d6a2c788247e10ce81ca47eead659baf", "YQoj0pq25mj+rAIflJ3Bk/jG+idaFt+wYnP2K3hUfBCAhHLv66HE3ikEIDDV5yn16sq+ZxNKjyRiJxV5BjRalA==" },
  { "1AE63F185A37BA7BD206A1A44E9506FDA817B52B", "Ou0CysfekaoAKYCqZ9aasVlXHJjF21fv9DyCEFXbwGw=", "A3aXENlhM8C2oNSCooag3ueT21WIq25X4JEoMlLSbIc67QLKx96RqgApgKpn1pqxWVccmMXbV+/0PIIQVdvAbA==", "60800df68e5254d8943c0210e34b130d767c725d", "w4aHfdiAd12cnbQ0ozqitMr/igWLpcs65mdbsaLGbiaZYwv+kD5LB8fKF9y+7N2UQtZcVrzrwRHBdO6YbU4Yjg==" },
  { "35A6028EE40C0B0E761BDC099007AF7F9F1F544E", "ClLUkmShSPzQS39ikTOLsj9PB7K2Q8Xng++o12y+gBM=", "9LDHYBNRbAnUc9NgNOqxdnmuW3tjedDZB2U7eEM8xDYKUtSSZKFI/NBLf2KRM4uyP08HsrZDxeeD76jXbL6AEw==", "86c7a8f8b3354a2cfe95fb693b3fb1cb8da27d07", "Z/30dhZZYJi5YBM+RrfjSqAv9Yh8zzEnj4/irWpoE0IT85Gl7/dU3cExv9gh3sq/FMA2spWYSnmR3J6+gBw/Bg==" },
  { "434144F13859334F0F02D5E93D6FF652A2C658E3", "FEGVc0M+WG1t7usCf4ogjmkleoi8cZZt7ZeTQBSoFQ4=", "+WvKSrD0MhKVeayY+MUwoKHfhPn+QiOK/2I0CapvyyEUQZVzQz5YbW3u6wJ/iiCOaSV6iLxxlm3tl5NAFKgVDg==", "9a547fe203373d7a65079aa80b95d054c72b3c1a", "QOgBDrAd2q4lln0qEsAjQsKZ+offHQl4iR7cV5ZIwpVOW3my/x2105daPrjBh7jhh9ZpJ9YVIWLNyvrzcMLYQQ==" },
  { "9A8F8CE8FE36DA33712D418FF3122B8FBFCBD71E", "dFEZkV7ewCxPYXeq+kEV5jXROrJ57EQmFlF6HtBZk/Q=", "x4kroWXUIsf8HTJryQwMU72W7WxJfMXj231sbw/bSBV0URmRXt7ALE9hd6r6QRXmNdE6snnsRCYWUXoe0FmT9A==", "7971145e692e4035587aa9528a0c1e4648e8a77f", "Mr5hGFoUo4hC62ASIeYsmadOnG4qrKXF0HB/UIncuV2GzyqRdXI78ilgKcAl2TOs8MaKFyRmLvyyiq+HoQhx5w==" },
  { "566C7C62BEECA941282B471380D33C81F68130E6", "g8bNE7Cc3f8wAENri2XiRdyEc67BSEiObHan2SXmlEA=", "FJ8U3dXq99J050vJtX2+aX9VALvWn1krN6r00tRmeMCDxs0TsJzd/zAAQ2uLZeJF3IRzrsFISI5sdqfZJeaUQA==", "dfb6e6e162a67642be2686fffce2f12415d05677", "bTL1Q9u3ckYZfmIKrfFlRbNiTdHKv8WkigJZHj5/k2qf5gwxEG+a5ZaEnzoibXLAXTmzANU2vsgS/nMWz49Rbw==" },
  { "ADF052BDD791359C1F2EF27654EF653CE2C2C725", "L4x6mtUwdUJoFV8hikUK5JnxJ9aiM42UEmaBzzDGtfA=", "rUTQIvl8Rkgqp8rXoXwPxCfRHQp9anrhxSlYmFgLyuQvjHqa1TB1QmgVXyGKRQrkmfEn1qIzjZQSZoHPMMa18A==", "c811a0be67107ab9046317163b488e6e3d10ab60", "BgPPQMbBmeLBC8El1hHqGDB0pw4Jb406b3DinQtZU9K5tCqdq0a3WsFKZCro1Q6ozmOJE4kZezu4zFmbCcgsww==" },
  { "3ABBE1DA78C0250A7038DB38C70C8B4D0E34E9B4", "B9p0QZllEc6mthE7tqrG9H3oiuqATCRwufZWMfbDMsE=", "jDWLTsRwrOD9R+ZTL3BN8+4djC8QS7OPrr4ITUkIrfsH2nRBmWURzqa2ETu2qsb0feiK6oBMJHC59lYx9sMywQ==", "94356e3e48f9a2ec48636d3e153fc360497b7b09", "eimquM7CZeCzRFD/gHFT2C3WlzjaitGe0mAUHrHzjJMCVRHGwqo6ZMSvw0htujkg/1UZb8Tfg+OVVjbUjRYkzg==" },
  { "25BAC9E2AACFE766ABFE88B73B73947927482D3D", "PRn1N/4+ZNylZ4r8I/tg9ra4veb/jBIeAh7HKul4Np4=", "df5/ZbowlqWY2wdBh1kaDfIXn9IqCAbQOY2aydHmORE9GfU3/j5k3KVnivwj+2D2tri95v+MEh4CHscq6Xg2ng==", "0474d5d7685d7580f6a500fa0392d5cf0a5957da", "HZgBpcdoqe54xa1pNrRREY5QnPExP9mq4LwITJkJ5bNqoqF8UsK4gl2DluuckyBU0HwSCcMPTTq+vVw3/4HLbQ==" },
  { "47C5B9BB1F9E76F41807B8C7CDC34706C8B7726F", "pc1n48WbtNpeDkAWmVHXiDy58t4YnY21oN2bmBy48vU=", "8f1eMkGA1zxtAIFv/nRwjiVaK8kgSETwgZOwoK7CURSlzWfjxZu02l4OQBaZUdeIPLny3hidjbWg3ZuYHLjy9Q==", "8af9fe606af87063d62a7185a8f0c56f7acd79d7", "M5TgulrB0Zm9/m4/JMF53aLhgAVCw7eaLaJ+HDWsaVES58i6IIMfHLTMAaqABHeC+sgyDkT4ndQMOSQpQKa6Ww==" },
  { "41C9673FD8A42EB6DE2C03636F281B50EB62C70F", "SCYSpTMBXNYRN/xa+SJ7qfD7PgSv4QGq62D7/owJSEo=", "z1U4EoQoXOAqK2mJU1TBhF2Pebb3NZrYskoMdYbtssVIJhKlMwFc1hE3/Fr5Inup8Ps+BK/hAarrYPv+jAlISg==", "c35adde00f13a2a58b6b150680931d89250c0ef1", "sP5OwYSO/9hWKIrknQLaeZU+Q8yCjNSxKXiu/jhPUwDZleyt/OBYTpIycgVwP/YNkTrPLKyMcwVVWoAdzH8W5A==" },
  { "BC2DF8EFCE14B5554C5BD02CD359110FFF6BBF60", "IzgotOPT2IMtifknDGAIcQbAmAXYjcWBGhPa+xu6ksQ=", "nqd+LgnApq+wLMGbY3WI4H3iWitMW17GjykPxtVTIjUjOCi049PYgy2J+ScMYAhxBsCYBdiNxYEaE9r7G7qSxA==", "b664372842cab788aa1c6b04871364590d203998", "Z1YTYdpOd4FK+fE+xCkv0/d2MdC1Jh0lQ+60q/acCZv4vKEXzhOa3OmJXoMoS8KeITaG2XelAMYAHUxUDBJy7A==" },
  { "FB64FD4EFA8FEF57F08CC65C7DEF7B2DCEE7BF33", "ZlOx4V1wZ3lVxPBW4Xj4y3KdHoqD89s6TnZ4YC2MGBY=", "kjk75YOqvnGa7uT4q2uP5o7HYX0NtnuMUaW7bQxn1KFmU7HhXXBneVXE8FbhePjLcp0eioPz2zpOdnhgLYwYFg==", "01ec49ea1a42d899ec69c86c75ec04ef87cb80e5", "slEWyGy2eFVZjmGa3GkVsZVj1kpxkGsIU10vtlRkTU/web0wXSxEp1DVhNodE6OsFidSZWMBESCPVnR9mgfASw==" },
  { "A863B70DD93F622C6F1A69E5DB3AA21587B14A8C", "sxStmMBtAhLxyWXz9kY6QXiHFJHTjfI73AlY1O3U6AQ=", "ycOs7rMkqU/ILzQ8sRLPCgtz4fyVbeVr3hvFs+eRzuCzFK2YwG0CEvHJZfP2RjpBeIcUkdON8jvcCVjU7dToBA==", "33decd0b0fe3de3328898872f02dad6739a1c389", "KpaHGl1FjVoCMDYmfo91vDeCFff6SgPaXMsrVS0YpalBYoO8+2raPRP7/pFLw1YEfy+4B25ovp7C66O0faY1dg==" },
  { "E95175BFDD7931F1923902F194F4F1957E478C52", "LQXBcRPtMwbxg6S5JXgbUFz8H7uaCufftG8lUnJ3HZA=", "ha0YKhT2RPFx8/OAJnKAQUqT+bDfOR+xhdbHSW2iLgktBcFxE+0zBvGDpLkleBtQXPwfu5oK59+0byVScncdkA==", "3611ad1ed9e81c8e394602f6d57135e312622b6c", "kmp9KIAAebVekmVZwdxX8J1cCKiUEKOY9n7arE9/P6vHOALhwxO28Z1BJtyjcD/wqcb5zLVoj9UYlbNdU0qhnQ==" },
  { "87513C36E0C8AEF0BA016D651C2BF8469A5018CB", "BWcikZTus+Y3j+CfO82L0T5d7Shls/fJAIClKoQLgU0=", "twjBNRPXlD6bc4lb+LpWJmhSXeHC+I07Rbma0FkZoeAFZyKRlO6z5jeP4J87zYvRPl3tKGWz98kAgKUqhAuBTQ==", "fa2fb72f5a976bfc03501a8a7499df993cc09a42", "58EsinSz6dn2g0zYRAWY5MB7tj7Im7L3hCkjYQdiMAOvv+nqTWy1nCcIrcfuEYEWoN900GbfR+zSzR0Icnt8YA==" },
  { "00027DEC8C0A12CF53CFC0C35AED6E9F017E6D40", "6fUCstXbJyEijs6ntps7edlkP9CunTwttIpQtLLHmcc=", "0Cx6Y3YtYR2s5GAYKvr87gu1FcQsnsd9xmiYxNG3EaHp9QKy1dsnISKOzqe2mzt52WQ/0K6dPC20ilC0sseZxw==", "2d65787b62652112b9efd04500827da819e5ea37", "WZqEoYRCRCjwHcSFdZbCt4+xyTCFm9wQ46nDsSxtKOBqCWn5tnWb3l5gT4RQOxMZcnD5fXPd9eg+fvMaKqvYKA==" },
  { "854F7D123CA2D605031311F9FF7108DB43ADA75D", "hNzoT3BAedHdfkHtiaBM6qUCx2VVaDK/+XI9b3YVVeU=", "ciLY/UV2QfbvGKw8RB0XExt10sTUEKsHoNtMvY1DASKE3OhPcEB50d1+Qe2JoEzqpQLHZVVoMr/5cj1vdhVV5Q==", "5dc9d0b74fe18901a9e10f62acdb871f1a734cb5", "OECJdmWD8u/n8M4HNiSO2SYd6nTUmu8aaUTJYTaiAuA0q4ttoPHgp5nTfn+K5vznggMMVRXe+ISMCerDzruTnA==" },
  { "D6F87BA47EBDFF3C75290DFC7FFA58AC50750965", "MrHnTiTkhkSpFF4bv7yD4S6MPq7WbSRCSMoklMyMCIQ=", "KlQgvIeqsuqxpWH+eV3LNhBOp/GXGONINj2d6f2kbKcysedOJOSGRKkUXhu/vIPhLow+rtZtJEJIyiSUzIwIhA==", "23b9f4d119bc491d5ced4665d510cc286ab9e665", "5p7b+ItWxpew5QUONuaJkCYZQNbCsJHRkcsg3OuUzP0S84QbDRd+Ee0CyoSvrOsj/g09plCyGDPZEk8QTzfpZg==" },
  { "01E0B71D1DA4DDE52A0155C67112B2013D68737D", "ibLJ9ashLTLTGuQfB1BK7tDHd9TgTm9HJGMzu8VU9ME=", "LTtZh+KtIs7DrkocU2wAHii4k1XanjnCHgDNehQ2Az2Jssn1qyEtMtMa5B8HUEru0Md31OBOb0ckYzO7xVT0wQ==", "ac99dc0be5804440e8e9787f155c1dfcefe98251", "+ciBFHIBc9wjJIJKxnDyZf21W5leoLnV+M10cPc2/hNBNJQRnVNMXDrQhq8HfFtu2rnHN3SAtOk09/OGWKIpeA==" },
  { "FCF09298619B7765F7527A77942D93607A9E3618", "hWDJYDRIsbuPObx7D9aX6gkRL+6OTp1/LuZ43NqN+2w=", "Uhr+xwuavfOLFudqYunTR+g4tnac+lZ4soHwLObhJUOFYMlgNEixu485vHsP1pfqCREv7o5OnX8u5njc2o37bA==", "4f1a9fa4486ab53a4708e06367c1d31d313c7af6", "FkVrZw/QxtI+rYT8U10pnX/C5i5t/U4f6egVwohnYcpf8Vo75o5XBJhF1TJ4sjzqUmk1tS0mVXyJx1onrGXNNQ==" },
  { "5D188E1348EA4800BEF7AD03E6A7764CA2482B74", "WXtsiUbep6sh/MJ/ns97R4CJvuzINtRRyIsyEtxbysM=", "BOwMz1etva/2BBnqNH0Ee/15me1NvDJjhvoMF3Q02LhZe2yJRt6nqyH8wn+ez3tHgIm+7Mg21FHIizIS3FvKww==", "6c2fb476e5a9874d709ae9fb0cb7f1fe4c820635", "q7rOsyV67Zoero1sj24n2HKXrI3tL0+pmSglYsJ7Q/r4EbQMKVmeViP4sbyiQ1D/cQXAimRDXmxzxS29R+NO3w==" },
  { "E791D3055B378B0B2A98BDB8A0E3CA47C529E017", "wbTq/1qkzUJEYlLz1f1retv+xl1NHwwUKhdN2hYCaEc=", "ipGXMwLHaGdcggao0/JXW3bpj16DQp615XvXW171dTfBtOr/WqTNQkRiUvPV/Wt62/7GXU0fDBQqF03aFgJoRw==", "8cfd552224f2ca3f22ca3c422f48af21079195cb", "pkzR/azpj9xl82mgGBqSbo/f38txjaS1+181J+ugK4qqnZRG6uwBK2KJ8G4xsRvbi4obKHzvr9eoWmxFC8CcWA==" },
  { "020495652B73B04ACE1F86206D29BB107D3843DC", "Dnuxv4RzCfgvjHY17bi/K5hsaHmOOm22K55u3ZWI5As=", "7xtcD0E75oe0kMZBLyJz2Ir3xV4HfoC7u8n7DvRFnQEOe7G/hHMJ+C+MdjXtuL8rmGxoeY46bbYrnm7dlYjkCw==", "8dbc4dc025e49b6596779637f87e57f6e64f7e09", "JI7VJFSFkDILVp4YBwkGOBkPnc0u9hRdlOlrLdVCIII8ysKYbYDES1+HTM1JJTrF1xm1j4M9XXwcHbNOk+My/A==" },
  { "F99A62922058E919CC6C5A831DFCB5069F5A1108", "6XEdLYl4SiHkxjNgKn1zp5wIXfdzfFkCSkzRrnLqtjA=", "yypD9jIiGus4Olgc5sRubRHvyqZzbbLr7vlqJTMNUITpcR0tiXhKIeTGM2AqfXOnnAhd93N8WQJKTNGucuq2MA==", "5d81c42dd7d5e531861a96096b6685652fc3c650", "wgsq/Flsp2qRrTqSk8xqMn4HZ9tet+wswYZwFv2Mff7DgpY8+ZJt2vbpYhjWaxXph1CvxZ0mNN/urjQSuOydXw==" },
  { "86EF1B12AF7C210E90EABCD6BE94E04DB9040810", "hWuKV6HIjrqbRci5u0y9L+10r36352VLpJ3eIGCMtJw=", "EvqRvbizlvJXxBLKHH8FM3RNOlvYr9W6A0/FAk5AxDCFa4pXociOuptFyLm7TL0v7XSvfrfnZUuknd4gYIy0nA==", "043cbc9081968d2977837bc5663fbdebce7e7666", "3p2qgGzmrtoNsfMmZldLGInq5B8yECOjQs+L6n0c2Zi8ubgXidHJTeTKmTE4vlo9ywO4Q10hLCWpEGrm+TJNkA==" },
  { "AA40A82FFFADB426980C63511696BF277EA58743", "KvxhZB516zn0rWGGJ1Kdrcgs9Djn8meWB/X+jwiFfGA=", "Lmg7RjZlXDmymeHSHPLvxYq20O2t+gQpr5YeVuXY++cq/GFkHnXrOfStYYYnUp2tyCz0OOfyZ5YH9f6PCIV8YA==", "a330b77085fd4a5113ef5ed499194aadf0a91d3f", "n/nZYIE1/ByGT8Uc/C8ZrXeR6jNmHk8JtKePWtTQ09+qt9ja8POTshYvWzOMdLJ9/qiYuR/a5a5yFoo1/0jqiQ==" },
  { "997122701404035E44E43693521A1022FA37E979", "lRWEIH4fhbtQBGU7QoRUVRLznuZJ8bSgoA8to20icKM=", "kNquz4U8+KaBeesmAZ7gD8yI7H5FgalWIOGewn+f6qGVFYQgfh+Fu1AEZTtChFRVEvOe5knxtKCgDy2jbSJwow==", "f206064f3875e4daf2dfeccf7fda1b030c5d4fd1", "YjA0ZARN64Udhsk5+ml1AKo9W5bhWbQIpTCnnfaHKdF6LS6hluulK+UEs+aHZxYfAT7RODYM7zF+tGMGlpB35Q==" },
  { "F732BE1CBAACBAE5A1CEA75887A0CE16274A8BC9", "LNcUOsQaQeV+9zW5GRYhnjrvgO2OTElXPTv8+34AiTI=", "dgo3yaSgh9676OBA9YMICuTJnXx08E1MmZzK7+wkr9Qs1xQ6xBpB5X73NbkZFiGeOu+A7Y5MSVc9O/z7fgCJMg==", "9035383cfba4523358641e1e850a103478dd768c", "6fo2eQadMWcP/t2nytkk5pmc9TIW0rIEYB0u42GNfJpVYCa6BnPFKr+bSWHhj1gHpHe/jIFUZRpOXKoMfQVSFg==" },
  { "E5B1D9548BF4045D178AA5A2D3C7AC93D02EDB11", "TfZ7DMdCFmRSLCypdduLPB6FRlliTg3DDSnI3yIlfrE=", "K3gnB+dG6QpkFIYFAp/eBtRzSEUdtJK+iPG88icQp9JN9nsMx0IWZFIsLKl124s8HoVGWWJODcMNKcjfIiV+sQ==", "57a8f92798ed6c50917fcdafadcbb7f20f9a6510", "AzfyoF3zTDKZ9amLfiPuWDVL5sg/oBdMoOdpECHdGDgX4UPwW1jBOSCFnwXaJIUfJoNNiB4qdBdavxAdi3JcAA==" },
  { "3C2ADCED6B8E7A3E6169A95A2918F337338BD0B4", "Lak93PNSvCeTJaQ+8LhY6j0PlB5wN15j+uxktTf6534=", "SM9nuKB5crHYYBkMpoFJVo5oAKyq5aF+xKTeYcUpdPktqT3c81K8J5MlpD7wuFjqPQ+UHnA3XmP67GS1N/rnfg==", "3eb57303d93bc26326a26aaef54e871dc1159149", "iPbCQFbcHMZkya13gTbu07nHsY0JpdvyphtV+/GXsHgTnTUKwcLb1o11f+xWXzO0wPTHNQuQnpVhMavj0ejUpg==" },
  { "9922A80AF56ED57B78394EF1F13195E916178F39", "+/ZcEGE6o8IoRVLCFOaLXC6flUyQfanAwLk88mGqGDA=", "xAFsSzmUuvJxBsYUNV2ZxlSUC5lU/rtTK1w8M/fVRQH79lwQYTqjwihFUsIU5otcLp+VTJB9qcDAuTzyYaoYMA==", "b334633a857101cb30b4645205cab3668a6983bd", "l0dXP+S2BTpObsjHNKfcMgv5hFyI9YCRWBJOh9EBgBLBvoU7Z7WEC09clvkFJAOQ2xPAmXtf7r0P3TrQstAMvw==" },
  { "F23B1048B085E85FE831E330AEF50992C92CC412", "VXFmHP+j+Obt+uOSSzC1HGDRSiiqo5EFEU7AG6O7EZ0=", "d8E5oTswjmHSOJZuB9sC6J6cj+mEqBLq0w+CV+aiP/ZVcWYc/6P45u3645JLMLUcYNFKKKqjkQURTsAbo7sRnQ==", "020cfd8e49b42742b1cfc66ed8c97e5eb9c9b3c4", "PB+XIqCi4fTJ+bH/1E9IhU//a+2fbVJdXOk++cJ4cz1dVsYCCXmzxEldGg+u3PHDt1WZgXsp+hqPxH6PgitxqQ==" },
  { "87A1F8D53121DF568060967FAB6BF87150E1E85D", "vH/liaSI2liuC6hG2AglJ/w4l+e+AOKy1MhuvqIsvn4=", "luX6cPSYadFHZdl7yA0/jiJdRACXc6J6ch2IDrdeMQW8f+WJpIjaWK4LqEbYCCUn/DiX574A4rLUyG6+oiy+fg==", "dfa3621928bc9ef36cf6dae02555f12c4c5ad013", "a3oUscIwb3QTC+B2qBNT3a9t7LLA1aM8s1hRcag3mPrNetZxXHsnJD7OzauVV/iVyOoX4UT/Dgoqork13OADFA==" },
  { "F5D0F14BB0E366602B094744D79EAA73202E51CA", "z9CM30xmK/PE36YSpweuk53doscRu8sFbsZ9LLZRigI=", "BFLUrXG2ZP2pjYG9dyOagrjr3xr7Mj/8HBBfAFMzlAnP0IzfTGYr88TfphKnB66Tnd2ixxG7ywVuxn0stlGKAg==", "a8a99f62d70de172bc8a3faf98e6194f364dba07", "LT2IaP18rZEDen03kWvvOoLmLG319lg52P0tzCn0rsQ2RQUbt51MRs6Aljih3ZHrhSHRRxLQ3XvbUVrAmMnE5Q==" },
  { "E8B05EEBD8536F0A5C717C1DE185ABDABBD2DCE8", "IThnvA+YHwhyaPwdy7fTkH+aM+g40bg1yHwBZn9k9hw=", "7GLMCJ4ctyq2doxQISgEJL9JigxQ0h4dp8MLzvjfZbEhOGe8D5gfCHJo/B3Lt9OQf5oz6DjRuDXIfAFmf2T2HA==", "d5cd287aaf38990df5e30a9c104c9ff1c3b9b406", "5rPmCbEclLJgyaPQ9oWpb+4XiGVMrCfIRFiVRGUDQOucCxNg0ItCJT2ao2ycZYhEyInatQSV1lxUcWv9ADyRrA==" },
  { "DCF47F6074B399CE27130879E180208B60F7CAE6", "XbP5Mbj6/EuS6TrSQilR00Gb2wVgXUSFs4jPDJTob7o=", "6ANDXI8/jtHfpQTYaTMPpyzRcyEQPN5j7S9ow9GvQ81ds/kxuPr8S5LpOtJCKVHTQZvbBWBdRIWziM8MlOhvug==", "3ae4216a9a045722a2a02b0c13de56fa0917425a", "9/d6THJEzWu9GCH9mFhjD+7QP+Tia6+QLoR38AQ/4PpO1jgrXlJtlNhtrHZunPKQrkVjZZ11J02w0Ht86Zb9jw==" },
  { "B250FE5AF913F4B1090B7567F095581DD39126FE", "EW2Yw7KOHsuUe1qiUQPh8z4LDV4kkI3JwiC1YWrq1jg=", "jjJNikpgk8Qftp30H3wGH09vJkBEd5bLPU8WOpYEzGgRbZjDso4ey5R7WqJRA+HzPgsNXiSQjcnCILVhaurWOA==", "fd25f0613d0b594230ae60467256d444a7c81f76", "/SyvILep1Id3wI2FSbBpd9kS1RO6ZIDj1yDusGJmLV/iBm5+6QqBKtiYTFe85vop0/5ySttP3B4il9CTmpB5ag==" },
  { "43028D1677DB24ABC7C49C07AF07048F0969F559", "Fm3iGKlNp+QrGJxnzuiWUA73Z5hEhBdX7m93jfaig7s=", "J194f8dmH8dksW01N+wlhcDeiUA8q8KGnpzHNfc7g5oWbeIYqU2n5CsYnGfO6JZQDvdnmESEF1fub3eN9qKDuw==", "5b595ebd83c27ee6423a81201a4f8b5b35352f55", "ZNhvccKYjEY9enFj0NjlAEYawRka1GUqPo8kI/2IbWl9K/JgV5xkMyE023DfRxY2tFHe/LtOOtUauZxJeB1HlQ==" },
  { "A7ADE5881FA25D86A60FD7CD9B728DA1674CA0FE", "FxXZJF9bTzEJ/h8b1saFrBpUkNrBipQYD1oy/gL1FFI=", "CKLJanOTaBBPo+oxINXQ+z5e+RVgUtU2/oqWenj3pYIXFdkkX1tPMQn+HxvWxoWsGlSQ2sGKlBgPWjL+AvUUUg==", "564c33a6cf576c59ebd6aab9a2234219c887d0d4", "5xNfxzsYoLn4OzlKl/3PL9yz6li0xAHsCO1ddnGHjVLNhd9KtRZco2fkzV7DakxjZ9qzdM3U0E0qsoQ9Q0E7KQ==" },
  { "F386BAAEAFD4965AE2F3F94E38E19E82C68F873A", "zTTcssujOkbJrZuR6SzPtfa/KOI2nyS14yXxxA7w+fI=", "brSU+Eo1BvopFDgZt0hL/UwwxMMxB3cE7lPpEDLrBnrNNNyyy6M6Rsmtm5HpLM+19r8o4jafJLXjJfHEDvD58g==", "26771044198f951579fe129df64d492fae9426fe", "NxEyHzHz67SEOaTt7O/hvctKVK2ixeg5JqC2lHmt0UtKuZrl9N2ILEr/+Xinfr83AiMu1bNemYmUYjA18IgaqA==" },
  { "B5E64739214B5DED61E35B23F08129B9A8E2175C", "fqMJWynlGFc7XabVVosD+VS3jWVMhCWHi77FyuxVGSc=", "6UjQdzWvWcjGb49ES5PyVmgmTCAuMxchyU71xTbqNH5+owlbKeUYVztdptVWiwP5VLeNZUyEJYeLvsXK7FUZJw==", "3276f8d109e2e1884f6c6a041a8a40d6f9266685", "Pg+cyparPlVIoFsmO7Ow995wQocLwkHLljKSeHxQ3X9gBaKWfAkL64w/nMg/E38ltdMz/XqdS/LlU2dOiv7TiA==" },
  { "62CFF3690F459EAD0310035F91786C4D134224E5", "w2PWoNsGFnorxc+rNjpYECQJ8i1HmBXH5Fl3ot6Prww=", "4wh3ut2HsYD/X8Hkjgzlp0paeLNuZCnYGSN/pJ5ftlLDY9ag2wYWeivFz6s2OlgQJAnyLUeYFcfkWXei3o+vDA==", "6abc039583a9aaf1946ecfd1e5490f59f253b387", "sKfyP6/6nbxFcVoKncacWCyLcxqFMyDlNdLfzFQnBdxbmIFZ89C1OnadtlvHsDNZPqLIe+zr+fbaz7vNX5zlSQ==" },
  { "E0B75779E5C257EA2C228E1C511ABACE27A3A68F", "7w2yKAJmeNefJvJsUJ4ain1IlT9p8QLvWpollNXxBFs=", "4qjcslm6k4EWSu4iy8QRyvOJOUtmaRp+5xKbI+B3hbfvDbIoAmZ4158m8mxQnhqKfUiVP2nxAu9amiWU1fEEWw==", "3c6fd20f86b941120191ea93bdac4a9f99985ece", "p7eit7JB5JZ/JASm35xzhr4hFniLCEDw9IS5zED5Mpk5JKQe3Je0m074OZ3q9SHN7ha830bgwAOEmTqF6CAvWg==" },
  { "E3EE9C6C711EFF07BAA201911D2CD8CF44D5C64C", "VvMiXPBpMhfazdgKPqJxHnVew/6ZHEeMrSmuIg/kD20=", "pa6/0BQMve2bIhLe0fWS9VMw5vPYwu6L04DMJwrN6kZW8yJc8GkyF9rN2Ao+onEedV7D/pkcR4ytKa4iD+QPbQ==", "68207156fe63a50ed088c41d41137dba7cd0a846", "u7CuR4OYqSP4c55aN5+GF/9iLrkTN02plyt1oUnpam9boWV7ypv0aL1VnP4Tkm+xWtm4JwW9+B8LMR2rULwFsA==" },
  { "1A658E6B6DCD64818ECFD0813C71FBA9EB30DEFE", "i749Ct5Lt6i1FpJZVJEjzuH9AeIk+scgfmp35ftvHfY=", "YIjEWH008d7Bs685GFnuI4rrdUBoZ+7NFxP7pDmYpWOLvj0K3ku3qLUWkllUkSPO4f0B4iT6xyB+anfl+28d9g==", "601c596409d0e41f6d9d3aea49691d10c6fdb9a1", "4Oq2OKNePLHQIkbicfx2dNQTLVyagBKroZPx/+DgLHGyl3AYRu//28+goVVOgP9pcJCbHQIFM7r0GdBbk6q9Aw==" },
  { "FA1BCCFD47B6F785B17064489B433D2498148A65", "+2cfM0Gcon6gJOrHadQE7I2LURWqJLo+Glj4b8wjMIw=", "VSor4Py/cAcxEprzEt/JjHW+nxgdrUKGRYwyab5j/HT7Zx8zQZyifqAk6sdp1ATsjYtRFaokuj4aWPhvzCMwjA==", "7932bfc7ba72717c598de950fb24d91cf70a150c", "wLjIQDDn5Sejtdm65oKPcwKhFLG8Ig3C6m27NpTnUeQiLzo878WPo5wuw+uSI5q2VwHIEXYMbXYtc8VDtiMc6g==" },
  { "634E32A1F7ABE395EBF7EBD2EE7CD2FFF224DCB0", "snVs7P6JC+ZL806kznaYCsDvJcktm8JCzy++sP7/G8I=", "8FQdKCkAYYteOjTmpmqRh3oIxmSSjUmgPd2/QDtIe0SydWzs/okL5kvzTqTOdpgKwO8lyS2bwkLPL76w/v8bwg==", "4a65a2baca6f34cb62e25afde4a3e0cc1df7e545", "LO67ORzCFU10g0tO8P+yR3uRRE8a+3zDMvCyiJWfHYSYrT+Z9sgmZajGl9ioZjtRgFKUe/q1h9JjvwBeImBAcw==" },
  { "F2080C47FD2E05450C5B551A528BFA014BFB8C0E", "rfCu9/joAIyWWEcnk4IXc7xwVHKjD1aEKjBZ3Y81jS4=", "yacHahZ+BH2k/kBir8Ze3DehW2ayLA6pzLubvZKAN9+t8K73+OgAjJZYRyeTghdzvHBUcqMPVoQqMFndjzWNLg==", "fd5af7ab5f59a6bb97813a1f9b14e965cf3c3f77", "uAImZr28RdKkor/23jh11AGnIxRSGjw+/1c++yamTOmykCtEWMGRwvOo1U8yJ4RLXOQe7euajoQma/C76WfnoQ==" },
  { "47C643808839F0D4698F31D37568D146103A313B", "b2lxLvBvsKATAEJyC5XmaVYTNG+bnB5pzoD5MmB9ZV4=", "hOAaqxAk++nWU/NBp54qTQI3Dt0XNy+GjS7Ip+JD/JlvaXEu8G+woBMAQnILleZpVhM0b5ucHmnOgPkyYH1lXg==", "968e5d954274295fac3292e07796c76149d4c483", "ITeDPT6F5Kustx/cDDSweRqrm9N4xAxwv2Nlja8uUwITDVKzmBXRpNA39n7C4bZ8sUF8huyIN9C80xDgy5QajA==" },
  { "64A1E8D64E3961E525F779750579C5AC0E07D857", "EEXl9QnPQuNIV3Z7I0x+9BkhrC8LrbfC8mAQ+8obS7M=", "Fjb1TcN+Y7YZzVXPxK0Y21cTDlNkusBHVAVA3CVdh8gQReX1Cc9C40hXdnsjTH70GSGsLwutt8LyYBD7yhtLsw==", "e2fb9fcc2623d2559371cf351ab17723584cbdde", "xP/HBB5zx0W7w2rzG1rRKAcU4oe0KTKBzLxYDEBh+GPNc+OGw4zPnqENGFrwlQPqn2nC11umQp9M4aySdcYqSg==" },
  { "37317E620A82CDFEDC39F7C6D17BB4D0FBDA4258", "nNfx5lsNKcXzlw6R2yRwngYZbzU7bsBh66JgeumV2Hk=", "WsVc3Lu8YUTvWYfuAGFwrt1nP33tUZxBUi2DTCgzfaCc1/HmWw0pxfOXDpHbJHCeBhlvNTtuwGHromB66ZXYeQ==", "4d1fbc4cddfdd2e4a32e1059256a1a574e7563c6", "aUqr/vmYNolZf8HzZ1ava0fdXhvHyux6SllIKrgfy2q3blGV2VTNxXMDW7yUy2WuPaXSCIug8aarpgrwnoqNNg==" },
  { "4EC7356845B6A28EC0A710A74A28DF7C4C279D7D", "sR78IxBydHJ7QJzW+0h2lZ4ZJPfFbKmz5r+ZovHq1Vc=", "yRmwu9OrG5lWGi2hLZKXbewyeQDdiWqsI6egjP2zWBuxHvwjEHJ0cntAnNb7SHaVnhkk98VsqbPmv5mi8erVVw==", "abff46cf15bbe96717e4791fc6c79ecc67f387b5", "uX6B/BV4t6BJu1/vzmfR+rb7zoDgN/Mf/bBhGKyUjDhm7jR4A5Xkogarwqh4wfgY3k6I7ANvsCf6/Q3+YG1aCQ==" },
  { "8039B9B31B0F45316A2339F23433EAE1E7BCC8DC", "s2b7yKIh7k7BUn/tMEXfrQ8WTYtA+rCtyVTg668yX4c=", "GyUW5FJFhVB8oly9eUPHOqXdWzk6GqiPsmSy/1fdwpKzZvvIoiHuTsFSf+0wRd+tDxZNi0D6sK3JVODrrzJfhw==", "bcbb909d72cd149ee7617135bb5d444dc0ee61d5", "F2wQhLGD8fNbQWtMg3cVxc2fjuIaWs7lhrMAqw1NWt+O/Ou3xtgcqsomt19EriX5ovn1KByL/nlTttm8Y9LLmA==" },
  { "F71A4FE6F77AC36AABAAC18335BBE6485F9B4EC2", "1AkCprFE69goX+wLxPyqPudCa1aNFutgYRR0xEAf35o=", "5oRNM9JZ13jLbU4iOJX+5noNz8yJ+fv46IBnFQvaMErUCQKmsUTr2Chf7AvE/Ko+50JrVo0W62BhFHTEQB/fmg==", "2132c1e7960346e042b751c8bf6b6403fa21d4a7", "yd2Sj07Uq0B2HIn+Ml8DIu7tbwcz5Hi5BgAfjRJX6MEQLs9AOa1QE2JSALzXgN2K4IO7QMLBzBYNqK9rLuh+IQ==" },
  { "52166AEE4E21D25BA2E6EF95AAAB88D500BE5D17", "hLiogFckkY9yjHWi8lH4SDqBt/GA9dLwejC36B4gP9g=", "UT814DD/AuHFb/y8kp4cFWu/230Y1ey6BKTMLXQLez2EuKiAVySRj3KMdaLyUfhIOoG38YD10vB6MLfoHiA/2A==", "d557ddf689b8a836e0546b0b2e015f53fffdfad9", "T32wapmPdLs9h5aXxKtMy/8ZAguUWiG5gSfbmN1Y9RoCcCwzA8k/RDWT6lqbUsNH6j0kxyucAxRPaGIl2LUMMw==" },
  { "D3F21BB9F196E0FB0A77A7A2C7A9C4718CED131E", "xEkBhSZUqY5KekE9zSgHb19oZ8xzDTEEqWZ/FHAl0qo=", "etGhEKSvLtZZef+qx/cS+p8DCcNd+MicODuxJc7+hfzESQGFJlSpjkp6QT3NKAdvX2hnzHMNMQSpZn8UcCXSqg==", "d397512b050651773214a62cfd788ec0d92eb60a", "9NqKw7Szpbd7mW19zyLZz0q5XiexjJct0APOYhY3+tnrtdyyBiEINC+ZJzx5mKChwviN9ALNngoQryKlHtSoyA==" },
  { "E2DE094CDA933A8FE010B22A5D1692C630D6DFD4", "Q/qQC2Fc5bI89iO4WZDqZF8MlJmNczn4WrmoGgr5g7s=", "O7qG0kWn/ZErTCwz2rYBUEmObiQooMEbbJnAhw2xmQ1D+pALYVzlsjz2I7hZkOpkXwyUmY1zOfhauagaCvmDuw==", "149cfd20cd544630184b46a4d3c66742eff616da", "R++IuTo9FOohgC6JFNWN8CmyF+JQXs2/bFj+ugkuY+GZhfKucoGmcAzGPm7BRNX+SSYlpuMtkrmNpVyOgqV6UA==" },
  { "7C762270034EFEA87E853934B31CD28DC4014857", "6x3K7TDa2dVuRzWALZV+IJXYqKLJQkUge5mqSr6N78g=", "0BGiPF+kRhOorL6esyKeS2Xwun5t3iAATzkWjHU/cMPrHcrtMNrZ1W5HNYAtlX4gldiooslCRSB7mapKvo3vyA==", "96d861246d9147ac4b2a5970150785c96c3585e0", "MRDNj0ksnMgb2/lF80ZQgLmiSWd8rJx1HrKfQrWUkJKTf3kZcn5aab8vxiZjKTGsx72+7og4/4TJnP4Y+1/iWw==" },
  { "28255FC9982BE0C1FBB6D8A30606E01B8B93F222", "8BPzadcIIpqyPBGNq0RP6XeyjGnZ0vu4r/ok9dFNe2Y=", "Vdt611ZBPf2gQmn2EQmr7/NsjuvtHzqNACsNqyqwtp/wE/Np1wgimrI8EY2rRE/pd7KMadnS+7iv+iT10U17Zg==", "49784c665a0dc9cb26ffd939b54451569b7ab5a1", "tdG7j7iQwHRjB4veq2BiIBI2Qy9iCSGmCC3e7Sbe/P9S2mqc8xwU1lf0rk4Nhu6WMAZ5cjlk0KJEmtRCVzTKWw==" },
  { "4E68BC64569BB2C556465AFA6F0E3EFF455211DB", "AYJjuGkQ2NhF/7EZc6G7MrbLwKCVr0+LW0QF5L8XOY8=", "7OrNUkpTUnC44+eQyws44tLWnm9iy2VDluJnL2Rat/sBgmO4aRDY2EX/sRlzobsytsvAoJWvT4tbRAXkvxc5jw==", "f62cb7483d17f50bcf66c20d45276b816ec979c2", "QxPCJB0B9T9znC1bRLln10ooqFs22Ob+ssr0CKijFTbKOuGQA2snTVxCeHJ/MFjw7xEId/Ukuwhpym8SknTvsQ==" },
  { "07376D643AF614F14B4804687B9E5C92A9A2268E", "wbE0twQxcfzJ4jlezKwB8gosuGqmgcnUSnvDNpyuSHw=", "NG9SsaJb8nvHJLJpSMT9O1IlLBA0xrvPA5Jw8wBL39jBsTS3BDFx/MniOV7MrAHyCiy4aqaBydRKe8M2nK5IfA==", "5ab3b7384d112a468971af6d784e0a2aa36cbf77", "oAuSZCSXwy82pFZ7HfrL9mzRXTbcEVSeNGO5e5qypOT9qBMcvUy3TOHMLpFsA5k5NW8krHn6wjLWx6VCDi8mBg==" },
  { "38DCDC66630A594B58E78D8DCAE40712DFF1879A", "wRCwnYNgVsZIt2G/o5Q6wTQMVbldd21aCRv7/ikgCaA=", "xlne7Xy8ZL+xkfpsQ0CU7knrgNKxhXoam/vjZZpH1hDBELCdg2BWxki3Yb+jlDrBNAxVuV13bVoJG/v+KSAJoA==", "126203633b7d7a6b0d01c7269a41da77059e87ae", "GJJzh34OkMdrusEXG4WVd5UjVvvtOdPxYv41i+CZwFq9W2ijIPHxXOSWavjCiMM8g/rsKbXAQsgvJXlH/LBq+Q==" },
  { "629C17C1521E51BA17D405CF214C82D781571BA4", "l7pHRPjTiJ/zqClKpvqDxRB1hWF/2y5JXOZ3g75cwZ4=", "5/kQbl12DEeP/qmi73aPJI+SJKQ+kZI6IQaViIYM7ECXukdE+NOIn/OoKUqm+oPFEHWFYX/bLklc5neDvlzBng==", "4799d3c912f016d1c1ff664f66a6f8eb5d196af6", "YG+uYHzVt+QOSjFQI284uwPvyB29OzFaMla+Aiw5hjNNLdun0rpLObcir6f0TnP2PYwr4AR/0t3ARleQHZrS7w==" },
  { "A03126E0A03D3E0675C0F0AB956499A80DA3CBD3", "SSH7xoYWQe5kJnkp2Mc5MONYHI9iXFT2gdqk9DG3Djk=", "usBVbyhoUTFiufxCoXx7RSW24zZ7YQ/mWPLfkw4hqSRJIfvGhhZB7mQmeSnYxzkw41gcj2JcVPaB2qT0MbcOOQ==", "f5937783fc53fedb0eba60d4210e2591e17fddf6", "tVSUEeJfaYnMZ/xeY48g7hyZdXZ/5XtvubxtxVXZPxoBF5Q6XAu+ISVSiC7KI/tyH/ZgLUH0f/a0DYZCjXwKHA==" },
  { "36C162180D46E6A62EBF3062FACB2F3D5F3D8CDB", "h2JsddPBOe4nDftKD+i5wjMUeVzk7H3Sl/EZmKfQ8L0=", "d0JdSp/Trk5J7PWqf4d0ZWcMb71BdxWEs3dxq8zyWKaHYmx108E57icN+0oP6LnCMxR5XOTsfdKX8RmYp9DwvQ==", "8135a48fcaadb679e7411a304ae769e0c15903c2", "slXqDb2El8T+FKyOQc7PvmvUeP+QmokrNzieTWq/txLr3oWjsT9/nEW/bTDogGKfd3uLFYKSroTYpXIpQtwFag==" },
  { "759D389C18B3F83F857DD65AE74868079B1CE695", "UoYbL//vXNkaOMZ6nrbpWrxw2R5peMV8Be1gBHNzWEI=", "BwyQXFp5skvdAwXrDtU3+UOIuNs1duxgEK4Zl6Ux+21Shhsv/+9c2Ro4xnqetulavHDZHml4xXwF7WAEc3NYQg==", "fd6566d45a919b4a6f36aa224266985dddae1265", "wxoN2qn4FugE+qlAw1Vi1M7lSsiabYH5YB5fS8YJlvZNgo1lrIosjOEXyb8X2c/9jFTmh0iFgwnRui1Bo5V1VQ==" },
  { "D2B1D0A590B68D9EA45A4F28C13A401A57DC6C71", "h6eAlxuskezCUSmzB3pqgbeS0Jsk4JLJooS79CXZwIE=", "h5W7T5NtHaiJP6ObVcPBsiXPgPtOxVGrJw7F1PZ6GheHp4CXG6yR7MJRKbMHemqBt5LQmyTgksmihLv0JdnAgQ==", "b09ab3c8d85c213daa7dde8b040d3007f5d5023a", "jsF8h3iAyyl+g7/g9DBDNkhXR1vJVqtbv4t0UXQH4cGyOnZr897PUlKYC5VT8JN0wn0+iZ78N5AjuD9Lih/oRw==" },
  { "E5E4472CF2E05690BF2443A02A692040254D2733", "wAz4cT9Hh5bbp6YZug5sUqISJXv/wgXweVF4pIegW4E=", "w178eTXAuD0It8KwKLvHC+Xgyj/3ElebuNLo1Yt3CbHADPhxP0eHltunphm6DmxSohIle//CBfB5UXikh6BbgQ==", "76ced9e4e65f305c0102066d926655ac87f7aaa5", "hXj3hOizkHvaqhJUQOVV1s40bHVdHIDDFXr68moPXzMuxQaS1/yz+Zhek/vLYRZKKZ27AkgAoNG7qXV40ZLhMQ==" },
  { "83FEA548056FA92AA33788B59FAAFC137D861D88", "9KbVs2nfwNA5Dt0n8V4TupqFwjVLBpMHMPffeJ3299A=", "pGp7klukxdqreCgsQdVLbZiLHoxNp3+5GaUKA8uiRGT0ptWzad/A0DkO3SfxXhO6moXCNUsGkwcw9994nfb30A==", "9ea5d5366259a8243dc7b1aaba6ee94b220f6377", "TGw6bbMtPa2uyASKw0F5xf1EgDd65x4eSDVGAU4zlxkal4nrWtsFnB6F2Y9STba2cOJ5c5RD6ZGti6oBsPmQ3g==" },
  { "BF2CB6AEEC3557B64E6996D65973AA5281B12F4E", "bgRi0ixP3wTWFZL0Qq++sqFua37IJ5ipzCwfDf1ZeUQ=", "RIZe5xxYhB1WaoLL+f+oWAjsp/JZnYf8bH89Ki1a8/luBGLSLE/fBNYVkvRCr76yoW5rfsgnmKnMLB8N/Vl5RA==", "06b0851a370c8b2f03859869ff154e1dc7d6e5f7", "+nmZ7P6dQeQn1MLHkXV0y49Q1CfpCxDg94xuLAR6ZOTd9gQPdb88O6zy/dDUR7NbiEYzL14loBOkceTQcYsDIg==" },
  { "4E886366DC66C3FA26D6C8C47434F7515B4C6EDD", "2PhMmAMnUSzeEh5AafcGezSCqrEr8XaIzQVbEYlUbQA=", "syjPqVqo6d4U/nrptvpWPFHLoRRrshIvvsHHKtBVnyTY+EyYAydRLN4SHkBp9wZ7NIKqsSvxdojNBVsRiVRtAA==", "1b447b63fad87b395eb409da24049f4d2424776b", "rsKp0I5ebos0tMzV3Ji07SfPzlQeYFWkeLbcFcnqqWeJkENpvUc09D5Ww8l5em/xfshiCX989bCVTt+B77dFmw==" },
  { "3B2E0B68600D53F61E3CCAAA9BFDC0FAA5F6A382", "NqBJ4QqR7nPZD0XK1uNL2dbzx8QbggfI9xQskvfSc2M=", "71T+vffmWjVNn6OFYoL0DjHRDMrqOaQXTGlI9mrav1U2oEnhCpHuc9kPRcrW40vZ1vPHxBuCB8j3FCyS99JzYw==", "5387bd32572f744bf72bcf72f86406107ce194a0", "NW20gRIVOY3VbMWCvFwsgPRazNGp5NKhers2e2acSikwCEjxyHJZXCiza3mj2uij0/q8P5y9Rjbu4bJb3ROQyg==" },
  { "5D7AF9EFAF09BB7EC6BDEFBA0EE5870726F53713", "M55M508jlhfaXlzwhifuDXzOBaTL492p6xn/3S9LA5g=", "7JcJSNwNx6aZbjlGNBLE8tM9qvb6rKp/8XCfWlmtSpEznkznTyOWF9peXPCGJ+4NfM4FpMvj3anrGf/dL0sDmA==", "19560b7ada78d2ba0a8b0fcd6d18362ddae2f87b", "P0wG7shfMecrHYYjebA/2KsAzfyQkgStdjTIZyhGl5rAUgTTvKyKXP9YMrrRBQXCfg5wRCoOGRiYKf/T9GykNA==" },
  { "D0A135D921A9F7D78BC66BF340C919334CC21ABF", "cODCzSaB7xdSS1aboPAYPvSq9wEihdXVJcmzFbn9Wqo=", "NrPlSRfwXD4VdDxAgou7o6qrgDmteYSk4aWk5HSV3LJw4MLNJoHvF1JLVpug8Bg+9Kr3ASKF1dUlybMVuf1aqg==", "90e59c0f458486d4f71a5eb02493a8998ac80a0f", "9meziKNlRG/zlmojrhUk/96IVeRPLvsYwXoCfGZzT3KEveg+nL79rcpuBMHVdn06QHwwj1oRwedEomM2i3GpUg==" },
  { "9C0AEA7263110EB853A6F0F4669DC48B90A2F3BD", "hXoF5d2L3ROsWtQM3iqVjgr4FUQ2/eEm/i41UsMYg6Y=", "+27wLE+WhO/pMC5g/XGL53Zj9eriTHdf68gtvPnxVQ2FegXl3YvdE6xa1AzeKpWOCvgVRDb94Sb+LjVSwxiDpg==", "0bfad0a6e63d0a31ad7b2bf4dfd92b44ad0f859c", "QJnRJDIG/D3DYtWtS+epIN7cJ9vRfiX8C6EYRU5cK8Q4HumNfATyaMQrkPvMTSVQEZKrn7RTMiCYqLumSnkrSQ==" },
  { "A9534DF504F68A9BA74D31C0B1D4E492C6A84E8A", "csn56BRBLbMBS/NOviKjHvezxLIIZyZ2EOUeYT8ReB8=", "eSCHb8zuIKtVvfaPKoMFx47V5yNrInYs2TCDv+nL+x9yyfnoFEEtswFL806+IqMe97PEsghnJnYQ5R5hPxF4Hw==", "51d75e6f5d36b7e0665b17c5de017d5cc8065c5c", "UjqkpB2A5iKVOZu7Yu6bPq7hspfb+THsD4R3Pkp5JD65bKoAzd8CFE9k7TQGeDNLb8Ek2J/rlZZSzNj/s3YP2A==" },
  { "3D796A31E9F34E02BE10AB65B0B6DE9441DFD17D", "spGrkjGFh40ZWDcxypUG2Vc8ujRHYhgD7AfddSfzX/E=", "V+YjGmt6lPmA4BPsQlzD3c4Xcq9Sy12HgRD+op4DX3+ykauSMYWHjRlYNzHKlQbZVzy6NEdiGAPsB911J/Nf8Q==", "f58a4bc8af19b044da5835c9b688b76a106f81e4", "mbd0Us+M0DilQq/tjQCYfblQfquYJjR0sqWnznJrNJ4hFxqxNKtpvza2iH21/+6FX/KJsf2QZ1kOGp2p8zBbMw==" },
  { "AD039CF248A3ADF61BD57D05586417697B9982A1", "ABCJaZNa4TJxuNV/ht6fSSeos6NXgYF+sMD0y+Wa8BA=", "vOLnCdR+aK62S0FMCxmggAj8NwkVgjKnzbXjy4eKZdUAEIlpk1rhMnG41X+G3p9JJ6izo1eBgX6wwPTL5ZrwEA==", "25a9eea3e2a3f2f8eaad58cd16c030fdd99b3729", "4tIW/qzwo4MQEpUH5jrF6goUjacbytx9LznxZ/qcPAWWZ9rt/DBBFQki9GGdAguzjAWjqoiZedwb5/ACrQkwdQ==" },
  { "6D9295830FCE6B711878798A99FEE5456FB05CA5", "gdTjrZPmBBbnOTknRHgd7ztmipTetENxIXMRuTnuv8k=", "fT4dq/tGwEYwl9QKeKMGPDkQ4mb6xXEeEOz9U0X09rGB1OOtk+YEFuc5OSdEeB3vO2aKlN60Q3EhcxG5Oe6/yQ==", "1a4ff2a85d053eeef88065b8258fea28edf9d6b1", "abaAS08d2JdEm8UDkPwiA7gAUQbqmeCnrd2Sl42uyba8BzlhJ74CSzayGAuXvQz1sKTEXArQEPc+XPKI2cq4Zw==" },
  { "7F4224BCAF80BFA9E5C6BF99439BAEBDA028080F", "LBeH6ZCUB2h2X9jV3tjbDscxolS6M+ZhI2APN3EVqTM=", "8pmRzJ8Nrqnx0qIS7DLtyvPV3L1GYeR9iG9r5GAREbQsF4fpkJQHaHZf2NXe2NsOxzGiVLoz5mEjYA83cRWpMw==", "9e6266a9cc8366a4c2c343b221b5fa54178acf7a", "NJbaRuX3BHELFCnbKJnyvIsP29XCPMUKPqHXmhgKk5omo1beFA192giFsa0OxIbA246A59LBqL3o7LkmUJbQ0Q==" },
  { "A2BE651C1E32D83E27016039261709A50008B79B", "BGY5Nx6LMNApVORguuigiPityW+UzdnrR9E2Ff7D4U8=", "vsSYkI552G3PpBVq7ozEnEOZxT6qdFQWsWSQeh4pyysEZjk3Hosw0ClU5GC66KCI+K3Jb5TN2etH0TYV/sPhTw==", "d70f280308501f81b15568b5a9d187995c0807b1", "RayDDwzDiS/tno9T2MuLTOS3q8fTf2jSOoK/ztyuY6yMn4gIoASHnD8lE00zyFO4gMA60rYzCrGa3fgtLPFDUQ==" },
  { "BE88C16C68859B63358F2CBD76D7172897A9247C", "6URfNuPqwqy6afS2N0BJdO1p0WtIfRItQnQc3tIVoKc=", "nTrCAECjG5WJ2rTz88nMmhO7yq2BVypZvZ17we4YERLpRF824+rCrLpp9LY3QEl07WnRa0h9Ei1CdBze0hWgpw==", "c4fce82f9c2add44e861d78bf069d5729c1e12da", "/uXsuuJuP/bAADRKE8hGhvvQ8swt3/zN01UP57e60DpTzB+ayG3zvd0qNkMNJ/ofTc9uGbw+lXlsvzDPAXr59w==" },
  { "3E0826138B65FAD96D0071A7CF20AB1A5BB1A262", "KH6wvPZS7CBLkDs4SBg58qXc53scf9ftkY1+GM2G4Jo=", "Ce+/BDu20ar7OFZjiJrF8sJw5LlPH80s4nEd0Eqp2iUofrC89lLsIEuQOzhIGDnypdznexx/1+2RjX4YzYbgmg==", "35c3e65dd63bdb1cf682047466025d981ad3e62c", "NyoOuGJqM31vTSBED2flyBWqA43oJ9tIiDTaF2BbhSMQwEzWXSQ4Kj2buMBu2kXGC6O4YxPzoJxbfbV7z/p6jw==" },
  { "C9E931B0ED404EB7497276FE8A0D28E68730CEEF", "ni13Hw2Kmg+7IKq3aeBP/1YwDCd6vzw9NWgkMKYRnUw=", "OIxOGrPjTzq+oN7DxNO6mq51VdWRcjsoOnolAaE5k8eeLXcfDYqaD7sgqrdp4E//VjAMJ3q/PD01aCQwphGdTA==", "219c765bd1e17a56cd81d8aae6c5b49e379acc7d", "cuEgU9vNoxv8ytvfitbdLnBH4FUyHr8dx8v2nISj19AYK3KOukwfc9At9AkFPByeIuPlQRsqHlpclxEf4ZwdBg==" },
  { "7A6D4A2C5E4956D98381C34257C4F2239129DF6B", "op5+zZdQxF9jFPdLBjuhq3/+RaKfr+KXzEHDo3IENHU=", "ZUYk0AdZKEqqJ6pQR5YR1Ujq3PDv3yjudoFU7bFn6KOinn7Nl1DEX2MU90sGO6Grf/5Fop+v4pfMQcOjcgQ0dQ==", "64e94ec228419fd539c8c38626e35feb415c61dc", "g2mIUKREznquaMuEoQk2/+7sxr+ve66yDm0EVmIAsPY4HdvXYLBgR4iAZ0Oz+Hfp8MUv71WYhfm1Sq+T7o7Abg==" },
  { "926F7D1BF8F5FFE86347B13E5CE0BF59C49E2E2E", "oqbwHzeafTWljWUqdwwXG84Izqog59/x7fuWXCfx5e0=", "8oP6IpBDZhOT+qqPgGvhMzw+l2+9bwntTRVGRcRrbkuipvAfN5p9NaWNZSp3DBcbzgjOqiDn3/Ht+5ZcJ/Hl7Q==", "8375b73f2fcba08d119d05fc6b9125a07c5a3d87", "VhvNxOTJ5D8LRzYdw2ecKz1Chel0jHuvZNEOuqxEy090QuLA1gVBdU+EUls0bY4IzsVpnZm8WujmP8MLh0QSRQ==" },
  { "9B2820043D12A35CE99941F20777B100F812DA66", "3IXTtKbzcM8H6LpVxD/7wSih+x5yTuPjo8MEs1zeXmQ=", "gR0PMoy57pmP4CC9GyYJFYpu14ZR1oFqh9qnMR724eDchdO0pvNwzwfoulXEP/vBKKH7HnJO4+OjwwSzXN5eZA==", "1b22b8cfb60675b70d923257b454bed29ddd569e", "0tsmKzpifhCsdW1rz4XMQpKBko6kA4vHqbUbfpi66r74yyGDEf/yHkA9pjDodDR6AymKIOpf2S5WzUVJMbUnqw==" },
  { "B9741F6BC0ED76F362749785F24DB289C08D52C2", "LZ3D2d0AhWB5yA9LFk9odyXwfYC3bTLS+e9lKRibVIY=", "MZuhEcSMFSYzb3pKHNmrerPG6Ogo5leu6xZPNIz2TNEtncPZ3QCFYHnID0sWT2h3JfB9gLdtMtL572UpGJtUhg==", "e61c28ccf878fa1b4401e8a9b1333e343ebdb39f", "ko1BGN3Gbr4uJabUhHCUNKeF42NqucTsSeyAFofFlp8bfBmDSb5X+5mAAk+/nhW1KOxbRk2Ei7OBrpkfjHsriA==" },
  { "C836EA6F83F56C0A9FA92F149D9F0B455A80447E", "GzI7cClre2SSuMJSnXsJLcC2a49Ol7HPGkBUMDGFLyY=", "65hnWyvEoG+i9KKvgMnazNe4VEqUd5zbGpkbdnE3ucIbMjtwKWt7ZJK4wlKdewktwLZrj06Xsc8aQFQwMYUvJg==", "2c1b405285ba6f9e45b0cc92e91864534e7a4f3b", "jUZARUJ+AA7jx8KuMeZ8+I/WUUANqtd/9cAPHp0+xPy6Y/JKx2FwifyP/X4oIFRTSWr3YJbsdC7sHwt1N3V98A==" },
  { "2FF81ADD5EBFD52FD9D39C4A8D284D38B031DEC6", "Vr5BxBovpEQVPr7uG0IbuUz9XBhWi5VKl5uFhPSO5Yk=", "Joh/R+M3i5S2Egri2Q4Q536B449vUBC8WEGq3WwGF8lWvkHEGi+kRBU+vu4bQhu5TP1cGFaLlUqXm4WE9I7liQ==", "01a861996f2eaf7b3a355349032034e5f2c82943", "N7kkuXg4/5nnio13vLDFgrh4Gorw0IrTHD8AKVThRUF1lFOnEIB8b2vsqYlfc9Ow0nKmpPisq6B8sCRELOnVxw==" },
  { "B1C554FA643794BE89DC1869CF089151D4FE7FD2", "s6d9jJwRfVee37rKiArpwqJqWZ60hqDli+9TwS6qmao=", "d6yMi05DC80e5SmXVlh3P6tqqa80QBrUNcxX7aFRJLqzp32MnBF9V57fusqICunCompZnrSGoOWL71PBLqqZqg==", "dfb96c12735724e688def6e09d067e55390becec", "LW9AnjFONyh0JAoHXvbQoiBEsrtlc4fmiCtxrLUygJxu8Vo3JIjfiNim4tiuWN7/JaR2528icxqhjGgsUCrRdQ==" },
  { "2DF75654000959C1F4EC148B14F827211D352548", "2zCnIo+kkIdrkrED27RQCR5uyswzmC72V3XwL4LeK/o=", "Nw6l5wZKldENpvI7Cx+QAclZ6W/QsVhwCt3Cc+GXBJTbMKcij6SQh2uSsQPbtFAJHm7KzDOYLvZXdfAvgt4r+g==", "03a363a5719835c0fbeaace65363172ac6d0da45", "xJIayTCwwSzCqhOM2dBKGm5TPOSq9g0brNdXcVY/S45UBNO/f2Xukzd9UcrtNeJzpVHcLFtnHAvSwGRVIgp97g==" },
  { "8B38AAE558DC8210EE728E21C297DDC2BFCDE0EB", "0m4/M63sIkKgVT1vSb5UMLWO1IBExkH54HqIx7j/CRE=", "ebiW3BdJACw25Pj8ZsQ5s/l3iO1VArdfyLc3+q8aGd7Sbj8zrewiQqBVPW9JvlQwtY7UgETGQfngeojHuP8JEQ==", "076b0562e03238ed849e79c4c59e7984bce67638", "Jes6Xi6VXp4BM5oqJLJZsb/HCvRtOwIobQbGRbyyAVkiSc5uEhPYnqbFcOios56l7aBJQpRa3ckvOlIBAJVlHw==" },
  { "AD70E08168242D8D8C39BAE1F8453F642777D2C3", "SeR8utYAsSafJIKm09U/CXY3AWXxEHuxF9GClWEFCBg=", "uVQmKWB+52x9/cX//UOjkne6r6cz+JmfXEDQIs73Ku5J5Hy61gCxJp8kgqbT1T8JdjcBZfEQe7EX0YKVYQUIGA==", "f3aac7785a59482e1e87d4570e387e75bee59f05", "0VOUZv/iK49+9kL0bvkRHYTMvVkfwvKKFNXBg5kcV3wovnVlELXbT5id4NPoNkUD/zHUZ09AB38HLbYJIlXk4w==" },
  { "D9C18C34EB2DDC620DEBF4C42D1C3451AEB1C197", "rqD+4fLdA6Ll++OFngCbhx2gePYiXSSCwLah7cb9cJE=", "uHpo+vcFR8w/4nwoh+2ctTW27NswBSJuBPq7ox8HRNiuoP7h8t0DouX744WeAJuHHaB49iJdJILAtqHtxv1wkQ==", "9c0fd94045d003ba0fd80ecf1c4448aec44ff4a7", "NTLGkjJAoRewAsz+5TVyEeJJnPyAyV3n9AEGHiwumtShKYwS+4CU9RpTxaRYSnbG2F7o68HlrT61tPrvos4Kvg==" },
  { "113DB2B149D87B9206CCF750D6F49E2075A696C3", "vOjJ/9/NDb4DWcfL3m1AxMvEGPxO7jbsvjuWKbnx0ps=", "4UjT1i0lDIsH8N+B9Qu/wlg2A0Z2b1qLycMFr9Ka33G86Mn/380NvgNZx8vebUDEy8QY/E7uNuy+O5YpufHSmw==", "2ce02a795f237662b18b2d2486ebe32066c710ba", "jKmN6I3yteIbDt5UCYFyWdTKZOM4YLi3hLICj/Jk652213J2tkIo/WGQ/J1YhJGSx/wWTSzisNF3ge4DsMJ2Pg==" },
  { "7D344357267EB9511E204BFB7CAD48D3B7B76CC9", "ceG+KSXOkmqGGRXLZ9PfzDPBWdPb4v87VZSrTkHGzFI=", "fIH6IDAv1Ptf700McLoZl+ttscs50p5l2FATTsxRXypx4b4pJc6SaoYZFctn09/MM8FZ09vi/ztVlKtOQcbMUg==", "58a947c7a843982751592152bbfdec49a2662aa6", "ym7RwQwW3qsjSKFNUMoOLf9q/wjtHgj+PI2svNu82IHLoquVn2F+MT5aXw+amprIqJkFZUu0OWeArhF9PhvQgg==" },
  { "995C75DEDFE0FE34AFF3E76A6A89CC4D59AEF02F", "M9giMQszwUzx+ppZPFQJdOZD0U3m7IcADwhHs6IvFhs=", "V9hRcqlSrPGgPmRuWnltT6iuPF6VZcuW5TdPnMTqJJkz2CIxCzPBTPH6mlk8VAl05kPRTebshwAPCEezoi8WGw==", "3124136b31c830e72078538861e6af98f139d781", "O5xil1ABe9UnQAkg3aNbU+Ge7UkzSAoHZMF387/o32V95/0QSPjhOLUYTzcy59s/9tnNPTNwmlYhotRdlCP3kA==" },
  { "EDE52BBFDCC194AF4AE2530D00CEAE3B0C3BDE1F", "wzW3J7WvlRmbYbbcN1v2XV2zwaz71H2+zom5Dj3Pwwg=", "XhW6NWQEDhJZsPioM1lYP2tSux+4ndiKNbOikBhIgTXDNbcnta+VGZthttw3W/ZdXbPBrPvUfb7OibkOPc/DCA==", "fd202c1cbdb6026d71265a4abf1f8090c6d66bdd", "r5hmkiYRAscrCc/FW5EtR4KFQoZ2YbwOpX5ZqxHTUSGXyZtnjnn8iy61ukQhCAFipyP7MCRK6voSoe5DC0/Y/A==" },
  { "30B1E9FC3C33EFD8CED624A1917C63CD875A0E5E", "8Y4K0LuOk+UyS5oT8bZMlPBIVnpD7xMJwEk0f7vuH8o=", "pSUYzvkJr/jPbL8yukOxlNPp/itVGJHk5UcEVtVw64HxjgrQu46T5TJLmhPxtkyU8EhWekPvEwnASTR/u+4fyg==", "0cf14f90f9dc9c546621f3161dadf477ed99d08f", "Q5uO1BuO9qxj0rEwfFVyOygIANrjpE1Rn2Dg3g9oWwO/Z6Tozdv69vbpilq0yzupcvZwqLlTs3As4F/99Ws3wQ==" },
  { "BC8A7056F0A6117EDF69BB3C47DF47BD3AC252FF", "HmRYrGP1JhlTWJsF1kVjcWxxDA5lk0wP2BOB89EczrQ=", "mwI6JSh32G9qzQsa3lkqlT+Aw7vA8hOTF0PeVbOmtT0eZFisY/UmGVNYmwXWRWNxbHEMDmWTTA/YE4Hz0RzOtA==", "27f51cd91d01722a8466c71a4fb5917a61bb0aa8", "LPN2nDGnZgYalnsHytIWrNkVzEC3FmMo2nH54zBh7CHINqDychHu/9yb24Z8cxOFkajGPIrjdIRIQrWO9zF2ug==" },
  { "031F219D20F746AF9169EA4DED5EA60C1E0FDDF9", "ogxtR9U5kMWbcH8AbCODGd06Dk5mRdI4OAt7wImXZSk=", "ksGuoUJ/hOOXiXacY7jcxMIjUh6Zrge+gXci663N6zeiDG1H1TmQxZtwfwBsI4MZ3ToOTmZF0jg4C3vAiZdlKQ==", "902c1b6bc87a4f5a392614e10f319aca51afed5b", "sUbfQTp3A08RlE/IF5ObzVUSigcmviqenTEHFbx0hAPBtcy/Is2ijsr5k/HKU5e2gjgWH8oNqg7GKAilFoKYKg==" },
  { "B1865E5DF31E31EC4DE58EE97AAE2E32563485DF", "957mqeQn9o/yTV70lWD1akfbGz51C2jJYNOEVY9yWLU=", "NQ7Nh8tzAwtfVWq0AMEEU1hafhE+RuUKVBiiZgCWOQP3nuap5Cf2j/JNXvSVYPVqR9sbPnULaMlg04RVj3JYtQ==", "b70d1f6661faf27eb4dec8dfd4adcc07e2d26371", "3AO7/TCz8wMfsPj/r/168NpPNNHiRrgpuS9FZ0y661SKSVVDQ8aD9kgJ37g1nO/+jmgV6PaZRmCZ+OGcbVvrzA==" },
  { "7125A71BC140AD2ADA41CA6877BA127F6036DA64", "rt/M+znM8TXGtNpx4ZIQrjqYW2iElB8QTPBlS9/YF6k=", "EmegrS3ymTjb5y1kUvQCi68RGK6Fei7nSwDueRaUOr6u38z7OczxNca02nHhkhCuOphbaISUHxBM8GVL39gXqQ==", "6ba72a7005d31c2b68bb57a83b2b83fd97c1d66d", "U+lXq/iOZKx5lO61B4rat86G6Ng8sThxwZp2jN3DNChYw22x+20KvVKRwvRHJGiGrT7vL7f6yGsDbxnWfpoloQ==" },
  { "A2688929C6DE84B8C204B91AD5AAD35D842C95CE", "Drrsf3V4J1vHDVu1vZQnGrvbeTpHml+RTk+Tw55Mba8=", "s/VdKNTEnmwZW3uIQKYNeMiJHfvwMUCPM0mfaymATTMOuux/dXgnW8cNW7W9lCcau9t5OkeaX5FOT5PDnkxtrw==", "7d0e5945d7ecf34ccb25b037c573d68d1dc78947", "Xy6+gJhplzwyvPikQdWOoRnnlYhed9X2aT/QkqRDAtH9Rnx8FzetAHGZWt0tSjrL7ON17N3SfJAGZon2125JBQ==" },
  { "61066FF4E765F9C3387976A14E864EF3776E0DEE", "4gVMxPqP+KJMMRiM0bWtmq1JLvNB/Qn4mbMlYF9QS5I=", "R6w85sPVwr92vv6D4diTH09biGKu4C4T6zUeut6gILriBUzE+o/4okwxGIzRta2arUku80H9CfiZsyVgX1BLkg==", "5bedc052aa8da1dba577480d855a12e918233df2", "mj5B7Fc4wu15xkX72iXnlsC4+9p99/iM+4Nh+Flves/twBJAPepI3cDZBlkwygpq5WjD5G1mV35nOjGBOsig5A==" },
  { "40FB7F06B912DE16E739A1DD34BBE7E6FAE1FF42", "/hfq9dNqePUmFv6KfK2yE2NSVGQVtarSVfML4BFdJe0=", "su7VJClzQm39gX2IcC28S2U2zcim/uaum1jBnUG1RQj+F+r102p49SYW/op8rbITY1JUZBW1qtJV8wvgEV0l7Q==", "14b26ae325465f5c73841ab56c6c43761c55812c", "c3Q4eEG+v2vyiXkwazChT/2mgFgRrLOuEQ9T3NxSRpKsxrReulbDu6Zvmq9b9Cs2co2Gb9dvI2prmBontNANJw==" },
  { "E27934D6F649CF3365AD13D1930442111C2FB456", "v0NgKERMQ3SGjpPb7Bhtm3yBIJDJB+/NNhciknU7t3U=", "m8eMCusFGVYy8JPUtZk2oGdaTmlj+dhx31XPgeL5sOO/Q2AoRExDdIaOk9vsGG2bfIEgkMkH7802FyKSdTu3dQ==", "c4c2a66c1dc1847b8f9a5d64961d02b77e68e674", "1mzHUoVbMNzMi+TpKHZWDuezRyBcMFUCCzDBDd/PAeJMntMfbgfo4abu80RG7f2PY/iEZAuS1Eok20UclwS8ow==" },
  { "B9AD5A3D98D29380DD8338EBC6855C0A8B0F23E4", "/p73gPoNkNbMuNmtUSe7fBEJp6OfOq90qK7jd+uk/iw=", "gpPus3tPhV7CE+MXSb+9/PjAF+E2S33SwAmjhA+QYNH+nveA+g2Q1sy42a1RJ7t8EQmno586r3SoruN366T+LA==", "37b5fb250a152126210d98c1e5c22a807d58ef88", "XKr2jbJktW+kSz2OABsbD+fhcUy4GG9WR0WeMiGVH3QJrYEpzj+srCN1dYjtPdjiTozJRi5OsLHU+QsVrolImA==" },
  { "0BE97DEA73CB0A16E4FA4B92D956F7148BEDF596", "USPRxbdJSbpXzLbmi8oe/ezeJ0wf2GbPEQYgWK45M6c=", "3G9jMoOpsRFfTRiEw3m6Hywl3IE0VsvX93lzY0GM1kVRI9HFt0lJulfMtuaLyh797N4nTB/YZs8RBiBYrjkzpw==", "4c66b8714dcb439abf189c97154c6a4cd46be36d", "CD9vDJlWjDIGuEcy9KP3YlN5F2TsdSq4nVmr3N5HPDk91wvdxKdwjy2wh1mluvEkaPZYHVvsS+PqnpZNSgrHLw==" },
  { "F13F5803931CCA19637B7DFDAA94E4750CAE5146", "Ynxf0QymM66DfIljI1lv3pon1Jko7khb1HH7P/Mp8zQ=", "gT3/jjDVFHJ5Cb9TAQYyHpbqDAIu2nv/Q0uYnH5iwkpifF/RDKYzroN8iWMjWW/emifUmSjuSFvUcfs/8ynzNA==", "0f37cc0b4e4813c0e46c8d88ddf471fb61eb7713", "lBAnja+YN+PtslS2TUiP9GTjssSqMDDobwMbKZH8vJBJ/gLaGKFyG0AptQXbwAchwZsa3hL4GRYsXV/PdE1YcA==" },
  { "A680050BC6E66362CD41E2D42F97E55B2C85D442", "7OfXLsNxzoIzdbtmRZLuLyzQOjT9e7DrmWJnc0pVN1Y=", "3wOcfyjaPlvmRf4CrOiG+WAnY2hqsxC3XnA0oApmgZXs59cuw3HOgjN1u2ZFku4vLNA6NP17sOuZYmdzSlU3Vg==", "6fb129c3310b39cf0c4877a09802a24f0d75ac18", "hcIp4hcP6pVZyGvtgagcP56p0bVll0rNrwHRn6R3etURALfPY6QhJwLIbZqIRKymrkuzgBYIn88yijR+jcW3TA==" },
  { "8DA04087D6764DE0BBFE7E6542787A4D3CE18978", "W4tOCR1yWBM8WR4UIxrzRyv8eE9AabGR6pkpUrcylq0=", "ITSV0Cjs5cYpd21PZ6++kTrn/3xSre3bmwQxu3t4925bi04JHXJYEzxZHhQjGvNHK/x4T0BpsZHqmSlStzKWrQ==", "2ea989e6a1db53995a56b231ee05c85e58d18e9a", "8rBKfqLAQORetcV5QV7sdc6Av/dkLQyBuleaIqFEmZPrJcXvjkE3mF2Wl9sJHL0RkewUZHvIJ7T6IgzfJ64f+g==" },
  { "239FE2CE361D028BAE86EEDE3BFCAE3237F5CC38", "yCuwnvsWlxiTv5AdTXgLXcHIpiHaWfpkJ7UFlTi8ohQ=", "PdIlJvJD0h7bbBmR5oobuwSGJRwWcDzIcqT2PxX0OZrIK7Ce+xaXGJO/kB1NeAtdwcimIdpZ+mQntQWVOLyiFA==", "447439418a8a4f3fb6389722e20c2792d7d51bbc", "4Cx9EHKO0+809Kb4RO/4XLzMzXW4omFuzP/EzypmCZFYz92dGUqo4lRqKs1BnFZ4zN3NKRDV7JNtFhZzjVziGg==" },
  { "156872275A9B8BB6D5E771C4CF00479B9FD65006", "fqK2hs9KZReyj62O1tTfV8jplQDxFb/ZzZR1kxKNUw4=", "tNW4fPbGDLtVr2W6HOTijEggf+ePLYFVOw76k0xdWrd+oraGz0plF7KPrY7W1N9XyOmVAPEVv9nNlHWTEo1TDg==", "90867d14e7f7de8237a0a787d6b08db7d5e02d15", "c3dKkgS3Q/QKxoh1g7C3Um1m5MgH81HBwGk4drfy4/ZDL5oV6j6fUxUnVD/0EknFiE47dw6EwS7UjMhrUBxZFg==" },
  { "9E747335E2AC5EBFAB3CB88E0B8C134D5A624281", "9GHorAfi9yGTd0KRsdwhoifQTqfbITpaKU6QL1OcZiY=", "lKZPA7wJwYKkk8+aFS7eAqpwoJUvqVuGHL4BBycaci70YeisB+L3IZN3QpGx3CGiJ9BOp9shOlopTpAvU5xmJg==", "64d4e86de6423a453216add1ff4403b4cff3e370", "Nfzvt3u4P3lLKmuJ5na8CQb/qTTS6mi1xc1gtRmththPrmZuewe0TYAs6Gt3oWrlzFKWzykDNEhcxzMnsdbhPQ==" },
  { "F55AAAF48A6B9DC9052C77758019B3D7D7AE41EC", "ff1okNqIDGDl5iZfSRQ7+OEJQybbB/sUaismbgyeDjk=", "j/vlwhJpSEyjd+2Pe3tKMQAPOSbztZfkgbmvflHwVdt9/WiQ2ogMYOXmJl9JFDv44QlDJtsH+xRqKyZuDJ4OOQ==", "929369138888e470b25a412b4340cef8edecfe6e", "2+ityjP2N33pd/hyiNo1M4GoZmP1O45FDdwjA+pEP7BzqkFvaO2MFttYqx553sldoAJGWBe2mv5elsRPsmdHyw==" },
  { "387D33AF1F20D0FA2DF9F2023AFA6054C65C3B10", "dC9JU86JJVTRaVZTmK5ZjVUN4DvfiP7xVbORJexAf+0=", "kFHXuN7CXrZuxuSRZH8jxH66Z0BxVqZEU5WA+L4SVVB0L0lTzoklVNFpVlOYrlmNVQ3gO9+I/vFVs5El7EB/7Q==", "e09a99e578fed9e8053010aca1369455f6a538f7", "vkBwXXOlhfVp4DqIoKJMyCsxY2REP3s7UOxNtba/jqL2WWl/f1JILEDXS/P7ZtPYdtyfOz6R1y8Ys03WC+MTyg==" },
  { "5B80DA93F18A60A1062BBD24614FB7630E98E6D8", "Q8nqridZsertlGLBI5FD7GPJ9b4+PjF0i35UDYQJ2cU=", "S0JDganbyqNW8fuqUVXdZ3qyslzus4Uj0/BuAIE95ChDyequJ1mx6u2UYsEjkUPsY8n1vj4+MXSLflQNhAnZxQ==", "f92967aa7af6ea09972f3104e475cd6a82effe7e", "Xr6M5K/9LuelTud6VPW/hCejf4TPv1hAeWrVvwfLv+N5DL8R634CrLp8Tdi4sldRbh/LHZ7FF5jSQUkijjd3WQ==" },
  { "484AB8154ABDDC36D8180473840F6E078CB3D03B", "xSM9fo3cU5sVcEPZor7S2AXk8nsSWERMRYBTs3hYDS4=", "9vWqE+FC7Pwq4B9YvysEJrSW2oPzVaoOz7d1Mhcge2vFIz1+jdxTmxVwQ9mivtLYBeTyexJYRExFgFOzeFgNLg==", "3a5d568f74db43354c9fe52151bf9aa49324594d", "/WRZqdLMC3Jv6DL22F548RXVbXs9pjX909nqTeTnK6ASiTQM+uYY1BNPwHf37dHpa+MvfxsKZ25uKaFPCBfCvg==" },
  { "74D25D6A776DE5616A1D45D354C5C15811459AAC", "IcW6y4dd5krf/sfqdZZcu2AVsqwehHVmGExdQ7KN3Kw=", "39YvrxFr0uKiLDiM0MnkbF9HeZoCfzro5YPDGZue9/khxbrLh13mSt/+x+p1lly7YBWyrB6EdWYYTF1Dso3crA==", "45d33de2ccd31ff22438b9cb4c23b19d17e7e129", "l4h7Ex1f+GpiAVBu6+iVSTPzBta35SjhbYPVN11moH5CwNjpPDANBw4c5jrSVIwgh1bceUs2BYTCihVUC7/aSA==" },
  { "76F715119FBEE89D88047286EE080F01DB208F56", "PodgGklVqrKony8+rGgdhrqK6vytSvKXCINKSzHNVOk=", "+PSOCR/5QRaFBPiFOLOUhrD7/D+uXZ0zqYUAXaR02Yw+h2AaSVWqsqifLz6saB2Guorq/K1K8pcIg0pLMc1U6Q==", "357258cd3b943abb430e6bdfb63abdf14f122521", "sQmQFC6387tu7DwnUhOQ79kUeTmPwjl/otRC2iXwguBbSBagBDh3sA+mp/VGdgRoQKNQsatUiYOuLBFd9n5jZQ==" },
  { "61C20193E3FFA3AE13748C75F9BE5C0360EAF40C", "68RxrZD9KpeT1R2IcLRyttIKQPOVl1znRmXpGZr6g3w=", "Ctjw1eLuN0KSWXAend+BC8ZNR8ke9tF7ezrVCXOkZT3rxHGtkP0ql5PVHYhwtHK20gpA85WXXOdGZekZmvqDfA==", "0e19c29454d3ea9990febcbea738c7f7efb506d6", "MrtVEjI3T2Ddt0AxtjxBTonZnpeaBc4YyfeQSFYnN96K/v/ktYYxXa0vJPu+Kddsyu2N1Ww58RC8RQyN+yfUgg==" },
  { "979FE1853F5DE1694AD0F4DFE22D9DA585751F11", "E5qGbHc3MZNZmiK2tPgJHmgsfu3sLhslf9Sgghyp3xg=", "Nqo0TN+cKzdcQy1pqKM5+sRBJ3BygWe5SXiT/XOHQS0TmoZsdzcxk1maIra0+AkeaCx+7ewuGyV/1KCCHKnfGA==", "6cdfb574e5bc22a6ecf0f56538fe7eac4db8c341", "WZQYz62qxdG1HkRWZrVrbT30PH2DJVLRIFb4Tb5N1nHo84mIJdjj5QLqCnLkfcnsMqvXP4ZYexRH4KaOM31CTQ==" },
  { "D1F6918EA26CCF575F89A9CCA1855D63816146CB", "va+mCUG4qYur4got/dSZ8z+hc9Tsc70MXYEhvAOGQSo=", "YXppL7jXuaD2bP5t2uw2kfSVtSbRaHcfgOdXLF5Zhye9r6YJQbipi6viCi391JnzP6Fz1OxzvQxdgSG8A4ZBKg==", "8f7afd39bb6a0000363bf623609f785fe361380f", "SEdPBCRE4sHsacweG1fPJ3oqDQvAxYM+iggAqs4Qay/c+tKCcQlS8fnEYVHmTF9zeGtDlT863U0saQGQUBIPZQ==" },
  { "AAD77EAEEEB4D3971584D359012F39DEC711A886", "9maRp/WbqMOjhjO2Sd81cZ+UVqPHu9NS9R/15ClnqtA=", "5RZREvrSTowOS7jXwYkn7cvFnWwTh7URo5lXsAq3NDP2ZpGn9Zuow6OGM7ZJ3zVxn5RWo8e701L1H/XkKWeq0A==", "d87e2b985252d5035f7aeb7a1f2938c129c2d0af", "OoWBc18R8hHaY8wXCwaKqjUZk0lCrXRTKVXXczVLXA+4rytXsZavQDnXDvA6haPoyrDPSlylZIRSOxBy+do9lg==" },
  { "94CAE844B6D0C93FBF16053F02E71C4ABC5E351E", "f2xKsaeI0XC/yC4gXjbXlRfpFD1ASLV9ouprWQTXL4g=", "IybKjF30n8A9lqnFhprpHeYUEEx2XallIwn87DDl175/bEqxp4jRcL/ILiBeNteVF+kUPUBItX2i6mtZBNcviA==", "202a6cb43c4d62fbfa82841b2104701fb8f05136", "hAv21S2gIDQpgKENXHZlEZbDqO4qXk6Gosu1EmSvKdcWMjP0MVTNRU+QIk0Ore4uSclhY0aRBUzrEdrvIMNmVQ==" },
  { "BBFFD74C8C3A2A77B1720F82C91956C84EA7FC20", "/4K/Chvn1llv0UkSMzLAy+a9F55HF2iEP8vOtClPBr4=", "3jdSudbGYykSLnZ6WFEHceeQNSTHLZT9ys1GiHx4U2j/gr8KG+fWWW/RSRIzMsDL5r0XnkcXaIQ/y860KU8Gvg==", "96ee8df0ae9e52e778cd805f6d1f5f4a0ac55b48", "5RfcSB0P/9QhpId+DMGOk4Nw4idnzRCq20yK0aP7y0GjIBzr1aIWH7QGr2Cg2Iw+UyHBZ3t2K5tl+qreMlH4bg==" },
  { "AC86296DA51F836C24F503497BDF6D953286F9AC", "lgMQGnPeQw6+t6YMpUZzZ+ut/pvg+MohcbiwRdUGvVE=", "4qm1gnP5Ms+OsydsbDNknP1T/zFc7NvR8Fe7naEp/f2WAxAac95DDr63pgylRnNn663+m+D4yiFxuLBF1Qa9UQ==", "5f167e254815eea59bde0ca66afc2d27446e0444", "XjYu0pR8jD211y/AzKJ9B8uo218+p4brMGHaRxwTmU2GqcUhtclWAXjZzv8BFYEFzEC6FmuzIOIbnRjeqTLFOw==" },
  { "A1BDC0833E85AEC3B50BB8EBEA725C5B533390A9", "T25h93+Pll5da5Qmw5L0Lln4IaaYYZbpJnaTy5x0JxI=", "J4tbnJsOq64acFZqRdJ7ja1yy2Y0lobBF/QkXx+NtSlPbmH3f4+WXl1rlCbDkvQuWfghpphhlukmdpPLnHQnEg==", "c44d86e7b9407bb151d4f56782547a5761f3b923", "M5pZ+NIsQ2QlUj0ktP9ct8Anze+ClfBVgaO/LV8CyNxDfin7XgGQ69EeGDp13b8DzIIX9YCixm5tr9M63/4vUg==" },
  { "2EA515C9CC0A235C460D0D6B278F31CB2211FF32", "nYDlyNj3EDaCNiey7VElct3m/qjbq9gSHKh8W7wcvBI=", "2Un+rXP8UniTz4aFZRa3uBSroUxJitruxVOWOyWVppqdgOXI2PcQNoI2J7LtUSVy3eb+qNur2BIcqHxbvBy8Eg==", "666df529665fd68ebe480ccbc62c6bdfc8723725", "iSdYWXaviyKnPeEqwQZBWml1Dp2XM6WD54XdATXMENNBGW4pnPW0RlBHdVTnCfRcoA/0jJvnoTdvtP+6GU3OoA==" },
  { "3777876F6A33F22C908893070171957404BE2A46", "Xs8ftdMz8CXUL1jz85JAS+UdJrquO+tmOtCzLNWRxeU=", "O4gK5KQZwxFK2rFCSSPJpbdDE+zyKf85D4q3uTxOo3Rezx+10zPwJdQvWPPzkkBL5R0muq4762Y60LMs1ZHF5Q==", "4435dad67cc060fbc251b3e371edb98f37409396", "PBfBsTg4ZNE0BHSX0vb7ePtoGq1XwECFrYa2w4N+PniNI8jXOhn80tjlY7Ps75Az65osrG9Qx7NNZoUfRrD7YQ==" },
  { "C75174BB962785579067B7438B0441AA46DA90DD", "xb5EKaojiOKSTcRmxZBXT1TAtAfEb2qLVaYZT+kGrSc=", "BRPzDqmi6mIspx8KflR3Xhvsov04x3B8haxPmZzZ223FvkQpqiOI4pJNxGbFkFdPVMC0B8RvaotVphlP6QatJw==", "8b9649b69aa69c10c01a835a809d1f3affbdcb89", "BHhbtTbISTikkt/vk99WV4r4Jx+hTsEjGhRfvAHxhuCBm/8Gq+wxhBxBsY0uhHhmj4dw5302DYYbxudCsH/Ajg==" },
  { "D0B34F3884E983935480A0DF65905F9B780AC1CD", "mZ4kOi8jpySJ9c0hCrd7W0qQD/RyhBa/57fiSg3D9tc=", "gVj7S8Gti0JyByd5jOL+SUS/wg1oLUj/7I0VKl848RKZniQ6LyOnJIn1zSEKt3tbSpAP9HKEFr/nt+JKDcP21w==", "403a412b1d14e9bb31f668e2f9efa7dca9e57c49", "dhp5celvXJuzpwJagaTd3la2Lz01JGUD627fNX0cU/Wxfe5Tj93d0qiUTSe5O7+CpQdEk4ujWyy9oeXz1dT3Dw==" },
  { "F12539C22AA2F1405EE285DEFCC05C334D19196A", "ne1zErDL1sRn2ymGRY/c42sbruKE76rIr3VHzyxnpbM=", "wH//zesFkaOdegRXrgCCiX2MHIwNhWvP76SQOPkHY6+d7XMSsMvWxGfbKYZFj9zjaxuu4oTvqsivdUfPLGelsw==", "7a33f4359a6afebfa1a720a81ee75b5c1b181c24", "S4fp1aawDBifFZErazxbVHV60Kmb+TS3dLpq0Jd6kdP5nUgPVssa4k6Pcr/IVpHAOQ3obZwE39vkCIjRHRrDbg==" },
  { "86EA5CC534A1C136FB5EF5518945562FC6DE137D", "BLuWGDPXwC/Du7BMx+Hc95y2LJRNqYmQsXjFjczn3HA=", "l09RBjgTSrU3ADJHe6uGs6c6UkF4u/rqRRYPXH4QutwEu5YYM9fAL8O7sEzH4dz3nLYslE2piZCxeMWNzOfccA==", "fe1ecdc596797e40444f9e2c9f9e1994e2b38c52", "txqu/nSDLXUEJLa7u6p+sLo3VNw31KXqXBFU+NIjiSoIkZEFksL0tXL8WPOdWo7gdd6qtwaqkCEAOULju6gP6A==" },
  { "3C0246F0995223470DC78A17F8BDE09AC03289FC", "scJYNHSgh+fl0dTG1DwP4nnKBkyqQZbSr7/ThTokj/0=", "wM4DT+t2aqQkF+7QsQ4tmXuz0d/ZVdNw8uaiZgrboOyxwlg0dKCH5+XR1MbUPA/iecoGTKpBltKvv9OFOiSP/Q==", "81fc5f111761a889b1a354efd087a66b0e4eba4e", "JPIUM7e7rUYVWh9Q+F6IP1eIpQO5VSwsljPGK6HmHJ77g/G8c8a9f0yF3Ckuqsnf1OQMqVjxqSkb/h/WedRRbQ==" },
  { "0A9314B4DAD6B33D1EB7903D26F3EA91F3006CA7", "G+o0WNuhskh7YoS+a38pTLjT7dQCPiVvfFobRwSYWtM=", "uohmmBzqqF/1lcgUBmhTiTV2nt5722Shf4iPFJZDlpEb6jRY26GySHtihL5rfylMuNPt1AI+JW98WhtHBJha0w==", "7d3fac8ea0af57e6c5b29607ac09c8db24c55589", "0zy2E70bfY6gDFzCTtGieLSGQsSXhWDAlvh8EZKOygRAFdZYeki4wGCuK3TM5V6LAH8rNoz5hDOjGcFXPu214w==" },
  { "F68A69B22CCA7D6AA91123D0D82DC8D0B715EC1F", "mi4QxDKpt6jH1K/HVkSAkGhIYVXbLC1oFzG31Y0iGsM=", "ECiPfaTn3xV3k9KOJqtsbdTw/tsSzQovn5QkjOh/b/+aLhDEMqm3qMfUr8dWRICQaEhhVdssLWgXMbfVjSIaww==", "7efb5ac5240952a9898eb5a452b9e31e718ca9ea", "Ij/POHtdCZC7Zz5TgcOWbpF0eJL90nfr9gHztg9iPlh/ePjF9Wm2LSH46CacIcJGzHMqdhLy+/cO+RlIL0U1mw==" },
  { "816AC7F35322268293D130E268F90C3C55DD9109", "aNbgixf26i1llZ2SHQg2dE2JhS3AY2F0X69Q9NJLcqs=", "PMjniTE6ZJ8tT6nxRDXITeXhWYyvDHH+HWBDZp7LETlo1uCLF/bqLWWVnZIdCDZ0TYmFLcBjYXRfr1D00ktyqw==", "8c91d27781c2887f1c094cf921ccc1eaaa1c8843", "7AurM3QiIR3gwT3k6OPicyMXbBRYJZLd0181QVbXnxvFCn32g0qEBARtpd+1q7mNxCFl8D7ZLlf2L3JobaoNww==" },
  { "12DF0B4B75359031F339667012D0903B9DCDD659", "RGWbX4xKfcy6YfiBo7FMjYI0fgVbf8lO6kTiTJ99om4=", "Dyw/oFOULrhLKFIMCrvrClGZhmYhQzNABD4B+0Eb6f9EZZtfjEp9zLph+IGjsUyNgjR+BVt/yU7qROJMn32ibg==", "23c6eb51ead9c18e62d4915b8e47501ae644e145", "2i7bkNB48V59hCyxtbH1hSOPmkWvZ/acZ5WlwB8+QsDDkr+Kb8sLcvu5iyAx9cSC8XOkJs/EpiXVOHFX92od0Q==" },
  { "E84C2E0CB2AD8850377420210A96E9CCE18E9E04", "V2JvJY+Wa2KXNLQJ2akJiyrxi+ZZmvN5KHaMHNwnBiI=", "ahwZb8GeuWszii2iuT0546RTIli+6ydnzwF6OWzaSf9XYm8lj5ZrYpc0tAnZqQmLKvGL5lma83kodowc3CcGIg==", "a5dc6b3c87b33d925d2f123e50e33ac98a603df9", "1UwvXs/s+n19CFipSh7UeVE7XDRg1/F0xc0OSdFBDbUEBjUNZddLULFj0SLplRdkcye1CZePbGQTUyFT7iKxHw==" },
  { "04CA59ACBDE26ABDF10FC8C1D54AC33FA7C1E543", "szC7apaBnSxHtw4ADhlNjJ4y4nN3/uJqh7K0ksrWZuo=", "iDX6BKOxTbjUo/lePPJhTbbhgS6bD6f+/jBSEvCs1SSzMLtqloGdLEe3DgAOGU2MnjLic3f+4mqHsrSSytZm6g==", "cdbaf85930f8261f3ec8f8d775f0b19a6dd7e03b", "tTIqnWBx6pHw5SXkbwHWDMieFnI9Ju9oPTsE4UW6bbII4UIWE4VFf+fbYhlu/aZJc4cm9Y482m+uS2TrQY9QpQ==" },
  { "AEA964F8DCF71ADB9B5ACC5CEBCC6727E627815E", "VVs9dy6lqWEYDpX01RoCrlBeqUj1vl1pTuq8s9d0FgE=", "GGbg1ZAPwo20la7b7Kc7FWxMkElvYf8FBhgbV/SssWxVWz13LqWpYRgOlfTVGgKuUF6pSPW+XWlO6ryz13QWAQ==", "b6ef42a413d4836b8f73952f80005b9bd1f1be09", "R0Ns4CvMsSoVVO6VSdp/FD5EN4OqdKiT/1OxRyu1C82s0nQQQ4LPyLXWONRLVf1aIFrqbQtny1g9nJL+c0Zz3w==" },
  { "637D95E60D57EC9D5310E8AA099113436F9358FD", "Cw89GSYFHO8Uj+MDkFN1Tm5Wg670tjyJx91ZYHufkgc=", "zO9BSh7nvCxQBD7IRZ9mrfIj4yemLYcyMtCsM+jEAzQLDz0ZJgUc7xSP4wOQU3VOblaDrvS2PInH3Vlge5+SBw==", "2c5eeba786d8143584c479d0733d5ce4e1b1861d", "W7n0MYrIw1xKrh8efOMEoulrOAapt097a5Y4Ki2o9iyJin4weeymFvdHNH3h7og/bFtUDDDAzVQt1jQRC48e8g==" },
  { "4D3A891A9C7188F6C7D38099A8AFCE0758C68684", "5/YVWwhz22il+pX3Fbfz01nCqCflCdjE1mbaHTbQTUk=", "VNNvg75skDMe8pqYZxyNEooDZKZ1Z1sgwDboU157iM7n9hVbCHPbaKX6lfcVt/PTWcKoJ+UJ2MTWZtodNtBNSQ==", "42a17deda39ae9c3f2587c6e5edfc170ed7621c5", "QT0JPvLKN5vNFxiso3BB9Tmf/B1JJnhseux2dUdPQvsXpLCUuYHY5mafXzUJwAjYo2bpd2edp63iqj6wFYLtJg==" },
  { "5F0113B25EC0EBC68BE9BAA66E3A42CA884EA312", "iIWJJ0pqrOA+alZ6oi2x+14YyB5Mtjei2r7u5Ev5Zu8=", "3WiDGRMggnqeXP+Asp1fNxZlfFvPzS9ksDuaIlJcppKIhYknSmqs4D5qVnqiLbH7XhjIHky2N6Lavu7kS/lm7w==", "fe7a0cfcf7384e388f016c7c49a4d85fc2df2fb4", "vojBeFMKOsopFK2pVSQ1MV5Vmp62dQOXvdBcZ7YLW/Pa0n5a7PAyFqKSHs0+pFuDp3T03IPOyOxsgK34Gad66A==" },
  { "01761577F4142A72532DA5B24435043DB45B3D73", "+D5BFo1qF6SPJ0PlSk1Fhwxsh+IfG7ZR75nL4kZXnhY=", "WyDG/PzNgNL/8yADz/gXSKVwQ7xPMjyH6nG3wrCSpTr4PkEWjWoXpI8nQ+VKTUWHDGyH4h8btlHvmcviRleeFg==", "03143393854258e622e9fde9b3501d6a0e04a4c7", "eobnd8KZdHifmsf6bbJlNa8rO7TSdvBlBKidJld+FrhcKTnnVGRRxaHJnMIqkYX2T0uw2JlfY2WgDDXTNfUvSA==" },
};

/**
 * Get an Options object to test a single Comet instance, but considering the total
 * number of instances that will be present in the test, as well as all their keys
 * and network port numbers (contextual information required to generate the BDK
 * options JSON for every peer, since every peer's config file needs to know about
 * ALL of the peers).
 *
 * @param rootPath Root directory for the testcase.
 * @param appHash Application state hash at genesis.
 * @param p2pPort The CometBFT P2P local port number to use.
 * @param rpcPort The CometBFT RPC local port number to use.
 * @param keyNumber Index of validator key from the predefined test validator key set.
 * @param numKeys Number of validator keys to include in the genesis spec.
 * @param ports Vector of ports allocated by all peers (unused, if numKeys == 1).
 * @param numNonValidators Number of peers that are not validators (excluded from the validator set).
 * The non-validator peers, if any, are the last peers in the sequence (e.g. if numKeys == 10 and
 * numNonValidators == 3, then key indices 0..6 are validators, but keys 7..9 are excluded from the
 * validator set (but all 10 nodes are still fully connected to each other via persistent_peers).
 * @return Options object set up for testing a Comet instance.
 */
Options getOptionsForCometTest(
  const std::string rootPath,
  const bool stepMode = false,
  const std::string appHash = "",
  int p2pPort = -1, int rpcPort = -1,
  int keyNumber = 0, int numKeys = 1,
  std::vector<CometTestPorts> ports = {},
  int numNonValidators = 0
) {
  // Note: all Comet instances are validators.

  // Sanity check arguments
  if (numKeys < 1 || numKeys > cometTestKeys.size() || keyNumber < 0 || keyNumber > numKeys - 1) {
    throw DynamicException("Invalid key arguments for getOptionsForCometTest().");
  }
  if (numKeys > 1 && ports.size() != numKeys) {
    throw DynamicException("Ports vector size must match numKeys when numKeys > 1.");
  }

  // check if caller doesn't care which port cometbft uses for P2P and/or RPC
  if (p2pPort < 0) {
    p2pPort = SDKTestSuite::getTestPort();
  }
  if (rpcPort < 0) {
    rpcPort = SDKTestSuite::getTestPort();
  }

  // TODO:
  // - generate other Options parameters to allow it to test a full Blockchain instance
  //   that has a Comet instance, instead of just a standalone Comet instance

  // a default cometBFT options structure (validators and privValidatorKey to be filled in)
  json defaultCometBFTOptions = json::parse(R"(
    {
      "genesis.json":
      {
        "genesis_time": "2024-09-17T18:26:34.583377166Z",
        "chain_id": "test-chain-Q1JYzM",
        "initial_height": "0",
        "consensus_params": {
          "block": {
            "max_bytes": "22020096",
            "max_gas": "-1"
          },
          "evidence": {
            "max_age_num_blocks": "100000",
            "max_age_duration": "172800000000000",
            "max_bytes": "1048576"
          },
          "validator": {
            "pub_key_types": [
              "ed25519"
            ]
          },
          "version": {
            "app": "0"
          },
          "abci": {
            "vote_extensions_enable_height": "0"
          }
        },
        "validators": [],
        "app_hash": ""
      },
      "node_key.json": {},
      "priv_validator_key.json": {},
      "config.toml": {}
    }
  )");

  defaultCometBFTOptions["config.toml"]["p2p"] = {
    {"laddr", "tcp://0.0.0.0:" + std::to_string(p2pPort)},
    {"allow_duplicate_ip", true},
    {"addr_book_strict", false}
  };

  defaultCometBFTOptions["config.toml"]["rpc"] = {
    {"laddr", "tcp://0.0.0.0:" + std::to_string(rpcPort)},
  };

  // If the unit test is going to require more than one Comet instance, then we will need
  //   to set the BDK "peers" option with the full peer list for this peer to connect to.
  // NOTE: all keys in numKeys are peers of each other as we want all keys/nodes to be
  //   able to connect to each other.
  if (numKeys > 1) {
    // Build the peers array considering all nodes that will be peers with node keyNumber.
    std::string peersStr;
    bool first = true;
    for (int i = 0; i < ports.size(); ++i) {
      // Skip generating a peer address to connect to if that peer is itself.
      if (i != keyNumber) {
        if (! first) {
          peersStr += ",";
        } else {
          first = false;
        }
        // Given a comet node, the index in "ports" is the same as the index
        //   in "cometTestKeys" for that node.
        peersStr += cometTestKeys[i].node_id + "@localhost:" + std::to_string(ports[i].p2p);
      }
    }
    defaultCometBFTOptions["config.toml"]["p2p"]["persistent_peers"] = peersStr;
  }

  if (stepMode) {
    SLOGDEBUG("stepMode is set, setting step mode parameters for testing.");
    defaultCometBFTOptions["config.toml"]["consensus"] = {
      {"create_empty_blocks", false},
      {"timeout_propose", "1s"},
      {"timeout_propose_delta", "0s"},
      {"timeout_prevote", "1s"},
      {"timeout_prevote_delta", "0s"},
      {"timeout_precommit", "1s"},
      {"timeout_precommit_delta", "0s"},
      {"timeout_commit", "0s"}
    };
  }

  // Replace "priv_validator_key.json" with the key at index keyNumber
  const CometTestKeys& testKeys = cometTestKeys[keyNumber];
  defaultCometBFTOptions["priv_validator_key.json"] = {
    {"address", testKeys.address},
    {"pub_key", {
        {"type", "tendermint/PubKeyEd25519"},
        {"value", testKeys.pub_key}
    }},
    {"priv_key", {
        {"type", "tendermint/PrivKeyEd25519"},
        {"value", testKeys.priv_key}
    }}
  };

  // Replace "node_key.json" with the key at index keyNumber
  defaultCometBFTOptions["node_key.json"] = {
    {"priv_key", {
        {"type", "tendermint/PrivKeyEd25519"},
        {"value", testKeys.node_priv_key}
    }}
  };

  // Build the "validators" array with the first numKeys elements, but skip
  //   "numNonValidator" entries at the end.
  std::vector<json> validators;
  for (int i = 0; i < numKeys - numNonValidators; ++i) {
    const CometTestKeys& validatorKeys = cometTestKeys[i];
    json validator = {
      {"address", validatorKeys.address},
      {"pub_key", {
          {"type", "tendermint/PubKeyEd25519"},
          {"value", validatorKeys.pub_key}
      }},
      {"power", "10"}, // They all have the same voting power (doesn't matter)
      {"name", "node" + std::to_string(i)}
    };
    validators.push_back(validator);
  }

  defaultCometBFTOptions["genesis.json"]["validators"] = validators;

  defaultCometBFTOptions["genesis.json"]["app_hash"] = appHash;

  // NOTE: most parameters are unused by the Comet class
  PrivKey genesisPrivKey(Hex::toBytes("0xe89ef6409c467285bcae9f80ab1cfeb3487cfe61ab28fb7d36443e1daa0c2867"));
  FinalizedBlock genesis = FinalizedBlock::createNewValidBlock({},{}, Hash(), 0, 0, genesisPrivKey);
  const Options options = Options(
    rootPath,
    "BDK/cpp/linux_x86-64/0.2.0",
    1,
    8080,
    Address(Hex::toBytes("0x00dead00665771855a34155f5e7405489df2c3c6")),
    LOCALHOST,
    12345,
    9999,
    11,
    11,
    200,
    50,
    2000,
    10000,
    1000,
    4,
    {},
    genesis,
    0,
    genesisPrivKey,
    {},
    {},
    IndexingMode::RPC_TRACE,
    defaultCometBFTOptions
  );

  return options;
}

// Binary hash deserialization helper (to hex string without "0x" prefix)
std::string bytesToString(const Bytes& appHash) {
  return Hex::fromBytes(appHash, false).get();
}

/**
 * A simple stateful execution environment to test a Comet blockchain.
 *
 * Transactions must be ASCII strings in the following space-separated format:
 *  "<Signature> <Nonce> <Operation> <Value>"
 * Nonce is any string (whatever makes sense for the testcase).
 * The machine has a single memory cell that stores a signed integer and starts at 0.
 * A valid signature is "SIG", an invalid signature is "BADSIG", anything else is a badly formatted transaction.
 * Valid operations are + (add), - (subtract), = (set) and ? (assert value) to the memory cell.
 * The apphash is just set to the current block height at the end (h_).
 */
class TestMachine : public CometListener {
private:
  /**
   * Parse a TestMachine transaction string into its four components.
   * @param tx Transaction to be parsed (it is a plain ASCII string).
   * @param sig Parsed signature (outparam).
   * @param nonce Parsed nonce string (outparam).
   * @param op Parsed operation char (outparam) to be applied over m_.
   * @param val Parsed numeric value operand (outparam) to be appled to op over m_.
   * @return `true` if the transaction is valid and could be fully parsed, `false` otherwise.
   */
  bool parseTransaction(const Bytes& tx, std::string &sig, std::string& nonce, std::string& op, std::string& val) {
    std::string tx_str(tx.begin(), tx.end());
    std::istringstream iss(tx_str);
    if (!(iss >> sig >> nonce >> op >> val)) { return false; }
    std::string extra;
    if (iss >> extra) { return false; }
    if (sig == "BADSIG") { return false; }
    if (sig != "SIG") { return false; }
    if (op != "+" && op != "-" && op != "=" && op != "?" && op != "REVERT") { return false; }
    char* endptr;
    strtoll(val.c_str(), &endptr, 10);
    if (*endptr != '\0') { return false; }
    return true;
  }

  std::atomic<bool> enableAppHash_ = false; // Enables computing the app_hash based on m_ (instead of leaving it empty)

public:
  std::atomic<int64_t> m_ = 0; // machine state
  std::atomic<uint64_t> h_ = 0; // current block height (0 = genesis)
  std::atomic<uint64_t> incomingHeight_ = 0; // value of height we got from incomingBlock() (0 if none yet)
  std::atomic<uint64_t> incomingSyncingToHeight_ = 0; // value of syncingToHeight we got from incomingBlock() (0 if none yet)
  std::atomic<uint64_t> requiredSyncingToHeight_ = 0; // If set to != 0, requires incomingBlock(syncingToHeight) to match this value
  std::atomic<int> initChainCount_ = 0; // Flag for syncing with the cometbft InitChain callback
  Bytes appHash_; // Lastest apphash corresponding to m_ (if enableApphash_ == true)

  // ---------------------------------------------------------------------------
  // Transaction result tracker
  // ---------------------------------------------------------------------------

  // Test transaction serialization helper
  static Bytes toBytes(const std::string& str) {
    return Bytes(str.begin(), str.end());
  }

  struct TransactionDetails {
      // Fields from sendTransactionResult
      Bytes tx;
      uint64_t txId;
      bool sendSuccess;
      std::string txHash;
      std::string sendResponse;

      // Fields from checkTransactionResult
      bool checkResultArrived = false; // Indicates if a check result has been processed
      bool checkSuccess;
      std::string checkResponse;
  };
  // Map to store transaction details, indexed by txId
  std::mutex transactionMapMutex_;
  std::unordered_map<uint64_t, TransactionDetails> transactionMap_;

  std::string getSendTransactionHash(uint64_t txId) {
    std::lock_guard<std::mutex> lock(transactionMapMutex_);
    auto it = transactionMap_.find(txId);
    if (it == transactionMap_.end()) {
      LOGFATALP_THROW("Transaction ID not found: " + std::to_string(txId));
    }
    if (!it->second.sendSuccess) {
      LOGFATALP_THROW("Transaction ID wasn't successfully sent (failed or did not succeed yet): " + std::to_string(txId));
    }
    return it->second.txHash;
  }

  virtual void sendTransactionResult(
    const uint64_t tId, const Bytes& tx, const bool success,
    const std::string& txHash, const json& response
  ) override {
    GLOGDEBUG("TEST: TestMachine: Got sendTransactionResult : " + std::to_string(tId) + " hash: " + txHash + " success: " + std::to_string(success)
    + ", response: " + response.dump());
    TransactionDetails details = {tx, tId, success, txHash, response.dump(), false, false, ""};
    std::lock_guard<std::mutex> lock(transactionMapMutex_);
    transactionMap_[tId] = details;
  }

  virtual void checkTransactionResult(
    const uint64_t tId, const std::string& txHash, const bool success, const json& response
  ) override {
    GLOGDEBUG("TEST: TestMachine: Got checkTransactionResult : " + txHash + ", success: " + std::to_string(success) + ", response: " + response.dump());
    std::lock_guard<std::mutex> lock(transactionMapMutex_);
    for (auto& [txId, details] : transactionMap_) {
      if (details.txHash == txHash) {
        details.checkResultArrived = true;
        details.checkSuccess = success;
        details.checkResponse = response.dump();
        return;
      }
    }
    LOGFATALP_THROW("No matching transaction found for the given txHash.");
  }

  std::string getCheckTransactionResult(uint64_t txId) {
    std::lock_guard<std::mutex> lock(transactionMapMutex_);
    auto it = transactionMap_.find(txId);
    if (it == transactionMap_.end()) {
      LOGFATALP_THROW("Transaction ID not found: " + std::to_string(txId));
    }
    TransactionDetails& details = it->second;
    if (!details.checkResultArrived) {
      LOGFATALP_THROW("Transaction ID no check result arrived: " + std::to_string(txId));
    }
    if (!details.checkSuccess) {
      LOGFATALP_THROW("Transaction ID check result was failure: " + std::to_string(txId));
    }
    return details.checkResponse;
  }

  // ---------------------------------------------------------------------------

  TestMachine(bool enableAppHash = false) : enableAppHash_(enableAppHash) {
    updateAppHash();
  }

  /**
   * Get the appHash as a string.
   */
  std::string getAppHashString() {
    std::string ret;
    if (enableAppHash_) {
      ret = bytesToString(appHash_);
    }
    return ret;
  }

  /**
   * Recompute appHash_ based on m_ if enableAppHash_ == true.
   */
  void updateAppHash() {
    // Changing apphash generates empty blocks, making stepMode_ significantly less useful.
    // So, only compute the apphash if the testcase asks for it (via enableApphash_).
    // Don't use a proper hash here because that's just harder to debug/understand.
    appHash_.clear();
    if (enableAppHash_) {
      // int64ToBytes() is gone, so convert to use the uint version
      int64_t i = m_;
      uint64_t ui = static_cast<uint64_t>(i);
      auto arr = UintConv::uint64ToBytes(ui);
      appHash_ = Bytes(arr.begin(), arr.end());
    }
  }

  /**
   * Unfortunately, cometbft cannot be behind the application state, and by default if we don't have an app state
   * snapshot that we kept to match that "height" then we just reset to genesis.
   * TODO: allow TestMachine to store snapshots (i.e. values of m_) for all heights it processes and let tests use
   * them as they need it.
   * TODO: this callback should also forward the current validator set here because that's also state that the application
   * needs to be aware of.
   */
  void currentCometBFTHeight(const uint64_t height) override {
    if (h_ > height) {
      // comply by resetting to genesis
      GLOGDEBUG("TEST: TestMachine: currentCometBFTHeight " + std::to_string(height) + " > " + std::to_string(h_));
      h_ = 0;
      m_ = 0;
      updateAppHash();
    }
  }

  /**
   * InitChain ABCI callback.
   */
  void initChain(
    const uint64_t genesisTime, const std::string& chainId, const Bytes& initialAppState, const uint64_t initialHeight,
    const std::vector<CometValidatorUpdate>& initialValidators, Bytes& appHash) override
  {
    GLOGDEBUG("TEST: TestMachine: initChain()");
    m_ = 0;
    h_ = 0;
    incomingHeight_ = 0;
    incomingSyncingToHeight_ = 0;
    requiredSyncingToHeight_ = 0;
    ++initChainCount_;
    updateAppHash();
    appHash = appHash_;
  }

  /**
   * CheckTx ABCI callback.
   * @param tx Transaction to check.
   * @param accept Outparam to be set to `true` if the transaction is valid, `false` otherwise.
   */
  void checkTx(const Bytes& tx, int64_t& gasWanted, bool& accept) override {
    GLOGDEBUG("TEST: TestMachine: checkTx()");
    std::string sig, nonce, op, val;
    accept = parseTransaction(tx, sig, nonce, op, val);
  }

  /**
   * FinalizedBlock ABCI callback.
   * @param height The height of the block that is being delivered for processing to advance the app state.
   * @param syncingToHeight If the execution is still catching up to head (block replay) this is less than height.
   * @param txs All transactions in the block that need to be executed.
   * @param appHash Outparam that needs to be filled with the new state hash of the application, if any.
   */
  void incomingBlock(
    const uint64_t height, const uint64_t syncingToHeight, const std::vector<Bytes>& txs, const Bytes& proposerAddr,
    const uint64_t timeNanos, Bytes& appHash, std::vector<CometExecTxResult>& txResults, std::vector<CometValidatorUpdate>& validatorUpdates
  ) override
  {
    GLOGDEBUG("TEST: TestMachine: incomingBlock(): height=" + std::to_string(height) + "; syncingToheight="+std::to_string(syncingToHeight) + "; txs.size()="+std::to_string(txs.size()));
    incomingHeight_ = height;
    incomingSyncingToHeight_ = syncingToHeight;
    if (requiredSyncingToHeight_ != 0) {
      if (syncingToHeight != requiredSyncingToHeight_) {
        GLOGFATAL_THROW("incomingBlock with unexpected syncingToHeight=" + std::to_string(syncingToHeight) + "; required=" + std::to_string(requiredSyncingToHeight_));
      }
    }

    // If we get a finalized block height that is different from what our internal model is,
    //  that's an error: the consensus process would be finalizing a duplicate block, meaning
    //  it didn't correctly synchronize with the applicaiton.
    // It does not matter whether it is syncing to the height or not; our own current state should have
    //  been synchronized correctly via getCurrentState(). Whatever we report as the current height via
    //  getCurrentState() should be respected by cometbft so it doesn't give us a block that doesn't
    //  respect that current state, ever.
    if (height != h_ + 1) {
      GLOGFATAL_THROW("incomingBlock with out-of-sync height " + std::to_string(height) + "; app current height = " + std::to_string(h_));
    }

    // We need to process each transaction
    try {
      GLOGTRACE("incomingBlock: transaction count: " + std::to_string(txs.size()));
      for (const Bytes& tx : txs) {
        // Default tx result execution object:
        // code: 0 (success)
        // data: [] (zero bytes return value)
        // gas_used = 0, gas_wanted = 0
        CometExecTxResult txRes;
        // parse and validate the transaction
        std::string sig, nonce, op, val;
        bool accept = parseTransaction(tx, sig, nonce, op, val);
        if (!accept) {
          GLOGFATAL_THROW("incomingBlock: the transaction is somehow invalid");
        }
        // parse value as int
        char* endptr;
        int64_t value = strtoll(val.c_str(), &endptr, 10);
        if (*endptr != '\0') {
          // Should not reach here since we validated the tx already
          GLOGFATAL_THROW("incomingBlock: transaction has an invalid value operand");
        }
        if (op == "+") {
          m_ += value;
        } else if (op == "-") {
          m_ -= value;
        } else if (op == "=") {
          m_ = value;
        } else if (op == "?") {
          // Return the assertion result in 1 byte of the transaction return data
          txRes.data.push_back(m_ == value);
        } else if (op == "REVERT") {
          txRes.code = 1;
        } else {
          // Should not reach here since we validated the tx already
          GLOGFATAL_THROW("incomingBlock: transaction has an invalid operation");
        }
        GLOGXTRACE("TestMachine: incomingBlock updated m_ == " + std::to_string(m_));
        // Must provide Comet a tx result object for each transaction executed
        txResults.push_back(txRes);
      }
      // If all transactions are processed successfully, advance the height
      h_ = height;
      GLOGXTRACE("TestMachine: incomingBlock updated h_ == " + std::to_string(h_));
      // recompute the app_hash and return it
      updateAppHash();
      appHash = appHash_;
    } catch (...) {
      GLOGFATAL_THROW("incomingBlock: unexpected exception caugth");
    }
  }

  /**
   * PrepareProposal ABCI callback.
   * @param height Height of the block being proposed.
   * @param txs All transactions that are in the block that is being proposed, which need to be validated.
   * @param accept Outparam that should be set to `true` if the proposed transaction set is valid, `false` otherwise.
   */
  void validateBlockProposal(const uint64_t height, const std::vector<Bytes>& txs, bool& accept) override {
    GLOGDEBUG("TEST: TestMachine: validateBlockProposal(): height=" + std::to_string(height) + "; txs.size()="+std::to_string(txs.size()));
    accept = true;
    for (const Bytes& tx : txs) {
      bool tx_accept;
      int64_t gas_limit;
      checkTx(tx, gas_limit, tx_accept);
      if (!tx_accept) {
        accept = false;
        return;
      }
    }
  }

  /**
   * Info ABCI callback.
   * @param height Outparam that must be set to the current block height that the execution environment is in.
   * @param appHash Outparam that must be set to the current state hash of the application, if any.
   */
  void getCurrentState(uint64_t& height, Bytes& appHash, std::string& appSemVer, uint64_t& appVersion) override {
    GLOGDEBUG("TEST: TestMachine: getCurrentState(): h_=" + std::to_string(h_));
    // return the currently computed apphash and the current height
    appHash = appHash_;
    height = h_;
    appSemVer = "1.0.0";
    appVersion = 0;
  }

  /**
   * Answers cometbft about what's the earliest block in the chain it shouldn't prune.
   * @param height Height of the first block in the chain that should not be deleted.
   */
  void getBlockRetainHeight(uint64_t& height) override {
    GLOGDEBUG("TEST: TestMachine: getBlockRetainHeight()");
    height = 0; // retain all blocks forever
  }
};

// FIXME/TODO: must time out of all future threads so testcases will eventually cleanup/exit
namespace TComet {
  TEST_CASE("Comet tests", "[core][comet]") {

    // Very simple test flow that runs a single cometbft node that runs a single-validator blockchain
    //   that can thus advance with a single validator producing blocks.
    SECTION("CometBootTest") {
      std::string testDumpPath = createTestDumpPath("CometBootTest");

      GLOGDEBUG("TEST: Constructing Comet");

      // get free ports to run tests on
      int p2p_port = SDKTestSuite::getTestPort();
      int rpc_port = SDKTestSuite::getTestPort();

      const Options options = getOptionsForCometTest(testDumpPath, false, "", p2p_port, rpc_port);

      // Create a simple listener that just records that we got InitChain and what the current height is.
      class TestCometListener : public CometListener {
      public:
        std::atomic<bool> gotInitChain = false;
        std::atomic<uint64_t> finalizedHeight = 0;
        virtual void initChain(
          const uint64_t genesisTime, const std::string& chainId, const Bytes& initialAppState, const uint64_t initialHeight,
          const std::vector<CometValidatorUpdate>& initialValidators, Bytes& appHash
        ) override
        {
          appHash.clear();
          GLOGDEBUG("TestCometListener: got initChain");
          gotInitChain = true;
        }
        virtual void incomingBlock(
          const uint64_t height, const uint64_t syncingToHeight, const std::vector<Bytes>& txs, const Bytes& proposerAddr,
          const uint64_t timeNanos, Bytes& appHash, std::vector<CometExecTxResult>& txResults, std::vector<CometValidatorUpdate>& validatorUpdates
        ) override
        {
          GLOGDEBUG("TestCometListener: got incomingBlock " + std::to_string(height));
          finalizedHeight = height;
          appHash.clear();
          txResults.resize(txs.size());
        }
      };
      TestCometListener cometListener;

      // Set up comet with single validator
      Comet comet(&cometListener, "", options);

      // Set pause at configured
      comet.setPauseState(CometState::CONFIGURED);

      GLOGDEBUG("TEST: Starting");

      // Start comet.
      comet.start();

      // --- config check ---

      GLOGDEBUG("TEST: Waiting configuration");

      // Waits for the pause state or error status
      REQUIRE(comet.waitPauseState(10000) == "");

      // --- start ABCI server ---

      comet.setPauseState(CometState::STARTED_ABCI);

      GLOGDEBUG("TEST: Waiting for ABCI server to be successfully started");

      // Waits for the pause state or error status
      REQUIRE(comet.waitPauseState(10000) == "");

      // --- start cometbft ---

      comet.setPauseState(CometState::STARTED_COMET);

      GLOGDEBUG("TEST: Waiting for 'cometbft start' to be successfully started");

      // Waits for the pause state or error status
      REQUIRE(comet.waitPauseState(10000) == "");

      // --- test ABCI connection ---

      // Set pause at tested the comet gRPC connection
      comet.setPauseState(CometState::TESTED_COMET);

      GLOGDEBUG("TEST: Waiting for ABCI connection test");

      // Waits for the pause state or error status
      REQUIRE(comet.waitPauseState(10000) == "");

      // --- Wait for an InitChain ABCI callback ---

      GLOGDEBUG("TEST: Waiting for CometBFT InitChain");

      auto futureInitChain = std::async(std::launch::async, [&]() {
        while (!cometListener.gotInitChain) {
          std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
      });
      REQUIRE(futureInitChain.wait_for(std::chrono::seconds(5)) != std::future_status::timeout);
      REQUIRE(cometListener.gotInitChain);

      // --- Wait for a FinalizeBlock ABCI callback for a few block ---

      GLOGDEBUG("TEST: Waiting for CometBFT FinalizeBlock for 3 blocks");
      const int targetHeight = 3;
      auto futureFinalizeBlock = std::async(std::launch::async, [&]() {
        while (cometListener.finalizedHeight < targetHeight) {
          std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
      });
      REQUIRE(futureFinalizeBlock.wait_for(std::chrono::seconds(60)) != std::future_status::timeout);
      REQUIRE(cometListener.finalizedHeight >= targetHeight);

      // --- stop ---

      GLOGDEBUG("TEST: Stopping...");

      REQUIRE(comet.getStatus()); // no error reported (must check before stop())

      // Stop comet.
      comet.stop();

      GLOGDEBUG("TEST: Stopped");

      REQUIRE(comet.getState() == CometState::STOPPED);

      GLOGDEBUG("TEST: Finished");
    }

    // Simple test that runs a blockchain/genesis with two validators, that is:
    //       getOptionsForCometTest( path , 0 , 2 );   // instance 1 of 2
    //       getOptionsForCometTest( path , 1 , 2 );   // instance 2 of 2
    // This is just another trivial test that ensures we can run a CometBFT blockchain
    //   with more than one validator being required to finalize and advance state.
    SECTION("CometBootTest2") {

      GLOGDEBUG("TEST: Constructing two Comet instances");

      // get free ports to run tests on
      auto ports = generateCometTestPorts(2);

      // Create two test dump (i.e. BDK options rootPath) directories, one for each comet instance.
      // This is needed because each BDK instance only supports one running comet instance normally,
      //   so each options/rootPath has one "comet" subdirectory in it to be the cometbft home dir.
      std::string testDumpPath0 = createTestDumpPath("CometBootTest2_0");
      const Options options0 = getOptionsForCometTest(testDumpPath0, false, "", ports[0].p2p, ports[0].rpc, 0, 2, ports); // key 0 (totals 2 keys: 0 and 1)

      std::string testDumpPath1 = createTestDumpPath("CometBootTest2_1");
      const Options options1 = getOptionsForCometTest(testDumpPath1, false, "", ports[1].p2p, ports[1].rpc, 1, 2, ports); // key 1 (totals 2 keys: 0 and 1)

      // Create a simple listener that just records that we got InitChain and what the current height is.
      class TestCometListener : public CometListener {
      public:
        std::atomic<bool> gotInitChain = false;
        std::atomic<uint64_t> finalizedHeight = 0;
        virtual void initChain(
          const uint64_t genesisTime, const std::string& chainId, const Bytes& initialAppState, const uint64_t initialHeight,
          const std::vector<CometValidatorUpdate>& initialValidators, Bytes& appHash
        ) override
        {
          appHash.clear();
          GLOGDEBUG("TestCometListener: got initChain");
          gotInitChain = true;
        }
        virtual void incomingBlock(
          const uint64_t height, const uint64_t syncingToHeight, const std::vector<Bytes>& txs, const Bytes& proposerAddr,
          const uint64_t timeNanos, Bytes& appHash, std::vector<CometExecTxResult>& txResults, std::vector<CometValidatorUpdate>& validatorUpdates
        ) override
        {
          GLOGDEBUG("TestCometListener: got incomingBlock " + std::to_string(height));
          finalizedHeight = height;
          appHash.clear();
          txResults.resize(txs.size());
        }
      };

      // Instantiate the listener object twice, one for each running Comet instance
      TestCometListener cometListener0;
      TestCometListener cometListener1;

      // Set up our two running Comet instances
      Comet comet0(&cometListener0, "Comet0", options0);
      Comet comet1(&cometListener1, "Comet1", options1);

      // Start both Comet instances.
      GLOGDEBUG("TEST: Starting both Comet instances");
      comet0.start();
      comet1.start();

      // Wait for both Comet instances to find one finalized block
      GLOGDEBUG("TEST: Waiting for CometBFT FinalizeBlock to be called 3 times on both instances");
      int targetHeight = 3;
      auto futureFinalizeBlock = std::async(std::launch::async, [&]() {
        while (cometListener0.finalizedHeight < targetHeight || cometListener1.finalizedHeight < targetHeight) {
          std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
      });
      REQUIRE(futureFinalizeBlock.wait_for(std::chrono::seconds(30)) != std::future_status::timeout);
      REQUIRE(cometListener0.finalizedHeight >= targetHeight);
      REQUIRE(cometListener1.finalizedHeight >= targetHeight);

      // Stop both cometbft instances
      GLOGDEBUG("TEST: Stopping both instances...");
      REQUIRE(comet0.getStatus()); // no error reported (must check before stop())
      comet0.stop();
      REQUIRE(comet1.getStatus()); // no error reported (must check before stop())
      comet1.stop();
      GLOGDEBUG("TEST: Stopped both instances");
      REQUIRE(comet0.getState() == CometState::STOPPED);
      REQUIRE(comet1.getState() == CometState::STOPPED);
      GLOGDEBUG("TEST: Finished");
    }

    // Simple test that checks we can control block production with dispatching
    // one transaction per block while running cometbft in stepMode_ == true.
    SECTION("CometTxTest") {
      std::string testDumpPath = createTestDumpPath("CometTxTest");

      GLOGDEBUG("TEST: Constructing Comet");

      // get free ports to run tests on
      int p2p_port = SDKTestSuite::getTestPort();
      int rpc_port = SDKTestSuite::getTestPort();

      const Options options = getOptionsForCometTest(testDumpPath, true, "", p2p_port, rpc_port); // stepMode enabled

      const int txSize = 1048576;

      const uint8_t txContentByte = 0xde;
      const uint8_t txBorderByte = 0xad;

      static const std::string transactionHash = "2A62F69DB37417A3EB7E72219BDE4D6ADCD1A9878527DA245D4CC30FD1F899AB";

      // Create a simple listener that just records that we got InitChain and what the current height is.
      class TestCometListener : public CometListener {
      public:
        std::atomic<bool> gotInitChain = false;
        std::atomic<uint64_t> finalizedHeight = 0;
        std::atomic<int> txCount = 0;
        std::atomic<int> gotTxCheck = 0;
        virtual void initChain(
          const uint64_t genesisTime, const std::string& chainId, const Bytes& initialAppState, const uint64_t initialHeight,
          const std::vector<CometValidatorUpdate>& initialValidators, Bytes& appHash
        ) override
        {
          appHash.clear();
          GLOGDEBUG("TestCometListener: got initChain");
          gotInitChain = true;
        }
        virtual void incomingBlock(
          const uint64_t height, const uint64_t syncingToHeight, const std::vector<Bytes>& txs, const Bytes& proposerAddr,
          const uint64_t timeNanos, Bytes& appHash, std::vector<CometExecTxResult>& txResults, std::vector<CometValidatorUpdate>& validatorUpdates
        ) override
        {
          GLOGDEBUG("TestCometListener: got incomingBlock " + std::to_string(height));
          if (txs.size() != 0) {
            REQUIRE(txs.size() == 1);
            REQUIRE(txs[0].size() == txSize);
            REQUIRE(txs[0][0] == txBorderByte);
            bool err = false;
            for (int i = 1; i < txs[0].size() - 1; ++i) {
              if (txs[0][i] != txContentByte) {
                err = true;
                break;
              }
            }
            REQUIRE(err == false);
            REQUIRE(txs[0][txs[0].size()-1] == txBorderByte);
            ++txCount;
          }
          finalizedHeight = height;
          appHash.clear();
          txResults.resize(txs.size());
        }
        virtual void sendTransactionResult(const uint64_t tId, const Bytes& tx, const bool success, const std::string& txHash, const json& response) override {
          GLOGDEBUG("TestCometListener: got sendTransactionResult: " + response.dump() + ", txHash: " + txHash + ", success: " + std::to_string(success));
          REQUIRE(success == true);
          REQUIRE(tx.size() == txSize);
          REQUIRE(txHash == transactionHash);
        }
        virtual void checkTransactionResult(const uint64_t tId, const std::string& txHash, const bool success, const json& response) override {
          size_t jsonSize = response.dump().size();
          GLOGDEBUG("TestCometListener: got checkTransactionResult: " + std::to_string(jsonSize) + " response json bytes.");
          REQUIRE(jsonSize > txSize); // between json overhead and base64 encoding, this has to hold
          REQUIRE(success == true);
          ++gotTxCheck;
        }
      };
      TestCometListener cometListener;

      // Set up comet with single validator, no empty blocks and very large timeouts,
      //   which essentially makes cometbft only produce a block when we send a tx.
      Comet comet(&cometListener, "", options);

      // Start comet
      comet.start();

      // Wait for InitChain
      GLOGDEBUG("TEST: Waiting for CometBFT InitChain");
      auto futureInitChain = std::async(std::launch::async, [&]() {
        while (!cometListener.gotInitChain) {
          std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
      });
      REQUIRE(futureInitChain.wait_for(std::chrono::seconds(5)) != std::future_status::timeout);
      REQUIRE(cometListener.gotInitChain);

      // Wait for chain to advance to height==1
      // This also ensures we are in RUNNING state, which is required now for sendTransaction()
      // Apparently, even with produce empty blocks set to false, it produces the first block without
      //   any transactions for some reason.
      GLOGDEBUG("TEST: Waiting for CometBFT FinalizeBlock for height 1 (block 1 is created even when set to not create empty blocks)");
      auto futureFinalizeBlock1 = std::async(std::launch::async, [&]() {
        while (cometListener.finalizedHeight < 1) {
          std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
      });
      REQUIRE(futureFinalizeBlock1.wait_for(std::chrono::seconds(10)) != std::future_status::timeout);
      REQUIRE(cometListener.finalizedHeight == 1); // require exactly height 1

      // Sleep for a while: this is where block production could have
      //   most certainly advanced by now if we are allowing empty blocks
      //   to be produced and the block interval params were otherwise correct.
      // This 10s wait time is probably overkill, but we need at least one test
      //   to waste this time to ensure that stepMode_ is indeed working.
      GLOGDEBUG("TEST: Waiting to check that chain does not advance past height 1 until a transaction is sent (10s)");
      std::this_thread::sleep_for(std::chrono::seconds(10));

      // Ensure blockchain has indeed not advanced at all
      GLOGDEBUG("TEST: Checking that chain has not advanced past height 1 without a transaction");
      REQUIRE(cometListener.finalizedHeight == 1);

      // Send a transaction to cause a block to be produced
      GLOGDEBUG("TEST: Sending transaction");
      std::vector<uint8_t> largeTransaction(txSize, txContentByte);
      largeTransaction[0] = txBorderByte;
      largeTransaction[largeTransaction.size()-1] = txBorderByte;
      uint64_t tId = comet.sendTransaction(largeTransaction);
      REQUIRE(tId > 0); // Ensure RPC was actually called

      // Wait for chain to advance
      GLOGDEBUG("TEST: Waiting for CometBFT FinalizeBlock for height 2");
      auto futureFinalizeBlock2 = std::async(std::launch::async, [&]() {
        while (cometListener.finalizedHeight < 2) {
          std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
      });
      REQUIRE(futureFinalizeBlock2.wait_for(std::chrono::seconds(10)) != std::future_status::timeout);
      REQUIRE(cometListener.finalizedHeight == 2); // require exactly height 2

      // Require successful processing of the transaction we sent
      REQUIRE(cometListener.txCount == 1);

      // Check the transaction
      // Actually, you need to loop making multiple checkTransaction() calls until you get one
      // that succeeds, since CometBFT takes some time to index the transaction AFTER it has successfully
      // been included in a block.
      // In any case, it has to be able to index the successful transaction that DID go in a block in
      // say 3 seconds, so it's fine if we just wait upfront and then send one check request (simpler).
      std::this_thread::sleep_for(std::chrono::seconds(3));
      comet.checkTransaction(transactionHash);
      GLOGDEBUG("TEST: Waiting for transaction check...");
      auto futureCheckTx = std::async(std::launch::async, [&]() {
        while (cometListener.gotTxCheck < 1) {
          std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
      });
      REQUIRE(futureCheckTx.wait_for(std::chrono::seconds(10)) != std::future_status::timeout);
      REQUIRE(cometListener.gotTxCheck == 1);

      // Stop
      GLOGDEBUG("TEST: Stopping...");
      REQUIRE(comet.getStatus()); // no error reported (must check before stop())
      comet.stop();
      GLOGDEBUG("TEST: Stopped");
      REQUIRE(comet.getState() == CometState::STOPPED);
      GLOGDEBUG("TEST: Finished");
    }

    // Simple test that checks that failed transactions are returned to the listener.
    SECTION("CometTxFailTest") {
      std::string testDumpPath = createTestDumpPath("CometTxFailTest");

      GLOGDEBUG("TEST: Constructing Comet");

      const int txSize = 10000000; // Transaction is too large (10 MB)

      // Create a simple listener that just records that we got InitChain and what the current height is.
      class TestCometListener : public CometListener {
      public:
        std::atomic<uint64_t> expectedTxId_ = 0;
        std::atomic<int> failTxCount = 0;
        virtual void sendTransactionResult(const uint64_t tId, const Bytes& tx, const bool success, const std::string& txHash, const json& response) override {
          GLOGDEBUG("TestCometListener: got sendTransactionResult: " + response.dump() + ", txHash: " + txHash);
          REQUIRE(success == false); // we expect the only tx sent by this testcase to fail
          REQUIRE(tId == expectedTxId_);
          REQUIRE(tx.size() == txSize);
          ++failTxCount;
        }
      };
      TestCometListener cometListener;

      // get free ports to run tests on
      int p2p_port = SDKTestSuite::getTestPort();
      int rpc_port = SDKTestSuite::getTestPort();

      const Options options = getOptionsForCometTest(testDumpPath, true, "", p2p_port, rpc_port); // stepMode enabled

      // Set up comet with single validator
      Comet comet(&cometListener, "", options);

      // Start comet
      comet.start();

      // Need to wait for RUNNING state before sending transactions now unfortunately
      GLOGDEBUG("TEST: Waiting RUNNING state before sending transaction....");
      comet.setPauseState(CometState::RUNNING);
      REQUIRE(comet.waitPauseState(30000) == "");
      comet.setPauseState();

      // Send a transaction to cause a block to be produced
      GLOGDEBUG("TEST: Sending transaction");
      std::vector<uint8_t> largeTransaction(txSize, 0x00);
      cometListener.expectedTxId_ = comet.sendTransaction(largeTransaction);
      REQUIRE(cometListener.expectedTxId_ > 0); // ensure it got sent

      // Wait for failTxCount
      GLOGDEBUG("TEST: Waiting for sendTransaction to fail");
      auto futureFailTx = std::async(std::launch::async, [&]() {
        while (cometListener.failTxCount < 1) {
          std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
      });
      REQUIRE(futureFailTx.wait_for(std::chrono::seconds(10)) != std::future_status::timeout);

      // Require that the transaction has failed
      REQUIRE(cometListener.failTxCount == 1);

      // Stop
      GLOGDEBUG("TEST: Stopping...");
      REQUIRE(comet.getStatus()); // no error reported (must check before stop())
      comet.stop();
      GLOGDEBUG("TEST: Stopped");
      REQUIRE(comet.getState() == CometState::STOPPED);
      GLOGDEBUG("TEST: Finished");
    }

    // Test for transaction results such as reverted transaction or transaction return data
    SECTION("CometTxResultTest") {

      std::string testDumpPath = createTestDumpPath("CometTxResultTest");

      GLOGDEBUG("TEST: Constructing Comet");

      // Create a TestMachine with app_hash enabled.
      TestMachine cometListener(true);

      // get free ports to run tests on
      int p2p_port = SDKTestSuite::getTestPort();
      int rpc_port = SDKTestSuite::getTestPort();

      const Options options = getOptionsForCometTest(testDumpPath, false, cometListener.getAppHashString(), p2p_port, rpc_port);

      // Set up comet with single validator and no stepMode.
      Comet comet(&cometListener, "", options);

      // Start comet.
      GLOGDEBUG("TEST: Starting Comet");
      comet.start();

      // Need to wait for RUNNING state before sending transactions now unfortunately
      GLOGDEBUG("TEST: Waiting RUNNING state before sending transaction....");
      comet.setPauseState(CometState::RUNNING);
      REQUIRE(comet.waitPauseState(30000) == "");
      comet.setPauseState();

      // Send transactions
      uint64_t succeedAssertTxId = comet.sendTransaction(TestMachine::toBytes("SIG 1 ? 0")); // m_ == 0 so this returndata is true
      REQUIRE(succeedAssertTxId > 0);
      uint64_t failAssertTxId = comet.sendTransaction(TestMachine::toBytes("SIG 2 ? 9876")); // m_ == 0 so this returndata is false
      REQUIRE(failAssertTxId > 0);
      uint64_t revertTxId = comet.sendTransaction(TestMachine::toBytes("SIG 3 REVERT 1111")); // operand (1111) is ignored when REVERT op
      REQUIRE(revertTxId > 0);

      // It's just simpler to wait for some large amount of time which guarantees that the transactions were included in a block
      std::this_thread::sleep_for(std::chrono::seconds(5));

      // After waiting a lot we can just call checkTransaction() to get the results since the txHash will already have resolved
      // and the /tx endpoint will return the transaction result (sufficient time for the successful tx indexing to run also)
      comet.checkTransaction(cometListener.getSendTransactionHash(succeedAssertTxId));
      comet.checkTransaction(cometListener.getSendTransactionHash(failAssertTxId));
      comet.checkTransaction(cometListener.getSendTransactionHash(revertTxId));

      // And now just wait a little longer so that the Comet engine can make the 3 /tx RPC calls for sure
      std::this_thread::sleep_for(std::chrono::seconds(3));

      // After this long wait we expect the whole send/check pipeline must have resolved for all transactions
      std::string succeedAssertResult = cometListener.getCheckTransactionResult(succeedAssertTxId);
      std::string failAssertResult = cometListener.getCheckTransactionResult(failAssertTxId);
      std::string revertResult = cometListener.getCheckTransactionResult(revertTxId);

      GLOGDEBUG("TEST: succeedAssertResult: " + succeedAssertResult);
      GLOGDEBUG("TEST: failAssertResult: " + failAssertResult);
      GLOGDEBUG("TEST: revertResult: " + revertResult);

      // It's faster if we just assert for the expected code/data field substrings in the json string
      REQUIRE(succeedAssertResult.find("\"data\":\"AQ==\"") != std::string::npos); // AQ== is 1 in base64 (i.e. true, assert passed)
      REQUIRE(succeedAssertResult.find("\"code\":0,") != std::string::npos); // code == 0: not reverted
      REQUIRE(failAssertResult.find("\"data\":\"AA==\"") != std::string::npos); // AA== is 0 in base64 (i.e. false, assert failed)
      REQUIRE(failAssertResult.find("\"code\":0,") != std::string::npos); // code == 0: not reverted
      REQUIRE(revertResult.find("\"data\":null") != std::string::npos); // empty return value for the revert tx
      REQUIRE(revertResult.find("\"code\":1,") != std::string::npos); // code == 1: reverted

      // Stop
      GLOGDEBUG("TEST: Stopping...");
      REQUIRE(comet.getStatus()); // no error reported (must check before stop())
      comet.stop();
      GLOGDEBUG("TEST: Stopped");
      REQUIRE(comet.getState() == CometState::STOPPED);
      GLOGDEBUG("TEST: Finished");
    }

    // Stop at block M and restart test with no block replay, 1 validator
    // (snapshotted state at M before shutdown reported by Info on restart)
    // Non-empty transactions and verify that it reaches the same end state
    SECTION("CometRestartTest") {

      std::string testDumpPath = createTestDumpPath("CometRestartTest");

      GLOGDEBUG("TEST: Constructing Comet");

      TestMachine cometListener;

      // get free ports to run tests on
      int p2p_port = SDKTestSuite::getTestPort();
      int rpc_port = SDKTestSuite::getTestPort();

      const Options options = getOptionsForCometTest(testDumpPath, true, cometListener.getAppHashString(), p2p_port, rpc_port); // stepMode enabled

      // Set up comet with single validator
      Comet comet(&cometListener, "", options);

      // Start comet.
      GLOGDEBUG("TEST: Starting Comet");
      comet.start();

      // Need to wait for RUNNING state before sending transactions now unfortunately
      GLOGDEBUG("TEST: Waiting RUNNING state before sending transaction....");
      comet.setPauseState(CometState::RUNNING);
      REQUIRE(comet.waitPauseState(30000) == "");
      comet.setPauseState();

      // Should stop at height 10
      // Don't send a transation for height 1, since height 1 is seemingly produced
      // even without a transaction from the app (empty block even with produce
      // empty blocks option disabled).
      GLOGDEBUG("TEST: Sending several ++m_ transactions...");
      int targetHeight = 10;
      int expectedMachineMemoryValue = 0;
      for (int i = 1; i <= targetHeight; ++i) {

        GLOGDEBUG("TEST: Height=" + std::to_string(i));
        // send a transaction (skip height==1 as that height is produced regardless).
        if (i != 1) {
          // transaction increments the memory cell (++cometListener.m_)
          // The second parameter (i) is serving as the nonce (need to uniquify the transaction
          //   otherwise it is understood as a replay).
          std::string transaction = "SIG " + std::to_string(i) + " + 1";
          GLOGDEBUG("TEST: Sending transaction: " + transaction);
          Bytes transactionBytes(transaction.begin(), transaction.end());
          comet.sendTransaction(transactionBytes);
          ++expectedMachineMemoryValue;
        }

        // Wait for chain to advance
        auto futureFinalizeBlock = std::async(std::launch::async, [&]() {
          while (cometListener.h_ < i) {
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
          }
        });
        REQUIRE(futureFinalizeBlock.wait_for(std::chrono::seconds(10)) != std::future_status::timeout);

        // Ensure the block and transaction had the intended effect on the machine
        GLOGDEBUG("TEST: Checking we are at block " + std::to_string(i) + " and m_ == " + std::to_string(expectedMachineMemoryValue));
        REQUIRE(cometListener.h_ == i);
        REQUIRE(cometListener.m_ == expectedMachineMemoryValue);
      }

      // Stop comet.
      GLOGDEBUG("TEST: Stopping comet (before restart step)");
      REQUIRE(comet.getStatus()); // no error reported (must check before stop())
      comet.stop();
      GLOGDEBUG("TEST: Stopped");
      REQUIRE(comet.getState() == CometState::STOPPED);

      // Before stopping again, ensure that we are in the running state (otherwise we can
      // finish replay before we get to opening our RPC connection, which generates
      // unnecessary logging and RPC connection retries).
      comet.setPauseState(CometState::RUNNING);

      // Restart comet
      GLOGDEBUG("TEST: Restarting");
      comet.start();
      GLOGDEBUG("TEST: Restarted");

      // This behavior actually depends on the app hash / commit hash changes;
      // cometbft produces empty blocks regardless of the create-empty-blocks setting if
      // there's a change in app hash / commit hash (not sure why or how that works exactly).
      // In any case, we can't depend on it; the empty blocks option is for optimizing the
      // network, not creating a step-mode for block production / debugging.
      //
      //   So it turns out that upon a successful restart, we should get a block produced
      //    that is empty (again, ignoring our "dont't produce empty blocks) config.
      //   That's actually useful, because it gives us a condition to wait for here.
      //   In addition, the TestMachine class will error out if the restart generates a
      //    bad incomingBlock() callback that would ignore what getCurrentState() is
      //    informing cometbft.
      //
      // Wait for the last non-empty block we created before (targetHeight)
      auto futureFinalizeBlock = std::async(std::launch::async, [&]() {
        while (cometListener.h_ < targetHeight) {
          std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
      });
      REQUIRE(futureFinalizeBlock.wait_for(std::chrono::seconds(10)) != std::future_status::timeout);
      REQUIRE(cometListener.h_ >= targetHeight); // We *might* produce more blocks (empty blocks), which is fine
      REQUIRE(cometListener.m_ == expectedMachineMemoryValue); // Double-check that we didn't screw up the previous state

      // Waits for RUNNING so we know we are past RPC connection established and so we can just stop now.
      REQUIRE(comet.waitPauseState(60000) == "");
      comet.setPauseState(); // unset the pause state (not needed since stop() does it, but nicer)

      // Stop
      GLOGDEBUG("TEST: Stopping...");
      REQUIRE(comet.getStatus()); // no error reported (must check before stop())
      comet.stop();
      GLOGDEBUG("TEST: Stopped");
      REQUIRE(comet.getState() == CometState::STOPPED);
      GLOGDEBUG("TEST: Finished");
    }

    // Stop at block M and restart test with block replay from M/2, 1 validator
    // (Info on restart reports block M/2 thus replays M/2+1 to M)
    // Non-empty transactions and verify that it reaches the same end state
    SECTION("CometReplayTest") {

      std::string testDumpPath = createTestDumpPath("CometReplayTest");

      GLOGDEBUG("TEST: Constructing Comet");

      TestMachine cometListener;

      // get free ports to run tests on
      int p2p_port = SDKTestSuite::getTestPort();
      int rpc_port = SDKTestSuite::getTestPort();

      const Options options = getOptionsForCometTest(testDumpPath, true, cometListener.getAppHashString(), p2p_port, rpc_port); // stepMode enabled

      // Set up comet with single validator
      Comet comet(&cometListener, "", options);

      // Start comet.
      GLOGDEBUG("TEST: Starting Comet");
      comet.start();

      // Need to wait for RUNNING state before sending transactions now unfortunately
      GLOGDEBUG("TEST: Waiting RUNNING state before sending transaction....");
      comet.setPauseState(CometState::RUNNING);
      REQUIRE(comet.waitPauseState(30000) == "");
      comet.setPauseState();

      // Should stop at height 10
      // Don't send a transation for height 1, since height 1 is seemingly produced
      // even without a transaction from the app (empty block even with produce
      // empty blocks option disabled).
      GLOGDEBUG("TEST: Sending several ++m_ transactions...");
      int targetHeight = 10;
      int expectedMachineMemoryValue = 0;
      for (int i = 1; i < targetHeight; ++i) {

        GLOGDEBUG("TEST: Height=" + std::to_string(i));
        // send a transaction (skip height==1 as that height is produced regardless).
        if (i != 1) {
          // transaction increments the memory cell (++cometListener.m_)
          // The second parameter (i) is serving as the nonce (need to uniquify the transaction
          //   otherwise it is understood as a replay).
          std::string transaction = "SIG " + std::to_string(i) + " + 1";
          GLOGDEBUG("TEST: Sending transaction: " + transaction);
          Bytes transactionBytes(transaction.begin(), transaction.end());
          comet.sendTransaction(transactionBytes);
          ++expectedMachineMemoryValue;
        }

        // Wait for chain to advance
        auto futureFinalizeBlock = std::async(std::launch::async, [&]() {
          while (cometListener.h_ < i) {
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
          }
        });
        REQUIRE(futureFinalizeBlock.wait_for(std::chrono::seconds(10)) != std::future_status::timeout);

        // Ensure the block and transaction had the intended effect on the machine
        GLOGDEBUG("TEST: Checking we are at block " + std::to_string(i) + " and m_ == " + std::to_string(expectedMachineMemoryValue));
        REQUIRE(cometListener.h_ == i);
        REQUIRE(cometListener.m_ == expectedMachineMemoryValue);
      }

      // Stop comet.
      GLOGDEBUG("TEST: Stopping comet (before restart step)");
      REQUIRE(comet.getStatus()); // no error reported (must check before stop())
      comet.stop();
      GLOGDEBUG("TEST: Stopped");
      REQUIRE(comet.getState() == CometState::STOPPED);

      // Here we will pretend that our node has crashed, and thus we have rolled back
      // our state to a previously-saved snapshot state, and so we need cometbft to
      // replay some blocks for us.
      GLOGDEBUG("TEST: Rolling back state (h_ == " + std::to_string(cometListener.h_) + ", m_ == " + std::to_string(cometListener.m_) + ")");
      int finalAppState = cometListener.m_;
      int finalAppHeight = cometListener.h_;
      int snapshotAppHeight = cometListener.h_ / 2;
      for (int i = finalAppHeight; i > snapshotAppHeight; --i) {
        // Since all transactions we send to the app do ++m_, then each
        //  height we unstack from the blockchain means we need to do --m_
        //  (remember that this doesn't apply to height==1 since the first
        //  block is empty because cometbft doesn't strictly respect the
        //  "don't produce empty blocks" option, but since we are unstacking
        //  it only back to h_/2, and h_ is like 9 here, then we should be
        //  well clear off of accidentally unstacking the NOP block 1.)
        --cometListener.h_;
        --cometListener.m_;
        cometListener.updateAppHash(); // since we changed m_
      }
      GLOGDEBUG("TEST: Rolled back state (h_ == " + std::to_string(cometListener.h_) + ", m_ == " + std::to_string(cometListener.m_) + ")");

      // Set the requiredSyncingToHeight_ into the machine (will throw if it doesn't match)
      cometListener.requiredSyncingToHeight_ = finalAppHeight;

      // Before stopping again, ensure that we are in the running state (otherwise we can
      // finish replay before we get to opening our RPC connection, which generates
      // unnecessary logging and RPC connection retries).
      comet.setPauseState(CometState::RUNNING);

      // Restart comet
      GLOGDEBUG("TEST: Restarting");
      comet.start();
      GLOGDEBUG("TEST: Restarted");

      // Wait until we get back to the finalAppHeight we recorded before the rollback.
      auto futureFinalizeBlock = std::async(std::launch::async, [&]() {
        while (cometListener.h_ < finalAppHeight) {
          std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
      });
      REQUIRE(futureFinalizeBlock.wait_for(std::chrono::seconds(10)) != std::future_status::timeout);
      REQUIRE(cometListener.h_ == finalAppHeight);
      REQUIRE(cometListener.m_ == finalAppState); // Double-check we reproduced the state after the replay

      // Reset the required syncing to height, no longer syncing
      cometListener.requiredSyncingToHeight_ = 0;

      // Sleep a bit and ensure we didn't get some garbage added to the chain afterwards
      std::this_thread::sleep_for(std::chrono::seconds(10));
      REQUIRE(cometListener.h_ == finalAppHeight);
      REQUIRE(cometListener.m_ == finalAppState);

      // Waits for RUNNING so we know we are past RPC connection established and so we can just stop now.
      REQUIRE(comet.waitPauseState(60000) == "");
      comet.setPauseState(); // unset the pause state (not needed since stop() does it, but nicer)

      // Stop
      GLOGDEBUG("TEST: Stopping...");
      REQUIRE(comet.getStatus()); // no error reported (must check before stop())
      comet.stop();
      GLOGDEBUG("TEST: Stopped");
      REQUIRE(comet.getState() == CometState::STOPPED);
      GLOGDEBUG("TEST: Finished");
    }

    // Produce some blocks (without stepMode), stop, rewind to genesis and replay,
    // with app_hash computing over m_ enabled.
    SECTION("CometReplayAppHashTest") {

      std::string testDumpPath = createTestDumpPath("CometReplayAppHashTest");

      GLOGDEBUG("TEST: Constructing Comet");

      // Create a TestMachine with app_hash enabled.
      TestMachine cometListener(true);

      // get free ports to run tests on
      int p2p_port = SDKTestSuite::getTestPort();
      int rpc_port = SDKTestSuite::getTestPort();

      const Options options = getOptionsForCometTest(testDumpPath, false, cometListener.getAppHashString(), p2p_port, rpc_port);

      // Set up comet with single validator and no stepMode.
      Comet comet(&cometListener, "", options);

      // Start comet.
      GLOGDEBUG("TEST: Starting Comet");
      comet.start();

      // Need to wait for RUNNING state before sending transactions now unfortunately
      GLOGDEBUG("TEST: Waiting RUNNING state before sending transaction....");
      comet.setPauseState(CometState::RUNNING);
      REQUIRE(comet.waitPauseState(30000) == "");
      comet.setPauseState();

      // Send several transactions across different blocks (stepMode is disabled,
      // so cometbft can produce empty blocks).
      GLOGDEBUG("TEST: Sending several ++m_ transactions...");
      int numTxs = 10;
      int64_t expectedMachineMemoryValue = 0;
      for (int i = 0; i < numTxs; ++i) {

        // transaction increments the memory cell (++cometListener.m_)
        // The second parameter (i) is serving as the nonce (need to uniquify the transaction
        //   otherwise it is understood as a replay).
        std::string transaction = "SIG " + std::to_string(i) + " + 1";
        GLOGDEBUG("TEST: Sending transaction: " + transaction);
        Bytes transactionBytes(transaction.begin(), transaction.end());
        comet.sendTransaction(transactionBytes);
        ++expectedMachineMemoryValue;

        // Wait for memory cell to update (meaning the transaction was picked up)
        GLOGDEBUG("TEST: Waiting for m_ == " + std::to_string(expectedMachineMemoryValue));
        auto futureMemoryUpdated = std::async(std::launch::async, [&]() {
          while (cometListener.m_ != expectedMachineMemoryValue) {
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
          }
        });
        REQUIRE(futureMemoryUpdated.wait_for(std::chrono::seconds(10)) != std::future_status::timeout);

        // Log the appHash
        GLOGDEBUG("TEST: AppHash is now: " + bytesToString(cometListener.appHash_));

        // Ensure the block and transaction had the intended effect on the machine
        GLOGDEBUG("TEST: Checking m_ == " + std::to_string(expectedMachineMemoryValue));
        REQUIRE(cometListener.m_ == expectedMachineMemoryValue);
      }

      // Stop comet.
      GLOGDEBUG("TEST: Stopping comet (before restart step)");
      REQUIRE(comet.getStatus()); // no error reported (must check before stop())
      comet.stop();
      GLOGDEBUG("TEST: Stopped");
      REQUIRE(comet.getState() == CometState::STOPPED);

      // Roll back the application state to genesis state.
      GLOGDEBUG("TEST: Rolling back state to genesis");
      cometListener.h_ = 0;
      cometListener.m_ = 0;
      cometListener.updateAppHash(); // since we changed m_

      // Before stopping again, ensure that we are in the running state (otherwise we can
      // finish replay before we get to opening our RPC connection, which generates
      // unnecessary logging and RPC connection retries).
      comet.setPauseState(CometState::RUNNING);

      // Restart comet
      GLOGDEBUG("TEST: Restarting");
      comet.start();
      GLOGDEBUG("TEST: Restarted");

      // Wait until m_ is restored (we don't have to determine in what height this happens).
      GLOGDEBUG("TEST: Waiting for catch up to m_ == " + std::to_string(expectedMachineMemoryValue));
      auto futureMemoryUpdated = std::async(std::launch::async, [&]() {
        while (cometListener.m_ != expectedMachineMemoryValue) {
          std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
      });
      REQUIRE(futureMemoryUpdated.wait_for(std::chrono::seconds(60)) != std::future_status::timeout);
      GLOGDEBUG("TEST: Final check for m_ == " + std::to_string(expectedMachineMemoryValue));
      REQUIRE(cometListener.m_ == expectedMachineMemoryValue);

      // Waits for RUNNING so we know we are past RPC connection established and so we can just stop now.
      REQUIRE(comet.waitPauseState(60000) == "");
      comet.setPauseState(); // unset the pause state (not needed since stop() does it, but nicer)

      // Stop
      GLOGDEBUG("TEST: Stopping...");
      REQUIRE(comet.getStatus()); // no error reported (must check before stop())
      comet.stop();
      GLOGDEBUG("TEST: Stopped");
      REQUIRE(comet.getState() == CometState::STOPPED);
      GLOGDEBUG("TEST: Finished");
    }

    // Validator produces blocks, then launch another non-validator node
    // that connects to it and syncs from some block height.
    SECTION("CometSyncTest") {

      GLOGDEBUG("TEST: Constructing two Comet instances");

      // Instantiate the listener object twice, one for each running Comet instance
      TestMachine cometListener0(true);
      TestMachine cometListener1(true);

      // get free ports to run tests on
      auto ports = generateCometTestPorts(2);

      // Create two test dump (i.e. BDK options rootPath) directories, one for each comet instance.
      // This is needed because each BDK instance only supports one running comet instance normally,
      //   so each options/rootPath has one "comet" subdirectory in it to be the cometbft home dir.
      // numKeys == 2 (keys 0 and 1), and numNonValidators (last param) == 1, since only comet0 is
      //   a validator; comet1 is a nonvalidator that will sync to the chain mined only by comet0.
      std::string testDumpPath0 = createTestDumpPath("CometSyncTest_0");
      const Options options0 = getOptionsForCometTest(testDumpPath0, false, cometListener0.getAppHashString(), ports[0].p2p, ports[0].rpc, 0, 2, ports, 1);

      std::string testDumpPath1 = createTestDumpPath("CometSyncTest_1");
      const Options options1 = getOptionsForCometTest(testDumpPath1, false, cometListener1.getAppHashString(), ports[1].p2p, ports[1].rpc, 1, 2, ports, 1);

      // Set up our two running Comet instances
      Comet comet0(&cometListener0, "Comet0", options0);
      Comet comet1(&cometListener1, "Comet1", options1);

      // Start the validator first so the chain can advance to the target block height.
      GLOGDEBUG("TEST: Starting validator (node 0)");
      comet0.start();

      // Need to wait for RUNNING state before sending transactions now unfortunately
      GLOGDEBUG("TEST: Waiting RUNNING state before sending transaction....");
      comet0.setPauseState(CometState::RUNNING);
      REQUIRE(comet0.waitPauseState(30000) == "");
      comet0.setPauseState();

      // Send several transactions across different blocks (stepMode is disabled,
      // so cometbft can produce empty blocks).
      GLOGDEBUG("TEST: Sending several ++m_ transactions...");
      int numTxs = 3;
      int64_t expectedMachineMemoryValue = 0;
      for (int i = 0; i < numTxs; ++i) {

        // transaction increments the memory cell (++cometListener.m_)
        // The second parameter (i) is serving as the nonce (need to uniquify the transaction
        //   otherwise it is understood as a replay).
        std::string transaction = "SIG " + std::to_string(i) + " + 1";
        GLOGDEBUG("TEST: Sending transaction: " + transaction);
        Bytes transactionBytes(transaction.begin(), transaction.end());
        comet0.sendTransaction(transactionBytes);
        ++expectedMachineMemoryValue;

        // Wait for memory cell to update (meaning the transaction was picked up)
        GLOGDEBUG("TEST: Waiting for m_ == " + std::to_string(expectedMachineMemoryValue));
        auto futureMemoryUpdated = std::async(std::launch::async, [&]() {
          while (cometListener0.m_ != expectedMachineMemoryValue) {
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
          }
        });
        REQUIRE(futureMemoryUpdated.wait_for(std::chrono::seconds(10)) != std::future_status::timeout);

        // Log the appHash
        GLOGDEBUG("TEST: AppHash is now: " + cometListener0.getAppHashString()); //std::to_string(Utils::bytesToInt64(cometListener0.appHash_)));

        // Ensure the block and transaction had the intended effect on the machine
        GLOGDEBUG("TEST: Checking m_ == " + std::to_string(expectedMachineMemoryValue));
        REQUIRE(cometListener0.m_ == expectedMachineMemoryValue);
      }

      // Fetch the current block height (any value here is good, even if this is racing
      // block production, since any h_ value here is guaranteed to have the state after
      // the test transactions above, which is what matters).
      uint64_t comet1StartHeight = cometListener0.h_;
      uint64_t comet1StartMachineMemoryValue = cometListener0.m_;
      Bytes comet1StartAppHash = cometListener0.appHash_;
      std::string comet1StartAppHashStr = bytesToString(comet1StartAppHash);

      GLOGDEBUG(
        "TEST: comet1StartHeight will be " + std::to_string(comet1StartHeight) +
        ", comet1StartMachineMemoryValue will be " + std::to_string(comet1StartMachineMemoryValue) +
        ", comet1StartAppHash will be " + comet1StartAppHashStr
      );

      // Wait for comet0 to produce at least one more block
      auto futureFinalizeBlock = std::async(std::launch::async, [&]() {
        while (cometListener0.h_ <= comet1StartHeight) {
          std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
      });
      REQUIRE(futureFinalizeBlock.wait_for(std::chrono::seconds(10)) != std::future_status::timeout);
      REQUIRE(cometListener0.h_ > comet1StartHeight);

      // Add another set of transactions to produce a final target state
      // Send several transactions across different blocks (stepMode is disabled,
      // so cometbft can produce empty blocks).
      GLOGDEBUG("TEST: Sending more ++m_ transactions...");
      int startTxs = numTxs;
      numTxs = 3;
      for (int i = startTxs; i < startTxs + numTxs; ++i) {

        // transaction increments the memory cell (++cometListener.m_)
        // The second parameter (i) is serving as the nonce (need to uniquify the transaction
        //   otherwise it is understood as a replay).
        std::string transaction = "SIG " + std::to_string(i) + " + 1";
        GLOGDEBUG("TEST: Sending transaction: " + transaction);
        Bytes transactionBytes(transaction.begin(), transaction.end());
        comet0.sendTransaction(transactionBytes);
        ++expectedMachineMemoryValue;

        // Wait for memory cell to update (meaning the transaction was picked up)
        GLOGDEBUG("TEST: Waiting for m_ == " + std::to_string(expectedMachineMemoryValue));
        auto futureMemoryUpdated = std::async(std::launch::async, [&]() {
          while (cometListener0.m_ != expectedMachineMemoryValue) {
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
          }
        });
        REQUIRE(futureMemoryUpdated.wait_for(std::chrono::seconds(10)) != std::future_status::timeout);

        // Log the appHash
        GLOGDEBUG("TEST: AppHash is now: " + cometListener0.getAppHashString());

        // Ensure the block and transaction had the intended effect on the machine
        GLOGDEBUG("TEST: Checking m_ == " + std::to_string(expectedMachineMemoryValue));
        REQUIRE(cometListener0.m_ == expectedMachineMemoryValue);
      }

      // Here comet0 will just keep running.
      // Whatever h_ comet0 is in now will be the sync target for comet1, as it will already
      //   have the second batch of test transactions applied to it.
      uint64_t comet1TargetHeight = cometListener0.h_;
      uint64_t comet1TargetMachineMemoryValue = cometListener0.m_;
      Bytes comet1TargetAppHash = cometListener0.appHash_;
      std::string comet1TargetAppHashStr = bytesToString(comet1TargetAppHash);
      GLOGDEBUG(
        "TEST: comet1TargetHeight will be " + std::to_string(comet1TargetHeight) +
        ", comet1TargetMachineMemoryValue will be " + std::to_string(comet1TargetMachineMemoryValue) +
        ", comet1TargetAppHash will be " + comet1TargetAppHashStr
      );

      // Now we switch to testing comet1
      // Start by rigging the cometListener1 to start at the start height and memory value,
      //   as if it had loaded a BDK app state DB/snapshot.
      // NOTE: These will be simply ignored, since cometbft height is 0 (this is a fresh node).
      //       TestMachine will force its h_ to genesis when it is notified of this.
      // TODO: In a future version, the Comet driver will use cometbft state sync,
      //       snapshots, light-client verification, etc. instead and this test will
      //       actually start the node1 instance from comet1StartHeight and its current
      //       comet1StartMachineMemoryValue and comet1StartAppHash, without reverting to
      //       genesis state.
      cometListener1.h_ = comet1StartHeight;
      cometListener1.m_ = comet1StartMachineMemoryValue;
      cometListener1.appHash_ = comet1StartAppHash;

      // Start comet1 at the start height
      GLOGDEBUG("TEST: Starting non-validator (node 1) at comet1Start* values as logged above");
      comet1.start();

      // Wait for comet1 to reach the taget height
      auto futureFinalizeBlock1 = std::async(std::launch::async, [&]() {
        while (cometListener1.h_ <= comet1TargetHeight) {
          std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
      });
      REQUIRE(futureFinalizeBlock1.wait_for(std::chrono::seconds(10)) != std::future_status::timeout);
      REQUIRE(cometListener1.h_ > comet1TargetHeight);

      // comet1 must have synced to the target state
      REQUIRE(cometListener1.m_ == comet1TargetMachineMemoryValue);
      REQUIRE(cometListener1.appHash_ == comet1TargetAppHash);

      // Stop both cometbft instances
      GLOGDEBUG("TEST: Stopping both instances...");
      REQUIRE(comet0.getStatus()); // no error reported (must check before stop())
      comet0.stop();
      REQUIRE(comet1.getStatus()); // no error reported (must check before stop())
      comet1.stop();
      GLOGDEBUG("TEST: Stopped both instances");
      REQUIRE(comet0.getState() == CometState::STOPPED);
      REQUIRE(comet1.getState() == CometState::STOPPED);
      GLOGDEBUG("TEST: Finished");
    }

    // Start chain with two validators 0 and 1 (both are required to advance the chain since need 2/3 votes).
    // Change validator set to add validator 2.
    // Change validator set to remove validator 0 (now both 1 and 2 are required to advance the chain, but not 0).
    // Stop validator 0, verify that chain continues advancing normally.
    SECTION("CometValidatorSetTest") {

      GLOGDEBUG("TEST: Constructing three Comet instances");

      // Listener that tracks the validator set
      class TestCometListener : public CometListener {
      public:
        std::atomic<uint64_t> finalizedHeight_ = 0;
        virtual void initChain(
          const uint64_t genesisTime, const std::string& chainId, const Bytes& initialAppState, const uint64_t initialHeight,
          const std::vector<CometValidatorUpdate>& initialValidators, Bytes& appHash
        ) override
        {
          appHash.clear();
          GLOGDEBUG("TestCometListener: got initChain");
          // the genesis state has nodes 0 and 1 as validators only
          REQUIRE(initialValidators.size() == 2);
          REQUIRE(initialValidators[0].publicKey.size() == 32);
          REQUIRE(initialValidators[1].publicKey.size() == 32);
          std::string vs0 = base64::encode_into<std::string>(initialValidators[0].publicKey.begin(), initialValidators[0].publicKey.end());
          std::string vs1 = base64::encode_into<std::string>(initialValidators[1].publicKey.begin(), initialValidators[1].publicKey.end());
          // for some reason they can be flipped around (we can't use the order in the vector, although we should be able to get them in order...)
          // so we have to search the validator keys in the whole vector
          bool foundKey0 = vs0 == cometTestKeys[0].pub_key || vs1 == cometTestKeys[0].pub_key;
          bool foundKey1 = vs0 == cometTestKeys[1].pub_key || vs1 == cometTestKeys[1].pub_key;
          REQUIRE(foundKey0);
          REQUIRE(foundKey1);
        }
        virtual void incomingBlock(
          const uint64_t height, const uint64_t syncingToHeight, const std::vector<Bytes>& txs, const Bytes& proposerAddr,
          const uint64_t timeNanos, Bytes& appHash, std::vector<CometExecTxResult>& txResults, std::vector<CometValidatorUpdate>& validatorUpdates
        ) override
        {
          GLOGDEBUG("TestCometListener: got incomingBlock " + std::to_string(height));
          finalizedHeight_ = height;
          appHash.clear();

          // At height == 2, we add node 2, so now the validator set has nodes 0, 1, and 2
          if (height == 2) {
            CometValidatorUpdate update;
            update.publicKey = base64::decode_into<Bytes>(cometTestKeys[2].pub_key);
            REQUIRE(update.publicKey.size() == 32);
            update.power = 10;
            validatorUpdates.push_back(update);
          }

          // At height == 5, we remove node 0, so now the validator set has nodes 1 and 2 only
          if (height == 5) {
            CometValidatorUpdate update;
            update.publicKey = base64::decode_into<Bytes>(cometTestKeys[0].pub_key);
            REQUIRE(update.publicKey.size() == 32);
            update.power = 0;
            validatorUpdates.push_back(update);
          }
        }
      };
      TestCometListener cometListener0;
      TestCometListener cometListener1;
      TestCometListener cometListener2;

      // get free ports to run tests on
      auto ports = generateCometTestPorts(3);

      // Create nodes 0 and 1 as validators, and node 2 as a non-validator (it will be promoted to validator later)
      // The validator/non-validator setup here affects the validator set for genesis; we're free to change the validator
      //   set as we go as the non-validator nodes also get public/private validator keypairs even if those aren't initially
      //   listed in the genesis validator set.
      std::string testDumpPath0 = createTestDumpPath("CometValidatorSetTest_0");
      const Options options0 = getOptionsForCometTest(testDumpPath0, false, "", ports[0].p2p, ports[0].rpc, 0, 3, ports, 1);
      std::string testDumpPath1 = createTestDumpPath("CometValidatorSetTest_1");
      const Options options1 = getOptionsForCometTest(testDumpPath1, false, "", ports[1].p2p, ports[1].rpc, 1, 3, ports, 1);
      std::string testDumpPath2 = createTestDumpPath("CometValidatorSetTest_2");
      const Options options2 = getOptionsForCometTest(testDumpPath2, false, "", ports[2].p2p, ports[2].rpc, 2, 3, ports, 1);

      // Create the three nodes
      Comet comet0(&cometListener0, "Comet0", options0);
      Comet comet1(&cometListener1, "Comet1", options1);
      Comet comet2(&cometListener2, "Comet2", options2);

      // Start all of them
      GLOGDEBUG("TEST: Starting all validators");
      comet0.start();
      comet1.start();
      comet2.start();

      // Wait for block 8 on validator 1
      GLOGDEBUG("TEST: Waiting for node 1 to reach block 8...");
      auto futureFinalizeBlock = std::async(std::launch::async, [&]() {
        while (cometListener1.finalizedHeight_ < 8) {
          std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
      });
      REQUIRE(futureFinalizeBlock.wait_for(std::chrono::seconds(60)) != std::future_status::timeout);
      REQUIRE(cometListener1.finalizedHeight_ >= 8);

      // Stop node 0
      GLOGDEBUG("TEST: Stopping node 0 (chain must continue since node0 is no longer a validator)...");
      REQUIRE(comet0.getStatus()); // no error reported (must check before stop())
      comet0.stop();
      REQUIRE(comet0.getState() == CometState::STOPPED);
      GLOGDEBUG("TEST: Stopped node 0");

      // Wait for block 11 on validator 1
      GLOGDEBUG("TEST: Waiting for node 1 to reach block 11...");
      auto futureFinalizeBlock2 = std::async(std::launch::async, [&]() {
        while (cometListener1.finalizedHeight_ < 11) {
          std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
      });
      REQUIRE(futureFinalizeBlock2.wait_for(std::chrono::seconds(20)) != std::future_status::timeout);
      REQUIRE(cometListener1.finalizedHeight_ >= 11);

      // Stop both remaining cometbft instances
      GLOGDEBUG("TEST: Stopping node 1 and node 2...");
      REQUIRE(comet1.getStatus()); // no error reported (must check before stop())
      comet1.stop();
      REQUIRE(comet2.getStatus()); // no error reported (must check before stop())
      comet2.stop();
      GLOGDEBUG("TEST: Stopped node1 and node 2.");
      REQUIRE(comet1.getState() == CometState::STOPPED);
      REQUIRE(comet2.getState() == CometState::STOPPED);
      GLOGDEBUG("TEST: Finished");
    }

    // Test Comet RPC call API
    SECTION("CometRpcCallTest") {
      std::string testDumpPath = createTestDumpPath("CometRpcCallTest");

      GLOGDEBUG("TEST: Constructing Comet");

      int p2p_port = SDKTestSuite::getTestPort();
      int rpc_port = SDKTestSuite::getTestPort();
      const Options options = getOptionsForCometTest(testDumpPath, false, "", p2p_port, rpc_port);

      // Just use the dummy default listener
      CometListener cometListener;
      Comet comet(&cometListener, "", options);

      // Set pause at inspect so we can use RPC calls on inspect
      comet.setPauseState(CometState::INSPECT_RUNNING);
      GLOGDEBUG("TEST: Starting comet...");
      comet.start();
      GLOGDEBUG("TEST: Waiting for cometbft inspect RPC to be up...");
      REQUIRE(comet.waitPauseState(10000) == "");

      // Make an RPC call
      GLOGDEBUG("TEST: Making rpcSyncCall()...");
      json healthResult;
      bool success = comet.rpcSyncCall("header", json::object(), healthResult);
      GLOGDEBUG("TEST: rpcSyncCall() result: " + healthResult.dump());
      REQUIRE(success == true);
      // expect null block header from latest block since the chain is empty
      REQUIRE(healthResult.contains("result"));
      REQUIRE(healthResult["result"].contains("header"));
      REQUIRE(healthResult["result"]["header"].is_null());

      // Don't need to unpause, can just stop
      GLOGDEBUG("TEST: Stopping...");
      REQUIRE(comet.getStatus()); // no error reported (must check before stop())
      comet.stop();
      GLOGDEBUG("TEST: Stopped");
      REQUIRE(comet.getState() == CometState::STOPPED);
      GLOGDEBUG("TEST: Finished");
    }

    // Test the Comet transaction cache
    SECTION("CometTxCacheTest") {
      std::string testDumpPath = createTestDumpPath("CometTxCacheTest");

      GLOGDEBUG("TEST: Constructing Comet");

      int p2p_port = SDKTestSuite::getTestPort();
      int rpc_port = SDKTestSuite::getTestPort();
      const Options options = getOptionsForCometTest(testDumpPath, false, "", p2p_port, rpc_port);

      TestMachine cometListener(true);
      Comet comet(&cometListener, "", options);

      // Guarantee that txCache is enabled
      comet.setTransactionCacheSize(1000000);

      // Start Comet driver
      GLOGDEBUG("TEST: Starting comet...");
      comet.start();

      // Need to wait for RUNNING state before sending transactions now unfortunately
      GLOGDEBUG("TEST: Waiting RUNNING state before sending transaction....");
      comet.setPauseState(CometState::RUNNING);
      REQUIRE(comet.waitPauseState(30000) == "");
      comet.setPauseState();

      // Fetch current block height
      uint64_t seenHeight = cometListener.h_;
      GLOGDEBUG("TEST: Before sending the transaction, chain is at height: " + std::to_string(seenHeight));

      // Send the transaction. We can't predict in which block this will end up but we don't have to.
      GLOGDEBUG("TEST: Sending a transaction...");

      std::shared_ptr<Hash> ethHashPtr;
      comet.sendTransaction(TestMachine::toBytes("SIG 1 REVERT 1111"), &ethHashPtr); // operand (1111) is ignored when REVERT op

      REQUIRE(ethHashPtr.get() != nullptr);
      Hash& ethHash = *ethHashPtr.get();

      // Aggressively poll the cache in a busy loop
      GLOGDEBUG("TEST: Querying txCache until transaction is included in a block...");
      CometTxStatus txs;
      auto futureFinalizeTx = std::async(std::launch::async, [&]() {
        int64_t previousIndex = CometTxStatusHeight::NONE;
        do {
          comet.checkTransactionInCache(ethHash, txs);
          if (txs.height != previousIndex) {
            REQUIRE(txs.height > previousIndex); // as the tx status evolves, the height value always increases
            REQUIRE(txs.height != CometTxStatusHeight::REJECTED); // cometbft broadcast_tx_async should not reject it
            previousIndex = txs.height;
            GLOGDEBUG(
              "TEST: Transaction status: height: " + std::to_string(txs.height) +
              " index: " + std::to_string(txs.index) +
              " cometTxHash: " + txs.cometTxHash +
              " code: " + std::to_string(txs.result.code) +
              " data: " + bytesToString(txs.result.data) +
              " gasWanted: " + std::to_string(txs.result.gasWanted) +
              " gasUsed: " + std::to_string(txs.result.gasUsed)
            );
          }
          // Do not sleep here; do a busy wait to try to catch and log every state transition.
        } while (txs.height < 0);
      });
      REQUIRE(futureFinalizeTx.wait_for(std::chrono::seconds(10)) != std::future_status::timeout);
      REQUIRE(txs.height > seenHeight); // must necessarily be greater than a finalized height we have seen before sending the transaction
      REQUIRE(txs.index == 0); // first transaction in the block (since it is the only one)
      REQUIRE(txs.result.code == 1); // the TestMachine "REVERT" op tx transaction should have a revert status

      // Stop
      GLOGDEBUG("TEST: Stopping...");
      REQUIRE(comet.getStatus()); // no error reported (must check before stop())
      comet.stop();
      GLOGDEBUG("TEST: Stopped");
      REQUIRE(comet.getState() == CometState::STOPPED);
      GLOGDEBUG("TEST: Finished");
    }

    // setpriv test. setpriv is not *really* optional -- you must have setpriv in your path
    // to run the tests, otherwise this test will just fail.
    SECTION("CometSetprivTest") {
      // setpriv must be available, if not always then at least for running tests
      boost::filesystem::path setpriv_path = boost::process::search_path("setpriv");
      REQUIRE(!setpriv_path.empty());

      std::string testDumpPath = createTestDumpPath("CometSetprivTest");
      int p2p_port = SDKTestSuite::getTestPort();
      int rpc_port = SDKTestSuite::getTestPort();
      const Options options = getOptionsForCometTest(testDumpPath, false, "", p2p_port, rpc_port);
      CometListener cometListener;
      Comet comet(&cometListener, "", options);

      // Expected test behavior (if tasks take a minimally-reasonable time to complete):
      // < 5s: child process has cometbft inspect server running
      // at 5s: parent process sees RPC port to cometbft inspect is open
      // at 10s: child process terminates itself, making setpriv-wrapped cometbft inspect
      //         terminate itself soon after.
      // at 15s: parent process sees RPC port to cometbft inspect is closed

      // Spawn a disposable child process of the tester with a different PID that will actually call
      // comet.start(), and then the parent tester process will kill that process, which should kill
      // its child process (cometbft inspect) due to its setpriv wrapper.
      pid_t pid = fork();
      // Fork must have succeeded
      REQUIRE(pid != -1);
      if (pid == 0) {
        // Redirect stdout and stderr to /dev/null so we don't get any duplicate
        // Catch2 harness output generated, which is confusing and which we do get
        // if the prctrl() below goes into effect (i.e. we get a SIGTERM)
        int devnull = open("/dev/null", O_WRONLY);
        if (devnull == -1) {
          std::cerr << "ERROR: CometSetprivTest: can't open /dev/null" << std::endl;
          _exit(1); // _exit with underscore guarantees we immediately die
        }
        dup2(devnull, STDOUT_FILENO);
        dup2(devnull, STDERR_FILENO);
        close(devnull);
        // This is the tester child process, which wraps setpriv, which wraps cometbft inspect
        // Make sure this child process dies if the parent tester dies first for whatever reason
        // so we don't get dangling processes.
        std::cout << "CometSetprivTest: In child process." << std::endl;
        if (prctl(PR_SET_PDEATHSIG, SIGTERM) == -1) {
          std::cerr << "ERROR: CometSetprivTest: prctl() failed" << std::endl;
          _exit(1); // _exit with underscore guarantees we immediately die
        }
        // Hold the driver at "cometbft inspect" running, which is enough to test
        comet.setPauseState(CometState::INSPECT_RUNNING);
        // Only start the driver in the child process
        comet.start();
        comet.waitPauseState(10000);
        std::cout << "CometSetprivTest: Child process reached CometState::INSPECT_RUNNING" << std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(10));
        std::cout << "CometSetprivTest: Child process forcefully terminating itself" << std::endl;
        // We just kill ourselves after exactly 10 seconds -- we don't receive an
        // external SIGTERM, which is problematic. Instead, which is easier and simpler,
        // we just quit, so we can check that the setpriv mechanism is working.
        // This emulates any kind of failure condition where the BDK node (parent of the
        // cometbft process) dies for whatever reason.
        _exit(0); // _exit with underscore guarantees we immediately die
      }

      // Everything from here on runs in the parent tester process only
      GLOGDEBUG("TEST: Waiting 5s to test RPC port of child with PID = " + std::to_string(pid));

      // Give the child time to run prctrl() and then actually start cometbft inspect
      std::this_thread::sleep_for(std::chrono::seconds(5));

      // try to connect to the cometbft inspect RPC port. this should succeed, meaning that
      // starting cometbft inspect actually worked in the first place.
      GLOGDEBUG("TEST: Testing RPC port (must be open)");
      try {
        boost::asio::io_context io_context;
        boost::asio::ip::tcp::socket socket(io_context);
        boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::make_address("127.0.0.1"), rpc_port);
        socket.connect(endpoint);
        GLOGDEBUG("TEST: cometbft inspect RPC port is open as expected: " + std::to_string(rpc_port));
        socket.close();
      } catch (const std::exception& e) {
        FAIL("TEST: ERROR, failed to connect to RPC port when it should be open: " + std::to_string(rpc_port) + ": " + std::string(e.what()));
      }

      // Give the child time to decide to terminate on its own, and time for
      // the setpriv wrapper to detect that its parent process has died, so
      // it send SIGTERM to cometbft inspect, which then closes the RPC port.
      GLOGDEBUG("TEST: Waiting another 10s to test RPC port of child with PID = " + std::to_string(pid));
      std::this_thread::sleep_for(std::chrono::seconds(10));

      // try to connect to the cometbft inspect RPC port. this should fail,
      // which is enough for us to conclude that the cometbft inspect process is dead.
      GLOGDEBUG("TEST: Testing RPC port (must be closed)");
      try {
        boost::asio::io_context io_context;
        boost::asio::ip::tcp::socket socket(io_context);
        boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::make_address("127.0.0.1"), rpc_port);
        socket.connect(endpoint);
        FAIL("TEST: ERROR: connection to cometbft inspect RPC port succeeded, but port should be closed: " + std::to_string(rpc_port));
        socket.close();
      } catch (const std::exception& e) {
        GLOGDEBUG("TEST: SUCCESS, failed to connect to cometbft inspect RPC port, which was expected: " + std::string(e.what()));
      }
    }
  }
}
