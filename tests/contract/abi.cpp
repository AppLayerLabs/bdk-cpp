#include "../../src/contract/abi.h"
#include "../../src/libs/catch2/catch_amalgamated.hpp"
#include "../../src/utils/json.hpp"
#include "../../src/utils/strings.h"
#include "../../src/utils/utils.h"

#include <boost/filesystem.hpp>
#include <fstream>

using Catch::Matchers::Equals;

namespace TABI {
TEST_CASE("ABI Namespace", "[contract][abi]") {
  SECTION("Encode Uint256 (Single)") {
    ABI::Encoder::EncVar eV;
    eV.push_back(uint256_t("12038189571283151234217456623442137"));

    ABI::Encoder e(eV, std::string("testUint(uint256)"));
    std::string eS = e.getRaw();

    REQUIRE(eS.substr(0, 4) == Hex::toBytes("c7a16965"));
    REQUIRE(eS.substr(4) == Hex::toBytes("0000000000000000000000000000000000025"
                                         "187505f9a7cca5c5178e81858d9"));
  }

  SECTION("Encode Uint256 (Multiple)") {
    ABI::Encoder::EncVar eV;
    eV.push_back(uint256_t("985521342366467353964568564348544758443523147426"));
    eV.push_back(
        uint256_t("3453441424448154428346543455122894428593523456453894523"));
    eV.push_back(uint256_t(
        "238745423894452554435879784534423784946532544278453254451345"));

    ABI::Encoder e(eV,
                   std::string("testMultipleUint(uint256,uint256,uint256)"));
    std::string eS = e.getRaw();

    REQUIRE(eS.substr(0, 4) == Hex::toBytes("aab4c13b"));
    REQUIRE(eS.substr(4, 32) ==
            Hex::toBytes("000000000000000000000000aca04e2e6a9c731a64f56964ab72e"
                         "6c8270786a2"));
    REQUIRE(eS.substr(36, 32) ==
            Hex::toBytes("000000000000000000240e3c8296e085da6a626254ed08dd8b032"
                         "86c83bbe17b"));
    REQUIRE(eS.substr(68, 32) ==
            Hex::toBytes("000000000000002608ca87ae5c3b4312e205f41a89f288579ccd1"
                         "9f908317091"));
  }

  SECTION("Encode Uint256 (Array)") {
    ABI::Encoder::EncVar eV;
    eV.push_back(std::vector<uint256_t>{
        uint256_t("19283178512315252514312458124312935128381523"),
        uint256_t("31482535189448189541125434144"),
        uint256_t("1123444185124184138124378143891242186794252455823414458"),
        uint256_t("215345189442554346421356134551234851234484")});

    ABI::Encoder e(eV, std::string("testUintArr(uint256[])"));
    std::string eS = e.getRaw();

    REQUIRE(eS.substr(0, 4) == Hex::toBytes("d1a4e446"));
    REQUIRE(eS.substr(4, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000020"));
    REQUIRE(eS.substr(36, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000004"));
    REQUIRE(eS.substr(68, 32) ==
            Hex::toBytes("0000000000000000000000000000dd5c2b23fbb5fb408500075ff"
                         "573e1383853"));
    REQUIRE(eS.substr(100, 32) ==
            Hex::toBytes("000000000000000000000000000000000000000065b9be246336b"
                         "3f36607ab20"));
    REQUIRE(eS.substr(132, 32) ==
            Hex::toBytes("0000000000000000000bbab3b46bd0328e1d17617db2abfefc190"
                         "46a083e14ba"));
    REQUIRE(eS.substr(164, 32) ==
            Hex::toBytes("00000000000000000000000000000278d7b6df6a4c94873a7d655"
                         "9bcab95e2b4"));
  }

  SECTION("Encode String (Single)") {
    ABI::Encoder::EncVar eV;
    eV.push_back("Hello World!");

    ABI::Encoder e(eV, std::string("testString(string)"));
    std::string eS = e.getRaw();

    REQUIRE(eS.substr(0, 4) == Hex::toBytes("61cb5a01"));
    REQUIRE(eS.substr(4, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000020"));
    REQUIRE(eS.substr(36, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "0000000000c"));
    REQUIRE(eS.substr(68, 32) ==
            Hex::toBytes("48656c6c6f20576f726c642100000000000000000000000000000"
                         "00000000000"));
  }

  SECTION("Encode Bool (Multiple)") {
    ABI::Encoder::EncVar eV;
    eV.push_back(true);
    eV.push_back(false);
    eV.push_back(true);

    ABI::Encoder e(eV, std::string("testMultipleBool(bool,bool,bool)"));
    std::string eS = e.getRaw();

    REQUIRE(eS.substr(0, 4) == Hex::toBytes("49fdef10"));
    REQUIRE(eS.substr(4, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000001"));
    REQUIRE(eS.substr(36, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(68, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000001"));
  }

  SECTION("Encode String (Array) + Uint256 (Array)") {
    ABI::Encoder::EncVar eV;
    eV.push_back(std::vector<std::string>{"First String", "Second String",
                                          "Third String"});
    eV.push_back(std::vector<uint256_t>{
        uint256_t("129838151824165123321245841287434198"),
        uint256_t("2134584124125984418451243118545129854235"),
        uint256_t("1234812315823541285534458693557693548423844235"),
        uint256_t("32452893445892345238552138945234454324523194514")});

    ABI::Encoder e(eV,
                   std::string("testStringArrWithUintArr(string[],uint256[])"));
    std::string eS = e.getRaw();

    REQUIRE(eS.substr(0, 4) == Hex::toBytes("023c4a5e"));
    REQUIRE(eS.substr(4, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000040"));
    REQUIRE(eS.substr(36, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000180"));
    REQUIRE(eS.substr(68, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000003"));
    REQUIRE(eS.substr(100, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000060"));
    REQUIRE(eS.substr(132, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "000000000a0"));
    REQUIRE(eS.substr(164, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "000000000e0"));
    REQUIRE(eS.substr(196, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "0000000000c"));
    REQUIRE(eS.substr(228, 32) ==
            Hex::toBytes("466972737420537472696e6700000000000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(260, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "0000000000d"));
    REQUIRE(eS.substr(292, 32) ==
            Hex::toBytes("5365636f6e6420537472696e67000000000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(324, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "0000000000c"));
    REQUIRE(eS.substr(356, 32) ==
            Hex::toBytes("546869726420537472696e6700000000000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(388, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000004"));
    REQUIRE(eS.substr(420, 32) ==
            Hex::toBytes("0000000000000000000000000000000000190183df26aa795c3b0"
                         "1e079ae4fd6"));
    REQUIRE(eS.substr(452, 32) ==
            Hex::toBytes("0000000000000000000000000000000645e1f2c6dad3d9f1675c8"
                         "163df32551b"));
    REQUIRE(eS.substr(484, 32) ==
            Hex::toBytes("00000000000000000000000000375ef34102454b2b5222061ed99"
                         "b03a148918b"));
    REQUIRE(eS.substr(516, 32) ==
            Hex::toBytes("00000000000000000000000005af3cf248a13bc919ac44299b86c"
                         "8a94ba65892"));
  }

  SECTION("Encode Address (Single)") {
    ABI::Encoder::EncVar eV;
    eV.push_back(Address(
        std::string("0x873630b0fAE5F8c69392Abdabb3B15270D137Ca1"), false));

    ABI::Encoder e(eV, std::string("testAddress(address)"));
    std::string eS = e.getRaw();

    REQUIRE(eS.substr(0, 4) == Hex::toBytes("42f45790"));
    REQUIRE(eS.substr(4) == Hex::toBytes("000000000000000000000000873630b0fae5f"
                                         "8c69392abdabb3b15270d137ca1"));
  }

  SECTION("Encode Bytes (Single)") {
    ABI::Encoder::EncVar eV;
    eV.push_back(Hex::toBytes("0xc8191d2e98e7cd9201cef777f85bf857"));

    ABI::Encoder e(eV, std::string("testBytes(bytes)"));
    std::string eS = e.getRaw();

    REQUIRE(eS.substr(0, 4) == Hex::toBytes("3ca8b1a7"));
    REQUIRE(eS.substr(4, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000020"));
    REQUIRE(eS.substr(36, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000010"));
    REQUIRE(eS.substr(68, 32) ==
            Hex::toBytes("c8191d2e98e7cd9201cef777f85bf857000000000000000000000"
                         "00000000000"));
  }

  SECTION("Encode Bytes (Array) + String (Array)") {
    ABI::Encoder::EncVar eV;
    eV.push_back(std::vector<std::string>{
        Hex::toBytes("0x81a1217428d6d8ff7a419e87cfc948d2"),
        Hex::toBytes("0x2d96cf448d1d455d9013572ac07edefc"),
        Hex::toBytes("0xc584d0de5dbddca6e74686a3c154bb28"),
        Hex::toBytes("0xdb6f06ea16ab61dca14053001c6b5815")});
    eV.push_back(std::vector<std::string>{
        "First String", "Second String", "Third String",
        "Forth String" // Someone fix this typo for the love of the cosmos
    });

    ABI::Encoder e(eV, std::string("testBytesArrWithStrArr(bytes[],string[])"));
    std::string eS = e.getRaw();

    REQUIRE(eS.substr(0, 4) == Hex::toBytes("f1881d9f"));
    REQUIRE(eS.substr(4, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000040"));
    REQUIRE(eS.substr(36, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "000000001e0"));
    REQUIRE(eS.substr(68, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000004"));
    REQUIRE(eS.substr(100, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000080"));
    REQUIRE(eS.substr(132, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "000000000c0"));
    REQUIRE(eS.substr(164, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000100"));
    REQUIRE(eS.substr(196, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000140"));
    REQUIRE(eS.substr(228, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000010"));
    REQUIRE(eS.substr(260, 32) ==
            Hex::toBytes("81a1217428d6d8ff7a419e87cfc948d2000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(292, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000010"));
    REQUIRE(eS.substr(324, 32) ==
            Hex::toBytes("2d96cf448d1d455d9013572ac07edefc000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(356, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000010"));
    REQUIRE(eS.substr(388, 32) ==
            Hex::toBytes("c584d0de5dbddca6e74686a3c154bb28000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(420, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000010"));
    REQUIRE(eS.substr(452, 32) ==
            Hex::toBytes("db6f06ea16ab61dca14053001c6b5815000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(484, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000004"));
    REQUIRE(eS.substr(516, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000080"));
    REQUIRE(eS.substr(548, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "000000000c0"));
    REQUIRE(eS.substr(580, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000100"));
    REQUIRE(eS.substr(612, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000140"));
    REQUIRE(eS.substr(644, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "0000000000c"));
    REQUIRE(eS.substr(676, 32) ==
            Hex::toBytes("466972737420537472696e6700000000000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(708, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "0000000000d"));
    REQUIRE(eS.substr(740, 32) ==
            Hex::toBytes("5365636f6e6420537472696e67000000000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(772, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "0000000000c"));
    REQUIRE(eS.substr(804, 32) ==
            Hex::toBytes("546869726420537472696e6700000000000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(836, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "0000000000c"));
    REQUIRE(eS.substr(868, 32) ==
            Hex::toBytes("466f72746820537472696e6700000000000000000000000000000"
                         "00000000000"));
  }

  SECTION("Encode All") {
    ABI::Encoder::EncVar eV;
    eV.push_back(uint256_t("19283816759128317851231551416451212"));
    eV.push_back(std::vector<uint256_t>{
        uint256_t("1239381517249318561241694412"),
        uint256_t("2395843472138412758912309213482574123672567"),
        uint256_t("9138482765346472349817634647689124123"),
        uint256_t("9234782382341248283491")});
    eV.push_back(true);
    eV.push_back(std::vector<bool>{false, true, false});
    eV.push_back(Address(
        std::string("0x873630b0fAE5F8c69392Abdabb3B15270D137Ca1"), false));
    eV.push_back(std::vector<Address>{
        Address(std::string("0x2D061c095b06efed6A54b6e9B3f50f1b55cce2FF"),
                false),
        Address(std::string("0x873630b0fAE5F8c69392Abdabb3B15270D137Ca1"),
                false),
        Address(std::string("0xA462f6A66CC4465fA2d5E90EFA6757f615125760"),
                false)});
    eV.push_back(Hex::toBytes("0xec05537ed99fc9053e29368726573b25"));
    eV.push_back(std::vector<std::string>{
        Hex::toBytes("0xadfae295d92644d19f69e4f20f28d0ae"),
        Hex::toBytes("0x6777b56cd127407ae1b1cc309905521e"),
        Hex::toBytes("0x52719fe16375c2446b109dfcf9336c38"),
        Hex::toBytes("0x6763b32cbd1c695a694d66fe2e729c97")});
    eV.push_back("This is a string");
    eV.push_back(std::vector<std::string>{"Yes", "This", "Is", "A", "String",
                                          "Array", "How stupid lol"});

    ABI::Encoder e(eV,
                   std::string("testAll(uint256,uint256[],bool,bool[],address,"
                               "address[],bytes,bytes[],string,string[])"));
    std::string eS = e.getRaw();

    REQUIRE(eS.substr(0, 4) == Hex::toBytes("d8d2684c"));
    REQUIRE(eS.substr(4, 32) ==
            Hex::toBytes("000000000000000000000000000000000003b6c3fc7f2d1514406"
                         "85a319c408c"));
    REQUIRE(eS.substr(36, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000140"));
    REQUIRE(eS.substr(68, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000001"));
    REQUIRE(eS.substr(100, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "000000001e0"));
    REQUIRE(eS.substr(132, 32) ==
            Hex::toBytes("000000000000000000000000873630b0fae5f8c69392abdabb3b1"
                         "5270d137ca1"));
    REQUIRE(eS.substr(164, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000260"));
    REQUIRE(eS.substr(196, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "000000002e0"));
    REQUIRE(eS.substr(228, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000320"));
    REQUIRE(eS.substr(260, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "000000004c0"));
    REQUIRE(eS.substr(292, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000500"));
    REQUIRE(eS.substr(324, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000004"));
    REQUIRE(eS.substr(356, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000401313ead502"
                         "c4caecd00cc"));
    REQUIRE(eS.substr(388, 32) ==
            Hex::toBytes("00000000000000000000000000001b80c04c816f5d3f60d46e2c5"
                         "68de014a3f7"));
    REQUIRE(eS.substr(420, 32) ==
            Hex::toBytes("0000000000000000000000000000000006e001fc95fc94cdd8261"
                         "74c57e3d91b"));
    REQUIRE(eS.substr(452, 32) ==
            Hex::toBytes("0000000000000000000000000000000000000000000001f49e59b"
                         "0c3edac7363"));
    REQUIRE(eS.substr(484, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000003"));
    REQUIRE(eS.substr(516, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(548, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000001"));
    REQUIRE(eS.substr(580, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(612, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000003"));
    REQUIRE(eS.substr(644, 32) ==
            Hex::toBytes("0000000000000000000000002d061c095b06efed6a54b6e9b3f50"
                         "f1b55cce2ff"));
    REQUIRE(eS.substr(676, 32) ==
            Hex::toBytes("000000000000000000000000873630b0fae5f8c69392abdabb3b1"
                         "5270d137ca1"));
    REQUIRE(eS.substr(708, 32) ==
            Hex::toBytes("000000000000000000000000a462f6a66cc4465fa2d5e90efa675"
                         "7f615125760"));
    REQUIRE(eS.substr(740, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000010"));
    REQUIRE(eS.substr(772, 32) ==
            Hex::toBytes("ec05537ed99fc9053e29368726573b25000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(804, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000004"));
    REQUIRE(eS.substr(836, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000080"));
    REQUIRE(eS.substr(868, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "000000000c0"));
    REQUIRE(eS.substr(900, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000100"));
    REQUIRE(eS.substr(932, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000140"));
    REQUIRE(eS.substr(964, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000010"));
    REQUIRE(eS.substr(996, 32) ==
            Hex::toBytes("adfae295d92644d19f69e4f20f28d0ae000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(1028, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000010"));
    REQUIRE(eS.substr(1060, 32) ==
            Hex::toBytes("6777b56cd127407ae1b1cc309905521e000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(1092, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000010"));
    REQUIRE(eS.substr(1124, 32) ==
            Hex::toBytes("52719fe16375c2446b109dfcf9336c38000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(1156, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000010"));
    REQUIRE(eS.substr(1188, 32) ==
            Hex::toBytes("6763b32cbd1c695a694d66fe2e729c97000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(1220, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000010"));
    REQUIRE(eS.substr(1252, 32) ==
            Hex::toBytes("54686973206973206120737472696e67000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(1284, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000007"));
    REQUIRE(eS.substr(1316, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "000000000e0"));
    REQUIRE(eS.substr(1348, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000120"));
    REQUIRE(eS.substr(1380, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000160"));
    REQUIRE(eS.substr(1412, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "000000001a0"));
    REQUIRE(eS.substr(1444, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "000000001e0"));
    REQUIRE(eS.substr(1476, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000220"));
    REQUIRE(eS.substr(1508, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000260"));
    REQUIRE(eS.substr(1540, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000003"));
    REQUIRE(eS.substr(1572, 32) ==
            Hex::toBytes("59657300000000000000000000000000000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(1604, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000004"));
    REQUIRE(eS.substr(1636, 32) ==
            Hex::toBytes("54686973000000000000000000000000000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(1668, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000002"));
    REQUIRE(eS.substr(1700, 32) ==
            Hex::toBytes("49730000000000000000000000000000000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(1732, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000001"));
    REQUIRE(eS.substr(1764, 32) ==
            Hex::toBytes("41000000000000000000000000000000000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(1796, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000006"));
    REQUIRE(eS.substr(1828, 32) ==
            Hex::toBytes("537472696e6700000000000000000000000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(1860, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "00000000005"));
    REQUIRE(eS.substr(1892, 32) ==
            Hex::toBytes("41727261790000000000000000000000000000000000000000000"
                         "00000000000"));
    REQUIRE(eS.substr(1924, 32) ==
            Hex::toBytes("00000000000000000000000000000000000000000000000000000"
                         "0000000000e"));
    REQUIRE(eS.substr(1956, 32) ==
            Hex::toBytes("486f7720737475706964206c6f6c0000000000000000000000000"
                         "00000000000"));
  }

  SECTION("Decode Uint256 (Array)") {
    std::string ABI = Hex::toBytes(
        "0x00000000000000000000000000000000000000000000000000000000000000200000"
        "0000000000000000000000000000000000000000000000000000000000030000000000"
        "000000000000000000000000000000000000002017594d841303970000000000000000"
        "000000000000000000000000000000000000027cae776d750000000000000000000000"
        "0000000000000000000000000000016201a9fce5dd");
    std::vector<ABI::Types> types = {ABI::Types::uint256Arr};

    ABI::Decoder d(types, ABI);
    std::vector<uint256_t> dV = d.getData<std::vector<uint256_t>>(0);

    REQUIRE(dV[0] == uint256_t(2312415123141231511));
    REQUIRE(dV[1] == uint256_t(2734526262645));
    REQUIRE(dV[2] == uint256_t(389234263123421));
  }

  SECTION("Decode Address (Array)") {
    std::string ABI = Hex::toBytes(
        "0x00000000000000000000000000000000000000000000000000000000000000200000"
        "0000000000000000000000000000000000000000000000000000000000030000000000"
        "000000000000005b38da6a701c568545dcfcb03fcb875f56beddc40000000000000000"
        "00000000ab8483f64d9c6d1ecf9b849ae677dd3315835cb20000000000000000000000"
        "004b20993bc481177ec7e8f571cecae8a9e22c02db");
    std::vector<ABI::Types> types = {ABI::Types::addressArr};

    ABI::Decoder d(types, ABI);
    std::vector<Address> dV = d.getData<std::vector<Address>>(0);

    REQUIRE(dV[0] ==
            Address(Hex::toBytes("0x5B38Da6a701c568545dCfcB03FcB875f56beddC4"),
                    true));
    REQUIRE(dV[1] ==
            Address(Hex::toBytes("0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2"),
                    true));
    REQUIRE(dV[2] ==
            Address(Hex::toBytes("0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db"),
                    true));
  }

  SECTION("Decode Bool (Array)") {
    std::string ABI = Hex::toBytes(
        "0x00000000000000000000000000000000000000000000000000000000000000200000"
        "0000000000000000000000000000000000000000000000000000000000030000000000"
        "0000000000000000000000000000000000000000000000000000010000000000000000"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "000000000000000000000000000000000000000001");
    std::vector<ABI::Types> types = {ABI::Types::booleanArr};

    ABI::Decoder d(types, ABI);
    std::vector<bool> dV = d.getData<std::vector<bool>>(0);

    REQUIRE(dV[0] == true);
    REQUIRE(dV[1] == false);
    REQUIRE(dV[2] == true);
  }

  SECTION("Decode Bytes (Single)") {
    std::string ABI = Hex::toBytes(
        "0x00000000000000000000000000000000000000000000000000000000000000200000"
        "0000000000000000000000000000000000000000000000000000000000040adf1f1a00"
        "000000000000000000000000000000000000000000000000000000");
    std::vector<ABI::Types> types = {ABI::Types::bytes};

    ABI::Decoder d(types, ABI);
    std::string bytes = d.getData<std::string>(0);

    REQUIRE(bytes == Hex::toBytes("0x0adf1f1a"));
  }

  SECTION("Decode Bytes (Array)") {
    std::string ABI = Hex::toBytes(
        "0x00000000000000000000000000000000000000000000000000000000000000200000"
        "0000000000000000000000000000000000000000000000000000000000040000000000"
        "0000000000000000000000000000000000000000000000000000800000000000000000"
        "0000000000000000000000000000000000000000000000c00000000000000000000000"
        "0000000000000000000000000000000000000001000000000000000000000000000000"
        "0000000000000000000000000000000001400000000000000000000000000000000000"
        "0000000000000000000000000000040adf1f1a00000000000000000000000000000000"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "000000000000000004fffadcba00000000000000000000000000000000000000000000"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "0000060113ffedc2310000000000000000000000000000000000000000000000000000"
        "0000000000000000000000000000000000000000000000000000000000000002aaaa00"
        "0000000000000000000000000000000000000000000000000000000000");
    std::vector<ABI::Types> types = {ABI::Types::bytesArr};

    ABI::Decoder d(types, ABI);
    std::vector<std::string> dV = d.getData<std::vector<std::string>>(0);

    REQUIRE(dV[0] == Hex::toBytes("0x0adf1f1a"));
    REQUIRE(dV[1] == Hex::toBytes("0xfffadcba"));
    REQUIRE(dV[2] == Hex::toBytes("0x0113ffedc231"));
    REQUIRE(dV[3] == Hex::toBytes("0xaaaa"));
  }

  SECTION("Decode String (Single)") {
    std::string ABI = Hex::toBytes(
        "0x00000000000000000000000000000000000000000000000000000000000000200000"
        "00000000000000000000000000000000000000000000000000000000000e5468697320"
        "697320612074657374000000000000000000000000000000000000");
    std::vector<ABI::Types> types = {ABI::Types::string};

    ABI::Decoder d(types, ABI);
    std::string str = d.getData<std::string>(0);

    REQUIRE(str == "This is a test");
  }

  SECTION("Decode String (Array)") {
    std::string ABI = Hex::toBytes(
        "0x00000000000000000000000000000000000000000000000000000000000000200000"
        "0000000000000000000000000000000000000000000000000000000000040000000000"
        "0000000000000000000000000000000000000000000000000000800000000000000000"
        "0000000000000000000000000000000000000000000000c00000000000000000000000"
        "0000000000000000000000000000000000000001000000000000000000000000000000"
        "0000000000000000000000000000000001400000000000000000000000000000000000"
        "0000000000000000000000000000165468697320697320746865206669727374207465"
        "7374000000000000000000000000000000000000000000000000000000000000000000"
        "0000000000000000175468697320697320746865207365636f6e642074657374000000"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "0000165468697320697320746865207468697264207465737400000000000000000000"
        "0000000000000000000000000000000000000000000000000000000000000016546869"
        "732069732074686520666f727468207465737400000000000000000000");
    std::vector<ABI::Types> types = {ABI::Types::stringArr};

    ABI::Decoder d(types, ABI);
    std::vector<std::string> dV = d.getData<std::vector<std::string>>(0);

    REQUIRE(dV[0] == "This is the first test");
    REQUIRE(dV[1] == "This is the second test");
    REQUIRE(dV[2] == "This is the third test");
    REQUIRE(dV[3] == "This is the forth test"); // Someone fix this typo for the
                                                // love of the cosmos
  }

  SECTION("Decode Bytes (Array) + String (Array)") {
    std::string ABI = Hex::toBytes(
        "0x00000000000000000000000000000000000000000000000000000000000000400000"
        "0000000000000000000000000000000000000000000000000000000001e00000000000"
        "0000000000000000000000000000000000000000000000000000040000000000000000"
        "0000000000000000000000000000000000000000000000800000000000000000000000"
        "0000000000000000000000000000000000000000c00000000000000000000000000000"
        "0000000000000000000000000000000001000000000000000000000000000000000000"
        "0000000000000000000000000001400000000000000000000000000000000000000000"
        "0000000000000000000000165468697320697320746865206669727374207465737400"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "0000000000175468697320697320746865207365636f6e642074657374000000000000"
        "0000000000000000000000000000000000000000000000000000000000000000000016"
        "5468697320697320746865207468697264207465737400000000000000000000000000"
        "0000000000000000000000000000000000000000000000000000000016546869732069"
        "732074686520666f727468207465737400000000000000000000000000000000000000"
        "0000000000000000000000000000000000000000000004000000000000000000000000"
        "0000000000000000000000000000000000000080000000000000000000000000000000"
        "00000000000000000000000000000000c0000000000000000000000000000000000000"
        "0000000000000000000000000100000000000000000000000000000000000000000000"
        "0000000000000000000140000000000000000000000000000000000000000000000000"
        "00000000000000040adf1f1a0000000000000000000000000000000000000000000000"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "0004fffadcba0000000000000000000000000000000000000000000000000000000000"
        "000000000000000000000000000000000000000000000000000000000000060113ffed"
        "c231000000000000000000000000000000000000000000000000000000000000000000"
        "00000000000000000000000000000000000000000000000002aaaa0000000000000000"
        "00000000000000000000000000000000000000000000");
    std::vector<ABI::Types> types = {ABI::Types::stringArr,
                                     ABI::Types::bytesArr};

    ABI::Decoder d(types, ABI);
    std::vector<std::string> stringArr = d.getData<std::vector<std::string>>(0);
    std::vector<std::string> bytesArr = d.getData<std::vector<std::string>>(1);

    REQUIRE(stringArr[0] == "This is the first test");
    REQUIRE(stringArr[1] == "This is the second test");
    REQUIRE(stringArr[2] == "This is the third test");
    REQUIRE(stringArr[3] ==
            "This is the forth test"); // Someone fix this typo for the love of
                                       // the cosmos
    REQUIRE(bytesArr[0] == Hex::toBytes("0x0adf1f1a"));
    REQUIRE(bytesArr[1] == Hex::toBytes("0xfffadcba"));
    REQUIRE(bytesArr[2] == Hex::toBytes("0x0113ffedc231"));
    REQUIRE(bytesArr[3] == Hex::toBytes("0xaaaa"));
  }

  SECTION("JSONEncoder") {
    const std::string addToAddressListExpected = Hex::toBytes(
        "0x5fd673e8000000000000000000000000000000000000000000000000000000000000"
        "0020000000000000000000000000000000000000000000000000000000000000000200"
        "00000000000000000000002e913a79206280b3882860b3ef4df8204a62c8b100000000"
        "00000000000000002e913a79206280b3882860b3ef4df8204a62c8b1");
    const std::string addToStringListExpected = Hex::toBytes(
        "0xece49551000000000000000000000000000000000000000000000000000000000000"
        "0020000000000000000000000000000000000000000000000000000000000000000200"
        "0000000000000000000000000000000000000000000000000000000000004000000000"
        "000000000000000000000000000000000000000000000000000000c000000000000000"
        "0000000000000000000000000000000000000000000000005261616161616161616161"
        "6161616161616161616161616161616161616161616161616161616161616161616161"
        "6161616161616161616161616161616161616161616161616161616161616161616161"
        "6161000000000000000000000000000000000000000000000000000000000000000000"
        "0000000000000000000000004f62626262626262626262626262626262626262626262"
        "6262626262626262626262626262626262626262626262626262626262626262626262"
        "6262626262626262626262626262626262626262626200000000000000000000000000"
        "00000000");
    const std::string addToStringListFourExpected = Hex::toBytes(
        "0xece49551000000000000000000000000000000000000000000000000000000000000"
        "0020000000000000000000000000000000000000000000000000000000000000000400"
        "0000000000000000000000000000000000000000000000000000000000008000000000"
        "000000000000000000000000000000000000000000000000000000e000000000000000"
        "0000000000000000000000000000000000000000000000016000000000000000000000"
        "000000000000000000000000000000000000000001c000000000000000000000000000"
        "0000000000000000000000000000000000002461616161616161616161616161616161"
        "6161616161616161616161616161616161616161000000000000000000000000000000"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "0000000000000000005862626262626262626262626262626262626262626262626262"
        "6262626262626262626262626262626262626262626262626262626262626262626262"
        "6262626262626262626262626262626262626262626262626262626200000000000000"
        "0000000000000000000000000000000000000000000000000000000000000000286363"
        "6363636363636363636363636363636363636363636363636363636363636363636363"
        "6363630000000000000000000000000000000000000000000000000000000000000000"
        "0000000000000000000000000000000000000000000000046464646400000000000000"
        "000000000000000000000000000000000000000000");
    const std::string addToBytesListExpected = Hex::toBytes(
        "0x8ab94fd6000000000000000000000000000000000000000000000000000000000000"
        "0020000000000000000000000000000000000000000000000000000000000000000200"
        "0000000000000000000000000000000000000000000000000000000000004000000000"
        "0000000000000000000000000000000000000000000000000000008000000000000000"
        "00000000000000000000000000000000000000000000000002aaaa0000000000000000"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "00000000000000000000000000000000000002bbbb0000000000000000000000000000"
        "00000000000000000000000000000000");
    const std::string addToBytesListFourExpected = Hex::toBytes(
        "0x8ab94fd6000000000000000000000000000000000000000000000000000000000000"
        "0020000000000000000000000000000000000000000000000000000000000000000400"
        "0000000000000000000000000000000000000000000000000000000000008000000000"
        "000000000000000000000000000000000000000000000000000000c000000000000000"
        "0000000000000000000000000000000000000000000000010000000000000000000000"
        "0000000000000000000000000000000000000000014000000000000000000000000000"
        "000000000000000000000000000000000000090aaaaaaaaaaaaaaaaa00000000000000"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "0000000000000000000000001fbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
        "bbbbbbbbbbbbbbbbbb0000000000000000000000000000000000000000000000000000"
        "000000000000020ccc0000000000000000000000000000000000000000000000000000"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "120ddddddddddddddddddddddddddddddddddd0000000000000000000000000000");
    const std::string testMultipleByteArrayExpected = Hex::toBytes(
        "0x70afa559000000000000000000000000000000000000000000000000000000000000"
        "0040000000000000000000000000000000000000000000000000000000000000012000"
        "0000000000000000000000000000000000000000000000000000000000000200000000"
        "0000000000000000000000000000000000000000000000000000004000000000000000"
        "0000000000000000000000000000000000000000000000008000000000000000000000"
        "00000000000000000000000000000000000000000002aaaa0000000000000000000000"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "00000000000000000000000000000002bbbb0000000000000000000000000000000000"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "0000000000000000000200000000000000000000000000000000000000000000000000"
        "0000000000004000000000000000000000000000000000000000000000000000000000"
        "0000008000000000000000000000000000000000000000000000000000000000000000"
        "02cccc0000000000000000000000000000000000000000000000000000000000000000"
        "000000000000000000000000000000000000000000000000000000000002dddd000000"
        "000000000000000000000000000000000000000000000000000000");
    const std::string addMultipleToByteListExpected = Hex::toBytes(
        "0xf953151e000000000000000000000000000000000000000000000000000000000000"
        "004000000000000000000000000000000000000000000000000000000000000000c000"
        "00000000000000000000000000000000000000000000000000000000000046aaaaaaaa"
        "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
        "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa00000000"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "00000000000000000000000000000000000002bbbb0000000000000000000000000000"
        "00000000000000000000000000000000");
    const std::string addMultipleToStringListExpected = Hex::toBytes(
        "0x4aee7a8d000000000000000000000000000000000000000000000000000000000000"
        "0040000000000000000000000000000000000000000000000000000000000000008000"
        "0000000000000000000000000000000000000000000000000000000000000361616100"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "0000000000000000000000000000000000000000000000000362626200000000000000"
        "00000000000000000000000000000000000000000000");
    const std::string testAlmostAllExpected = Hex::toBytes(
        "0x1608f4b100000000000000000000000000000000000000000000000000007614cf69"
        "b633000000000000000000000000c4ea73d428ab6589c36905d0f0b01f3051740ff800"
        "0000000000000000000000000000000000000000000000000000000000000100000000"
        "0000000000000000000000000000000000000000000000000000010000000000000000"
        "0000000000000000000000000000000000000000000000014000000000000000000000"
        "000000000000000000000000000000000000000002e000000000000000000000000000"
        "0000000000000000000000000000000000046000000000000000000000000000000000"
        "000000000000000000000000000004e000000000000000000000000000000000000000"
        "00000000000000000000000002aaaa0000000000000000000000000000000000000000"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "0000000000016d4c6f72656d20697073756d20646f6c6f722073697420616d65742c20"
        "636f6e73656374657475722061646970697363696e6720656c69742e2050656c6c656e"
        "746573717565206567657420706f72747469746f7220746f72746f722c206574207469"
        "6e636964756e74206e6962682e2041656e65616e2065726174207175616d2c206d6178"
        "696d757320696420677261766964612073697420616d65742c2072686f6e6375732073"
        "6564206e756c6c612e20437572616269747572206d6178696d75732074656c6c757320"
        "6469616d2c2076656c2076756c7075746174652073617069656e206d6178696d757320"
        "76697461652e204475697320636f6e73656374657475722c2066656c69732061742065"
        "666669636974757220636f6e73656374657475722c20746f72746f72206e69736c2062"
        "6962656e64756d206d61757269732c20656765742076656e656e617469732061756775"
        "65206a7573746f206574206f72636953696d706c652000000000000000000000000000"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "0000030000000000000000000000000000000000000000000000000000000000000060"
        "00000000000000000000000000000000000000000000000000000000000000a0000000"
        "0000000000000000000000000000000000000000000000000000000120000000000000"
        "0000000000000000000000000000000000000000000000000005616161616100000000"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "0000000000000000000000000000000000000054626262626262626262626262626262"
        "6262626262626262626262626262626262626262626262626262626262626262626262"
        "6262626262626262626262626262626262626262626262626262626262626262626200"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "0000000000000003636363000000000000000000000000000000000000000000000000"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "0003000000000000000000000000c4ea73d428ab6589c36905d0f0b01f3051740ff800"
        "0000000000000000000000c4ea73d428ab6589c36905d0f0b01f3051740ff800000000"
        "0000000000000000c4ea73d428ab6589c36905d0f0b01f3051740ff800000000000000"
        "0000000000000000000000000000000000000000000000000300000000000000000000"
        "0000000000000000000000000000000000000000006000000000000000000000000000"
        "000000000000000000000000000000000000a000000000000000000000000000000000"
        "000000000000000000000000000000e000000000000000000000000000000000000000"
        "000000000000000000000000020aaa0000000000000000000000000000000000000000"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "000000000000020bbb0000000000000000000000000000000000000000000000000000"
        "0000000000000000000000000000000000000000000000000000000000000000000000"
        "21aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa00"
        "000000000000000000000000000000000000000000000000000000000000");

    boost::filesystem::path sourceFilePath(__FILE__);
    // We are three levels deep in the folder structure
    boost::filesystem::path rootProjectFolder =
        sourceFilePath.parent_path().parent_path().parent_path();
    boost::filesystem::path contractPath =
        rootProjectFolder / "tests" / "ArrayTest.json";

    std::ifstream contractFile(contractPath.string());
    json contractJson = json::parse(contractFile);

    ABI::JSONEncoder contract(contractJson);

    std::string addToAddressList = Hex::toBytes(contract(
        "addToAddressListArr",
        json::array({json::array(
            {Hex::toBytes("0x2E913a79206280B3882860B3eF4dF8204a62C8B1"),
             Hex::toBytes("0x2E913a79206280B3882860B3eF4dF8204a62C8B1")})})));

    std::string addToStringList = Hex::toBytes(contract(
        "addToStringListArr",
        json::array({json::array({"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                                  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
                                  "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
                                  "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"})})));

    std::string addToStringListFour = Hex::toBytes(
        contract("addToStringListArr",
                 json::array({json::array(
                     {"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
                      "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
                      "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
                      "cccccccccccccccccccccccccccccccccccccccc", "dddd"})})));

    std::string addToBytesList = Hex::toBytes(contract(
        "addToByteListArr", json::array({json::array({"0xaaaa", "0xbbbb"})})));

    std::string addToBytesListFour = Hex::toBytes(contract(
        "addToByteListArr",
        json::array({json::array(
            {"0xaaaaaaaaaaaaaaaaa",
             "0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
             "0xccc", "0xddddddddddddddddddddddddddddddddddd"})})));

    std::string testMultipleByteArray = Hex::toBytes(
        contract("testMultipleByteArray",
                 json::array({json::array({"0xaaaa", "0xbbbb"}),
                              json::array({"0xcccc", "0xdddd"})})));

    std::string addMultipleToByteList = Hex::toBytes(
        contract("addMultipleToByteList",
                 json::array({"0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
                              "0xbbbb"})));

    std::string addMultipleToStringList = Hex::toBytes(
        contract("addMultipleToStringList", json::array({"aaa", "bbb"})));

    // This should do it lmao.
    // testAlmostAll(uint256 item1, address item2, bool item3, bytes item4,
    // string item5, string[] item6, address[] item7, bytes[] item8)
    std::string testAlmostAll = Hex::toBytes(contract(
        "testAlmostAll",
        json::array(
            {"129831751235123",
             Hex::toBytes("0xc4ea73d428ab6589c36905d0f0b01f3051740ff8"), "1",
             "0xaaaa",
             "Lorem ipsum dolor sit amet, consectetur adipiscing elit. "
             "Pellentesque eget porttitor tortor, et tincidunt nibh. Aenean "
             "erat quam, maximus id gravida sit amet, rhoncus sed nulla. "
             "Curabitur maximus tellus diam, vel vulputate sapien maximus "
             "vitae. Duis consectetur, felis at efficitur consectetur, tortor "
             "nisl bibendum mauris, eget venenatis augue justo et orciSimple ",
             json::array({"aaaaa",
                          "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
                          "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
                          "ccc"}),
             json::array(
                 {Hex::toBytes("0xc4ea73d428ab6589c36905d0f0b01f3051740ff8"),
                  Hex::toBytes("0xc4ea73d428ab6589c36905d0f0b01f3051740ff8"),
                  Hex::toBytes("0xc4ea73d428ab6589c36905d0f0b01f3051740ff8")}),
             json::array({"0xaaa", "0xbbb",
                          "0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                          "aaaaaaaaaaaaaaaa"})})));

    REQUIRE(addToAddressList == addToAddressListExpected);
    REQUIRE(addToStringList == addToStringListExpected);
    REQUIRE(addToStringListFour == addToStringListFourExpected);
    REQUIRE(addToBytesList == addToBytesListExpected);
    REQUIRE(addToBytesListFour == addToBytesListFourExpected);
    REQUIRE(testMultipleByteArray == testMultipleByteArrayExpected);
    REQUIRE(addMultipleToByteList == addMultipleToByteListExpected);
    REQUIRE(addMultipleToStringList == addMultipleToStringListExpected);
    REQUIRE(testAlmostAll == testAlmostAllExpected);
  }
}
} // namespace TABI
