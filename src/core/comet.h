/*
Copyright (c) [2023-2024] [AppLayer Developers]

This software is distributed under the MIT License.
See the LICENSE.txt file in the project root for more information.
*/

#ifndef COMET_H
#define COMET_H

#include "../utils/options.h"
#include "../utils/logger.h"

#include <unordered_set>
#include <vector>

/// Comet driver states
enum class CometState {
  STOPPED          =  0, ///< Comet is in stopped state (no worker thread started)
  STARTED          =  1, ///< Comet worker thread just started
  CONFIGURING      =  2, ///< Starting to set up comet config
  CONFIGURED       =  3, ///< Finished setting up comet config
  INSPECTING_COMET =  4, ///< Starting cometbft inspect
  INSPECTED_COMET  =  5, ///< Stopped cometbft inspect; all tests passed
  STARTING_ABCI    =  6, ///< Starting ABCI server on our end
  STARTED_ABCI     =  7, ///< Started ABCI server
  STARTING_COMET   =  8, ///< Running cometbft start
  STARTED_COMET    =  9, ///< cometbft start successful
  TESTING_COMET    = 10, ///< Starting to test cometbft connection
  TESTED_COMET     = 11, ///< Finished cometbft connection test; all tests passed
  RUNNING          = 12, ///< Comet is running
  TERMINATED       = 13, ///< Comet worker somehow ran out of work (this is always an error)
  FINISHED         = 14, ///< Comet worker loop quit (stopped for some explicit reason)
  NONE             = 15  ///< Dummy state to disable state stepping
};

/**
 * The result of executing a transaction.
 */
struct CometExecTxResult {
  int64_t     gas_wanted = 0; ///< Gas limit set by the transaction.
  int64_t     gas_used = 0; ///< Gas used by the execution of this transaction as part of the actual block it was included in.
  Bytes       data; ///< Return data generated by the code invoked by the transaction, if any.
  uint32_t    code = 0; ///< 0 for success, any other value is a failure.
};

/**
 * The Comet class notifies its user of events through the CometListener interface.
 * Users of the Comet class must implement a CometListener class and pass a pointer
 * to a CometListener object to Comet so that they can receive Comet events.
 *
 * NOTE: These callbacks may or may not be invoked in parallel. You should not assume
 * that these are invoked in any particular order or that they aren't concurrent.
 *
 * NOTE: the return value of all callbacks is set to void because they are reserved
 * for e.g. some status or error handling use; all user return values are outparams.
 */
class CometListener {
  public:
    /**
     * Called upon starting a fresh blockchain (i.e. empty block storage) from a given genesis config.
     * @param genesisTime Genesis block time in seconds since epoch.
     * @param chainId The chain ID.
     * @param initialAppState Serialized initial application state.
     * @param initialHeight The application's initial block height.
     * @param appHash Outparam to be set to the application's initial app hash.
     */
    virtual void initChain(
      const uint64_t genesisTime, const std::string& chainId, const Bytes& initialAppState,
      const uint64_t initialHeight, Bytes& appHash
    ) {
      appHash.clear();
    }

    /**
     * Check if a transaction is valid.
     * @param tx The transaction to check.
     * @param gasWanted Outparam to be set to the gas_limit of this transaction (leave unmodified if unknown/irrelevant).
     * @param accept Outparam to be set to `true` if the transaction is valid, `false` if it is invalid.
     */
    virtual void checkTx(const Bytes& tx, int64_t& gasWanted, bool& accept) {
      accept = true;
    }

    /**
     * Notification of a new finalized block added to the chain.
     * @param height The block height of the new finalized block at the new head of the chain.
     * @param syncingToHeight If the blockchain is doing a replay, syncingToHeight > height, otherwise syncingToHeight == height.
     * @param txs All transactions included in the block, which need to be processed into the application state.
     * @param appHash Outparam to be set with the hash of the application state after all `txs` are processed into it.
     * @param txResults Outparam to be filled in with the result of executing each transaction in the `txs` vector (indices must match).
     */
    virtual void incomingBlock(
      const uint64_t height, const uint64_t syncingToHeight, const std::vector<Bytes>& txs, Bytes& appHash,
      std::vector<CometExecTxResult>& txResults
    ) {
      appHash.clear();
      txResults.resize(txs.size());
    }

    /**
     * Validator node that is the block proposer now needs to build a block.
     * @param txs Transactions that cometbft took from the mempool and that it wants to include in the block proposal.
     * @param delTxIds Outparam to be set with the indices in `txs`  that are to be excluded from the block proposal.
     */
    virtual void buildBlockProposal(const std::vector<Bytes>& txs, std::unordered_set<size_t>& delTxIds) {
      // By default, just copy the recommended txs from the mempool into the proposal.
      // This requires all block size and limit related params to be set in such a way that the
      // total byte size of txs in the request don't exceed the total byte size allowed for a block.
    }

    /**
     * Validator node receives a block proposal from the block proposer, and must check if the proposal is a valid one.
     * @param height The block height of the new block being proposed.
     * @param txs All transactions included in the block, which need to be verified.
     * @param accept Outparam to be set to `true` if the proposed block is valid, `false` otherwise.
     */
    virtual void validateBlockProposal(const uint64_t height, const std::vector<Bytes>& txs, bool& accept) {
      accept = true;
    }

    /**
     * Callback from cometbft to check what is the current state of the application.
     * @param height Outparam to be set with the height of the last block processed to generate the current application state.
     * @param appHash Outparam to be set with the hash of the current application state (i.e. the state at `height`).
     * @param appSemVer Outparam to be set with the application's semantic version string e.g. "1.0.0" (logged in every block).
     * @param appVersion Outparam with the uint version of the application (0 if never modified from its original/genesis version).
     */
    virtual void getCurrentState(uint64_t& height, Bytes& appHash, std::string& appSemVer, uint64_t& appVersion) {
      height = 0;
      appHash.clear();
      appSemVer = "1.0.0";
      appVersion = 0;
    }

    /**
     * Callback from cometbft to check if it can prune some old blocks from its block store.
     * @param height Outparam to be set with the height of the earliest block that must be kept (all earlier blocks are deleted).
     */
    virtual void getBlockRetainHeight(uint64_t& height) {
      height = 0;
    }

    /**
     * Notification of what the cometbft block store height is. If the application is ahead, it can bring itself to a height
     * that is equal or lower than this, or it can prepare to report a correct app_hash and validator set changes after
     * each incomingBlock() callback that it will get with a height that is lower or equal than its current heigh without
     * computing state (i.e. feeding it to Comet via stored historical data that it has computed in the past or that it has
     * obtained off-band). The application is free to block this callback for any amount of time.
     * @param height The current head height in the cometbft block store (the height that the cometbft node/db is at).
     */
    virtual void currentCometBFTHeight(const uint64_t height) {
    }

    /**
     * Notification of completing a Comet::sendTransaction() request.
     * @param tx Transaction that was previously sent via `Comet::sendTransaction()`.
     * @param txId The value that was returned by `Comet::sendTransaction()` (the request ticket/id).
     * @param success `true` if sendTransaction() succeeded, `false` if the transaction failed to send.
     * @param txHash Transaction hash as CometBFT sees it (SHA256: https://docs.cometbft.com/main/spec/core/encoding).
     * @param response The full JSON-RPC response returned by cometbft.
     */
    virtual void sendTransactionResult(
      const Bytes& tx, const uint64_t txId, const bool success, const std::string& txHash, const std::string& response
    ) {
    }

    /**
     * Notification of completing a Comet::checkTransaction() request.
     * @param txHash The transaction hash that was checked.
     * @param success Whether the transaction check (/tx RPC call) was successful or not.
     * @param response The full JSON-RPC response returned by cometbft.
     */
    virtual void checkTransactionResult(const std::string& txHash, const bool success, const std::string& response) {
    }
};

class CometImpl;

/**
 * The Comet class is instantiated by the BDK node to serve as an interface to CometBFT.
 * Most of its implementation details are private and contained in CometImpl, which is
 * declared and defined in comet.cpp, in order to keep this header short and simple.
 */
class Comet : public Log::LogicalLocationProvider {
  private:
    const std::string instanceIdStr_; ///< Identifier for logging
    std::unique_ptr<CometImpl> impl_; ///< Private implementation details of a Comet instance.

  public:
    /**
     * Constructor.
     * @param listener Pointer to an object of a class that implements the CometListener interface
     *                 and that will receive event callbacks from this Comet instance.
     * @param instanceIdStr Instance ID string to use for logging.
     * @param options Reference to the Options singleton.
     * @param stepMode If true, no empty blocks are ever produced (for unit testing only).
     */
    explicit Comet(CometListener* listener, std::string instanceIdStr, const Options& options, bool stepMode = false);

    /**
     * Destructor; ensures all subordinate jobs are stopped.
     */
    virtual ~Comet();

    /**
     * Get the global status of the Comet worker.
     * @return `true` if it is in a working state, `false` if it is in a failed/terminated state.
     */
    bool getStatus();

    /**
     * Get the last error message from the Comet worker (not synchronized; call only after
     * getStatus() returns false).
     * @return Error message or empty string if no error.
     */
    const std::string& getErrorStr();

    /**
     * Get the current state of the Comet worker (or last known state before failure/termination;
     * must also call getStatus()).
     * @return The current state.
     */
    CometState getState();

    /**
     * Set the pause state (this is not set by start(), but is set to NONE by stop()).
     * The pause state is a state that the comet worker thread stops at when it is reached, which
     * is useful for writing unit tests for the Comet class.
     * @param pauseState State to pause at, or CometState::NONE to disable.
     */
    void setPauseState(const CometState pauseState = CometState::NONE);

    /**
     * Get the pause state.
     * @return The current pause state.
     */
    CometState getPauseState();

    /**
     * Busy wait for the pause state, a given timeout in milliseconds, or an error status.
     * @param timeoutMillis Timeout in milliseconds, or zero to wait forever.
     * @return If error status set, the error string, or "TIMEOUT" in case of timeout, or an empty string if OK.
     */
    std::string waitPauseState(uint64_t timeoutMillis);

    /**
     * Get the cometbft node ID; this is only guaranteed to be set from the INSPECTED_COMET state and ownards.
     * @return The cometbft node id string, or an empty string if unknown (not yet computed) at this point.
     */
    std::string getNodeID();

    /**
     * Enqueues a transaction to be sent to the cometbft node; will retry until the localhost cometbft
     * instance is running and it acknowledges the receipt of the transaction bytes, meaning it should
     * be in its mempool from now on (if it passes CheckTx, etc).
     * @param tx The raw bytes of the transaction object.
     * @return Ticket number for the transaction send request (unique for one Comet object instantiation).
     */
    uint64_t sendTransaction(const Bytes& tx);

    /**
     * Enqueue a request to check the status of a transaction given its hash (CometBFT hash, i.e. SHA256).
     * @param txHash A hex string (no "0x") with the SHA256 hex of the transaction to look for.
     */
    void checkTransaction(const std::string& txHash);

    /**
     * Start (or restart) the consensus engine loop.
     */
    void start();

    /**
     * Stop the consensus engine loop; sets the pause state to CometState::NONE.
     */
    void stop();

    /**
     * Return an instance (object) identifier for all LOGxxx() messages emitted this class.
     */
    std::string getLogicalLocation() const override { return instanceIdStr_; }
};

/// Consensus parameter: PBTS Clock drift.
/// This must be at least 500ms due to leap seconds.
/// Give 1 whole second for clock drift, which is plenty.
#define COMETBFT_PBTS_SYNCHRONY_PARAM_PRECISION_SECONDS 1

/// Consensus parameter: PBTS Maximum network delay for proposal (header) propagation.
/// This cannot be too small or else performance is affected.
/// If it is too large, malicious validators can timestamp blocks up to this amount in the future,
/// which slows downs the network (need to wait for real time to pass until it catches up with the
/// timestamp of the previous block) but that's externally observable and punishable by governance.
/// Five seconds is plenty for the propagation of a timestamp worldwide.
#define COMETBFT_PBTS_SYNCHRONY_PARAM_MESSAGE_DELAY_SECONDS 5

// Use/keep the genesis file parameters instead.
//
// Consensus parameter: Maximum block size in bytes.
// The hard-coded maximum block size in cometbft is 100MB.
//#define COMETBFT_BLOCK_PARAM_MAX_BYTES 104857600
//
// Consensus parameter: Maximum gas in a block. -1 means we give no gas limit for cometbft to
// work with and so we have to deal with gas limits ourselves when generating valid block proposals.
//#define COMETBFT_BLOCK_PARAM_MAX_GAS -1

#endif