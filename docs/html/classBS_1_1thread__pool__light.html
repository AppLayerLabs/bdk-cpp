<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OrbiterSDK: BS::thread_pool_light Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OrbiterSDK<span id="projectnumber">&#160;1</span>
   </div>
   <div id="projectbrief">Subnet from Sparq Labs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>BS</b></li><li class="navelem"><a class="el" href="classBS_1_1thread__pool__light.html">thread_pool_light</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classBS_1_1thread__pool__light-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">BS::thread_pool_light Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A fast, lightweight, and easy-to-use C++17 thread pool class.  
 <a href="classBS_1_1thread__pool__light.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BS__thread__pool__light_8hpp_source.html">BS_thread_pool_light.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4c84e2fd4cda5402ba5d0351889fa995"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool__light.html#a4c84e2fd4cda5402ba5d0351889fa995">thread_pool_light</a> (const <a class="el" href="BS__thread__pool__light_8hpp.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> thread_count_=0)</td></tr>
<tr class="memdesc:a4c84e2fd4cda5402ba5d0351889fa995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new thread pool.  <a href="classBS_1_1thread__pool__light.html#a4c84e2fd4cda5402ba5d0351889fa995">More...</a><br /></td></tr>
<tr class="separator:a4c84e2fd4cda5402ba5d0351889fa995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d68b2122d42ee7eddb8cdd42cf0399"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool__light.html#a48d68b2122d42ee7eddb8cdd42cf0399">~thread_pool_light</a> ()</td></tr>
<tr class="memdesc:a48d68b2122d42ee7eddb8cdd42cf0399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the thread pool.  <a href="classBS_1_1thread__pool__light.html#a48d68b2122d42ee7eddb8cdd42cf0399">More...</a><br /></td></tr>
<tr class="separator:a48d68b2122d42ee7eddb8cdd42cf0399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e05f53971b73be08f15399a981c132"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BS__thread__pool__light_8hpp.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool__light.html#af3e05f53971b73be08f15399a981c132">get_thread_count</a> () const</td></tr>
<tr class="memdesc:af3e05f53971b73be08f15399a981c132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of threads in the pool.  <a href="classBS_1_1thread__pool__light.html#af3e05f53971b73be08f15399a981c132">More...</a><br /></td></tr>
<tr class="separator:af3e05f53971b73be08f15399a981c132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6c5881d6a3bf8c4a70644d2d21f0c7"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T1 , typename T2 , typename T  = std::common_type_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:a0c6c5881d6a3bf8c4a70644d2d21f0c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool__light.html#a0c6c5881d6a3bf8c4a70644d2d21f0c7">push_loop</a> (T1 first_index_, T2 index_after_last_, F &amp;&amp;loop, size_t num_blocks=0)</td></tr>
<tr class="memdesc:a0c6c5881d6a3bf8c4a70644d2d21f0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue.  <a href="classBS_1_1thread__pool__light.html#a0c6c5881d6a3bf8c4a70644d2d21f0c7">More...</a><br /></td></tr>
<tr class="separator:a0c6c5881d6a3bf8c4a70644d2d21f0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97f9c860e5359372cd299cea68224b8"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:af97f9c860e5359372cd299cea68224b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool__light.html#af97f9c860e5359372cd299cea68224b8">push_loop</a> (const T index_after_last, F &amp;&amp;loop, const size_t num_blocks=0)</td></tr>
<tr class="memdesc:af97f9c860e5359372cd299cea68224b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue.  <a href="classBS_1_1thread__pool__light.html#af97f9c860e5359372cd299cea68224b8">More...</a><br /></td></tr>
<tr class="separator:af97f9c860e5359372cd299cea68224b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9809382622e8bf7421abadfd3a80397"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... A&gt; </td></tr>
<tr class="memitem:ab9809382622e8bf7421abadfd3a80397"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool__light.html#ab9809382622e8bf7421abadfd3a80397">push_task</a> (F &amp;&amp;task, A &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab9809382622e8bf7421abadfd3a80397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a function with zero or more arguments, but no return value, into the task queue.  <a href="classBS_1_1thread__pool__light.html#ab9809382622e8bf7421abadfd3a80397">More...</a><br /></td></tr>
<tr class="separator:ab9809382622e8bf7421abadfd3a80397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457475c05b05f850a9cb1b9950b73a16"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... A, typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, std::decay_t&lt;A&gt;...&gt;&gt; </td></tr>
<tr class="memitem:a457475c05b05f850a9cb1b9950b73a16"><td class="memTemplItemLeft" align="right" valign="top">std::future&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool__light.html#a457475c05b05f850a9cb1b9950b73a16">submit</a> (F &amp;&amp;task, A &amp;&amp;... args)</td></tr>
<tr class="memdesc:a457475c05b05f850a9cb1b9950b73a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a function with zero or more arguments into the task queue.  <a href="classBS_1_1thread__pool__light.html#a457475c05b05f850a9cb1b9950b73a16">More...</a><br /></td></tr>
<tr class="separator:a457475c05b05f850a9cb1b9950b73a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dccae604ae99bc930a15025d975571"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool__light.html#a20dccae604ae99bc930a15025d975571">wait_for_tasks</a> ()</td></tr>
<tr class="memdesc:a20dccae604ae99bc930a15025d975571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for tasks to be completed.  <a href="classBS_1_1thread__pool__light.html#a20dccae604ae99bc930a15025d975571">More...</a><br /></td></tr>
<tr class="separator:a20dccae604ae99bc930a15025d975571"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a2dbdb70625c512dc483099ae6807bbb3"><td class="memItemLeft" align="right" valign="top"><a id="a2dbdb70625c512dc483099ae6807bbb3" name="a2dbdb70625c512dc483099ae6807bbb3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>create_threads</b> ()</td></tr>
<tr class="memdesc:a2dbdb70625c512dc483099ae6807bbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the threads in the pool and assign a worker to each thread. <br /></td></tr>
<tr class="separator:a2dbdb70625c512dc483099ae6807bbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048cbb8a03ccc09f2a5f864b41f4444f"><td class="memItemLeft" align="right" valign="top"><a id="a048cbb8a03ccc09f2a5f864b41f4444f" name="a048cbb8a03ccc09f2a5f864b41f4444f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>destroy_threads</b> ()</td></tr>
<tr class="memdesc:a048cbb8a03ccc09f2a5f864b41f4444f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the threads in the pool. <br /></td></tr>
<tr class="separator:a048cbb8a03ccc09f2a5f864b41f4444f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bff1ea889333d2cdc8a66aaa282145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BS__thread__pool__light_8hpp.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool__light.html#a24bff1ea889333d2cdc8a66aaa282145">determine_thread_count</a> (const <a class="el" href="BS__thread__pool__light_8hpp.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> thread_count_)</td></tr>
<tr class="memdesc:a24bff1ea889333d2cdc8a66aaa282145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine how many threads the pool should have, based on the parameter passed to the constructor.  <a href="classBS_1_1thread__pool__light.html#a24bff1ea889333d2cdc8a66aaa282145">More...</a><br /></td></tr>
<tr class="separator:a24bff1ea889333d2cdc8a66aaa282145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d99d80b932ddf0ac27cc4ad3902769c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool__light.html#a3d99d80b932ddf0ac27cc4ad3902769c">worker</a> ()</td></tr>
<tr class="memdesc:a3d99d80b932ddf0ac27cc4ad3902769c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A worker function to be assigned to each thread in the pool.  <a href="classBS_1_1thread__pool__light.html#a3d99d80b932ddf0ac27cc4ad3902769c">More...</a><br /></td></tr>
<tr class="separator:a3d99d80b932ddf0ac27cc4ad3902769c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a47e458d20208f602144aac17f1a9d119"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool__light.html#a47e458d20208f602144aac17f1a9d119">running</a> = false</td></tr>
<tr class="memdesc:a47e458d20208f602144aac17f1a9d119"><td class="mdescLeft">&#160;</td><td class="mdescRight">An atomic variable indicating to the workers to keep running.  <a href="classBS_1_1thread__pool__light.html#a47e458d20208f602144aac17f1a9d119">More...</a><br /></td></tr>
<tr class="separator:a47e458d20208f602144aac17f1a9d119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5563e16e0fa97afd164d014c1043cbc9"><td class="memItemLeft" align="right" valign="top"><a id="a5563e16e0fa97afd164d014c1043cbc9" name="a5563e16e0fa97afd164d014c1043cbc9"></a>
std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><b>task_available_cv</b> = {}</td></tr>
<tr class="memdesc:a5563e16e0fa97afd164d014c1043cbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A condition variable used to notify <a class="el" href="classBS_1_1thread__pool__light.html#a3d99d80b932ddf0ac27cc4ad3902769c" title="A worker function to be assigned to each thread in the pool.">worker()</a> that a new task has become available. <br /></td></tr>
<tr class="separator:a5563e16e0fa97afd164d014c1043cbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca3a979a9bb43fb526619d196284fd7"><td class="memItemLeft" align="right" valign="top"><a id="a7ca3a979a9bb43fb526619d196284fd7" name="a7ca3a979a9bb43fb526619d196284fd7"></a>
std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><b>task_done_cv</b> = {}</td></tr>
<tr class="memdesc:a7ca3a979a9bb43fb526619d196284fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A condition variable used to notify <a class="el" href="classBS_1_1thread__pool__light.html#a20dccae604ae99bc930a15025d975571" title="Wait for tasks to be completed.">wait_for_tasks()</a> that a tasks is done. <br /></td></tr>
<tr class="separator:a7ca3a979a9bb43fb526619d196284fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa403bc5713e46082140b0e674100dd"><td class="memItemLeft" align="right" valign="top"><a id="a8aa403bc5713e46082140b0e674100dd" name="a8aa403bc5713e46082140b0e674100dd"></a>
std::queue&lt; std::function&lt; void()&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tasks</b> = {}</td></tr>
<tr class="memdesc:a8aa403bc5713e46082140b0e674100dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue of tasks to be executed by the threads. <br /></td></tr>
<tr class="separator:a8aa403bc5713e46082140b0e674100dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae883665c1994d2a3417f5647e9f40df6"><td class="memItemLeft" align="right" valign="top"><a id="ae883665c1994d2a3417f5647e9f40df6" name="ae883665c1994d2a3417f5647e9f40df6"></a>
std::atomic&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tasks_total</b> = 0</td></tr>
<tr class="memdesc:ae883665c1994d2a3417f5647e9f40df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">An atomic variable to keep track of the total number of unfinished tasks - either still in the queue, or running in a thread. <br /></td></tr>
<tr class="separator:ae883665c1994d2a3417f5647e9f40df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6b9632ee363b5d424f850c6422dbfe"><td class="memItemLeft" align="right" valign="top"><a id="a7e6b9632ee363b5d424f850c6422dbfe" name="a7e6b9632ee363b5d424f850c6422dbfe"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>tasks_mutex</b> = {}</td></tr>
<tr class="memdesc:a7e6b9632ee363b5d424f850c6422dbfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutex to synchronize access to the task queue by different threads. <br /></td></tr>
<tr class="separator:a7e6b9632ee363b5d424f850c6422dbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b75f38e0c9f705b96b7ea808b833e13"><td class="memItemLeft" align="right" valign="top"><a id="a9b75f38e0c9f705b96b7ea808b833e13" name="a9b75f38e0c9f705b96b7ea808b833e13"></a>
<a class="el" href="BS__thread__pool__light_8hpp.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>thread_count</b> = 0</td></tr>
<tr class="memdesc:a9b75f38e0c9f705b96b7ea808b833e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of threads in the pool. <br /></td></tr>
<tr class="separator:a9b75f38e0c9f705b96b7ea808b833e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60472983885ba368e722ff5c3e9496a"><td class="memItemLeft" align="right" valign="top"><a id="aa60472983885ba368e722ff5c3e9496a" name="aa60472983885ba368e722ff5c3e9496a"></a>
std::unique_ptr&lt; std::thread[]&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>threads</b> = nullptr</td></tr>
<tr class="memdesc:aa60472983885ba368e722ff5c3e9496a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smart pointer to manage the memory allocated for the threads. <br /></td></tr>
<tr class="separator:aa60472983885ba368e722ff5c3e9496a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7702b75c8b8804b90d11c5cea1fe1a0"><td class="memItemLeft" align="right" valign="top"><a id="ab7702b75c8b8804b90d11c5cea1fe1a0" name="ab7702b75c8b8804b90d11c5cea1fe1a0"></a>
std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>waiting</b> = false</td></tr>
<tr class="memdesc:ab7702b75c8b8804b90d11c5cea1fe1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">An atomic variable indicating that <a class="el" href="classBS_1_1thread__pool__light.html#a20dccae604ae99bc930a15025d975571" title="Wait for tasks to be completed.">wait_for_tasks()</a> is active and expects to be notified whenever a task is done. <br /></td></tr>
<tr class="separator:ab7702b75c8b8804b90d11c5cea1fe1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A fast, lightweight, and easy-to-use C++17 thread pool class. </p>
<p >This is a lighter version of the main thread pool class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4c84e2fd4cda5402ba5d0351889fa995" name="a4c84e2fd4cda5402ba5d0351889fa995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c84e2fd4cda5402ba5d0351889fa995">&#9670;&nbsp;</a></span>thread_pool_light()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BS::thread_pool_light::thread_pool_light </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BS__thread__pool__light_8hpp.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td>
          <td class="paramname"><em>thread_count_</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new thread pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_count_</td><td>The number of threads to use. The default value is the total number of hardware threads available, as reported by the implementation. This is usually determined by the number of cores in the CPU. If a core is hyperthreaded, it will count as two threads. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48d68b2122d42ee7eddb8cdd42cf0399" name="a48d68b2122d42ee7eddb8cdd42cf0399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d68b2122d42ee7eddb8cdd42cf0399">&#9670;&nbsp;</a></span>~thread_pool_light()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BS::thread_pool_light::~thread_pool_light </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destruct the thread pool. </p>
<p >Waits for all tasks to complete, then destroys all threads. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a24bff1ea889333d2cdc8a66aaa282145" name="a24bff1ea889333d2cdc8a66aaa282145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24bff1ea889333d2cdc8a66aaa282145">&#9670;&nbsp;</a></span>determine_thread_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BS__thread__pool__light_8hpp.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> BS::thread_pool_light::determine_thread_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="BS__thread__pool__light_8hpp.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td>
          <td class="paramname"><em>thread_count_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine how many threads the pool should have, based on the parameter passed to the constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_count_</td><td>The parameter passed to the constructor. If the parameter is a positive number, then the pool will be created with this number of threads. If the parameter is non-positive, or a parameter was not supplied (in which case it will have the default value of 0), then the pool will be created with the total number of hardware threads available, as obtained from std::thread::hardware_concurrency(). If the latter returns a non-positive number for some reason, then the pool will be created with just one thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of threads to use for constructing the pool. </dd></dl>

</div>
</div>
<a id="af3e05f53971b73be08f15399a981c132" name="af3e05f53971b73be08f15399a981c132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e05f53971b73be08f15399a981c132">&#9670;&nbsp;</a></span>get_thread_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BS__thread__pool__light_8hpp.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> BS::thread_pool_light::get_thread_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of threads in the pool. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of threads. </dd></dl>

</div>
</div>
<a id="af97f9c860e5359372cd299cea68224b8" name="af97f9c860e5359372cd299cea68224b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97f9c860e5359372cd299cea68224b8">&#9670;&nbsp;</a></span>push_loop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool_light::push_loop </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue. </p>
<p >The user must use <a class="el" href="classBS_1_1thread__pool__light.html#a20dccae604ae99bc930a15025d975571" title="Wait for tasks to be completed.">wait_for_tasks()</a> or some other method to ensure that the loop finishes executing, otherwise bad things will happen. This overload is used for the special case where the first index is 0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
    <tr><td class="paramname">T</td><td>The type of the loop indices. Should be a signed or unsigned integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from 0 to (index_after_last - 1) inclusive. In other words, it will be equivalent to "for (T i = 0; i &lt; index_after_last; ++i)". Note that if index_after_last == 0, no blocks will be submitted. </td></tr>
    <tr><td class="paramname">loop</td><td>The function to loop through. Will be called once per block. Should take exactly two arguments: the first index in the block and the index after the last index in the block. loop(start, end) should typically involve a loop of the form "for (T i = start; i &lt; end; ++i)". </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is to use the number of threads in the pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c6c5881d6a3bf8c4a70644d2d21f0c7" name="a0c6c5881d6a3bf8c4a70644d2d21f0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6c5881d6a3bf8c4a70644d2d21f0c7">&#9670;&nbsp;</a></span>push_loop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename T1 , typename T2 , typename T  = std::common_type_t&lt;T1, T2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool_light::push_loop </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>first_index_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>index_after_last_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue. </p>
<p >The user must use <a class="el" href="classBS_1_1thread__pool__light.html#a20dccae604ae99bc930a15025d975571" title="Wait for tasks to be completed.">wait_for_tasks()</a> or some other method to ensure that the loop finishes executing, otherwise bad things will happen.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
    <tr><td class="paramname">T1</td><td>The type of the first index in the loop. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">T2</td><td>The type of the index after the last index in the loop. Should be a signed or unsigned integer. If T1 is not the same as T2, a common type will be automatically inferred. </td></tr>
    <tr><td class="paramname">T</td><td>The common type of T1 and T2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the loop. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from first_index to (index_after_last - 1) inclusive. In other words, it will be equivalent to "for (T i = first_index; i &lt; index_after_last; ++i)". Note that if index_after_last == first_index, no blocks will be submitted. </td></tr>
    <tr><td class="paramname">loop</td><td>The function to loop through. Will be called once per block. Should take exactly two arguments: the first index in the block and the index after the last index in the block. loop(start, end) should typically involve a loop of the form "for (T i = start; i &lt; end; ++i)". </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is to use the number of threads in the pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9809382622e8bf7421abadfd3a80397" name="ab9809382622e8bf7421abadfd3a80397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9809382622e8bf7421abadfd3a80397">&#9670;&nbsp;</a></span>push_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool_light::push_task </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push a function with zero or more arguments, but no return value, into the task queue. </p>
<p >Does not return a future, so the user must use <a class="el" href="classBS_1_1thread__pool__light.html#a20dccae604ae99bc930a15025d975571" title="Wait for tasks to be completed.">wait_for_tasks()</a> or some other method to ensure that the task finishes executing, otherwise bad things will happen.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function. </td></tr>
    <tr><td class="paramname">A</td><td>The types of the arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The function to push. </td></tr>
    <tr><td class="paramname">args</td><td>The zero or more arguments to pass to the function. Note that if the task is a class member function, the first argument must be a pointer to the object, i.e. &amp;object (or this), followed by the actual arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a457475c05b05f850a9cb1b9950b73a16" name="a457475c05b05f850a9cb1b9950b73a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457475c05b05f850a9cb1b9950b73a16">&#9670;&nbsp;</a></span>submit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... A, typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, std::decay_t&lt;A&gt;...&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; R &gt; BS::thread_pool_light::submit </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit a function with zero or more arguments into the task queue. </p>
<p >If the function has a return value, get a future for the eventual returned value. If the function has no return value, get an std::future&lt;void&gt; which can be used to wait until the task finishes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function. </td></tr>
    <tr><td class="paramname">A</td><td>The types of the zero or more arguments to pass to the function. </td></tr>
    <tr><td class="paramname">R</td><td>The return type of the function (can be void). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The function to submit. </td></tr>
    <tr><td class="paramname">args</td><td>The zero or more arguments to pass to the function. Note that if the task is a class member function, the first argument must be a pointer to the object, i.e. &amp;object (or this), followed by the actual arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A future to be used later to wait for the function to finish executing and/or obtain its returned value if it has one. </dd></dl>

</div>
</div>
<a id="a20dccae604ae99bc930a15025d975571" name="a20dccae604ae99bc930a15025d975571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20dccae604ae99bc930a15025d975571">&#9670;&nbsp;</a></span>wait_for_tasks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool_light::wait_for_tasks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for tasks to be completed. </p>
<p >Normally, this function waits for all tasks, both those that are currently running in the threads and those that are still waiting in the queue. Note: To wait for just one specific task, use <a class="el" href="classBS_1_1thread__pool__light.html#a457475c05b05f850a9cb1b9950b73a16" title="Submit a function with zero or more arguments into the task queue.">submit()</a> instead, and call the wait() member function of the generated future. </p>

</div>
</div>
<a id="a3d99d80b932ddf0ac27cc4ad3902769c" name="a3d99d80b932ddf0ac27cc4ad3902769c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d99d80b932ddf0ac27cc4ad3902769c">&#9670;&nbsp;</a></span>worker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool_light::worker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A worker function to be assigned to each thread in the pool. </p>
<p >Waits until it is notified by <a class="el" href="classBS_1_1thread__pool__light.html#ab9809382622e8bf7421abadfd3a80397" title="Push a function with zero or more arguments, but no return value, into the task queue.">push_task()</a> that a task is available, and then retrieves the task from the queue and executes it. Once the task finishes, the worker notifies <a class="el" href="classBS_1_1thread__pool__light.html#a20dccae604ae99bc930a15025d975571" title="Wait for tasks to be completed.">wait_for_tasks()</a> in case it is waiting. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a47e458d20208f602144aac17f1a9d119" name="a47e458d20208f602144aac17f1a9d119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e458d20208f602144aac17f1a9d119">&#9670;&nbsp;</a></span>running</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt; BS::thread_pool_light::running = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An atomic variable indicating to the workers to keep running. </p>
<p >When set to false, the workers permanently stop working. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/libs/<a class="el" href="BS__thread__pool__light_8hpp_source.html">BS_thread_pool_light.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
