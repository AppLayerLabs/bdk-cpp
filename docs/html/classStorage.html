<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OrbiterSDK: Storage Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OrbiterSDK<span id="projectnumber">&#160;1</span>
   </div>
   <div id="projectbrief">Subnet from Sparq Labs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classStorage-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Storage Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Abstraction of the blockchain history.  
 <a href="classStorage.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="storage_8h_source.html">storage.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae56a62413a2c31373f4eb07eb3f28772"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#ae56a62413a2c31373f4eb07eb3f28772">Storage</a> (const std::unique_ptr&lt; <a class="el" href="classDB.html">DB</a> &gt; &amp;<a class="el" href="classStorage.html#a2dda489465964490bd7ffeb752bbe20e">db</a>, const std::unique_ptr&lt; <a class="el" href="classOptions.html">Options</a> &gt; &amp;<a class="el" href="classStorage.html#a937408cf51999eb5abaeffd6221be1a5">options</a>)</td></tr>
<tr class="memdesc:ae56a62413a2c31373f4eb07eb3f28772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classStorage.html#ae56a62413a2c31373f4eb07eb3f28772">More...</a><br /></td></tr>
<tr class="separator:ae56a62413a2c31373f4eb07eb3f28772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cf30f0a34250396f9eabee7dc5c93d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a73cf30f0a34250396f9eabee7dc5c93d">~Storage</a> ()</td></tr>
<tr class="memdesc:a73cf30f0a34250396f9eabee7dc5c93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classStorage.html#a73cf30f0a34250396f9eabee7dc5c93d">More...</a><br /></td></tr>
<tr class="separator:a73cf30f0a34250396f9eabee7dc5c93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9145924ab41d59f5ae752f47db28a990"><td class="memItemLeft" align="right" valign="top"><a id="a9145924ab41d59f5ae752f47db28a990" name="a9145924ab41d59f5ae752f47db28a990"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pushBack</b> (<a class="el" href="classBlock.html">Block</a> &amp;&amp;block)</td></tr>
<tr class="memdesc:a9145924ab41d59f5ae752f47db28a990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for <code><a class="el" href="classStorage.html#acd7ed7b8aeefe31a2b928407460c9dff" title="Add a block to the end of the chain.">pushBackInternal()</a></code>. Use this as it properly locks <code>chainLock</code>. <br /></td></tr>
<tr class="separator:a9145924ab41d59f5ae752f47db28a990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad276d54477d80dacc0daa867cc6a7e61"><td class="memItemLeft" align="right" valign="top"><a id="ad276d54477d80dacc0daa867cc6a7e61" name="ad276d54477d80dacc0daa867cc6a7e61"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pushFront</b> (<a class="el" href="classBlock.html">Block</a> &amp;&amp;block)</td></tr>
<tr class="memdesc:ad276d54477d80dacc0daa867cc6a7e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for <code><a class="el" href="classStorage.html#a0d5fdb319d6861d835c76cfe819b958a" title="Add a block to the start of the chain.">pushFrontInternal()</a></code>. Use this as it properly locks <code>chainLock</code>. <br /></td></tr>
<tr class="separator:ad276d54477d80dacc0daa867cc6a7e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23545498f1cd6dab72a6513808b682ec"><td class="memItemLeft" align="right" valign="top"><a id="a23545498f1cd6dab72a6513808b682ec" name="a23545498f1cd6dab72a6513808b682ec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>popBack</b> ()</td></tr>
<tr class="memdesc:a23545498f1cd6dab72a6513808b682ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a block from the end of the chain. <br /></td></tr>
<tr class="separator:a23545498f1cd6dab72a6513808b682ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69281ca662cf783ad83f042fb72dc33"><td class="memItemLeft" align="right" valign="top"><a id="aa69281ca662cf783ad83f042fb72dc33" name="aa69281ca662cf783ad83f042fb72dc33"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>popFront</b> ()</td></tr>
<tr class="memdesc:aa69281ca662cf783ad83f042fb72dc33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a block from the start of the chain. <br /></td></tr>
<tr class="separator:aa69281ca662cf783ad83f042fb72dc33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7180a19d9e524d0d4153524ae0c7a8"><td class="memItemLeft" align="right" valign="top">StorageStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a4e7180a19d9e524d0d4153524ae0c7a8">blockExists</a> (const <a class="el" href="classHash.html">Hash</a> &amp;hash)</td></tr>
<tr class="memdesc:a4e7180a19d9e524d0d4153524ae0c7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a block exists anywhere in storage (memory/chain, then cache, then database).  <a href="classStorage.html#a4e7180a19d9e524d0d4153524ae0c7a8">More...</a><br /></td></tr>
<tr class="separator:a4e7180a19d9e524d0d4153524ae0c7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12456c8551d31bad3abaf12a35b8d985"><td class="memItemLeft" align="right" valign="top">StorageStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a12456c8551d31bad3abaf12a35b8d985">blockExists</a> (const uint64_t &amp;height)</td></tr>
<tr class="memdesc:a12456c8551d31bad3abaf12a35b8d985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <a class="el" href="classStorage.html#a4e7180a19d9e524d0d4153524ae0c7a8" title="Check if a block exists anywhere in storage (memory/chain, then cache, then database).">blockExists()</a> that works with block height instead of hash.  <a href="classStorage.html#a12456c8551d31bad3abaf12a35b8d985">More...</a><br /></td></tr>
<tr class="separator:a12456c8551d31bad3abaf12a35b8d985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011f9aeef1e65f3aee46fcd8ab48a7ea"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; const <a class="el" href="classBlock.html">Block</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a011f9aeef1e65f3aee46fcd8ab48a7ea">getBlock</a> (const <a class="el" href="classHash.html">Hash</a> &amp;hash)</td></tr>
<tr class="memdesc:a011f9aeef1e65f3aee46fcd8ab48a7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a block from the chain using a given hash.  <a href="classStorage.html#a011f9aeef1e65f3aee46fcd8ab48a7ea">More...</a><br /></td></tr>
<tr class="separator:a011f9aeef1e65f3aee46fcd8ab48a7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099c1422a244d6aedef9677736e0c0d5"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; const <a class="el" href="classBlock.html">Block</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a099c1422a244d6aedef9677736e0c0d5">getBlock</a> (const uint64_t &amp;height)</td></tr>
<tr class="memdesc:a099c1422a244d6aedef9677736e0c0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a block from the chain using a given height.  <a href="classStorage.html#a099c1422a244d6aedef9677736e0c0d5">More...</a><br /></td></tr>
<tr class="separator:a099c1422a244d6aedef9677736e0c0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf199dabe022ba4ed2fa456d4dc85f8"><td class="memItemLeft" align="right" valign="top">StorageStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a8cf199dabe022ba4ed2fa456d4dc85f8">txExists</a> (const <a class="el" href="classHash.html">Hash</a> &amp;tx)</td></tr>
<tr class="memdesc:a8cf199dabe022ba4ed2fa456d4dc85f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a transaction exists anywhere in storage (memory/chain, then cache, then database).  <a href="classStorage.html#a8cf199dabe022ba4ed2fa456d4dc85f8">More...</a><br /></td></tr>
<tr class="separator:a8cf199dabe022ba4ed2fa456d4dc85f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8b82552263dbb3b3df59665cd65e73"><td class="memItemLeft" align="right" valign="top">const std::tuple&lt; const std::shared_ptr&lt; const <a class="el" href="classTxBlock.html">TxBlock</a> &gt;, const <a class="el" href="classHash.html">Hash</a>, const uint64_t, const uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a0e8b82552263dbb3b3df59665cd65e73">getTx</a> (const <a class="el" href="classHash.html">Hash</a> &amp;tx)</td></tr>
<tr class="memdesc:a0e8b82552263dbb3b3df59665cd65e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a transaction from the chain using a given hash.  <a href="classStorage.html#a0e8b82552263dbb3b3df59665cd65e73">More...</a><br /></td></tr>
<tr class="separator:a0e8b82552263dbb3b3df59665cd65e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fc9debe348d564b2b8e2d769a35ca7"><td class="memItemLeft" align="right" valign="top">const std::tuple&lt; const std::shared_ptr&lt; const <a class="el" href="classTxBlock.html">TxBlock</a> &gt;, const <a class="el" href="classHash.html">Hash</a>, const uint64_t, const uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a24fc9debe348d564b2b8e2d769a35ca7">getTxByBlockHashAndIndex</a> (const <a class="el" href="classHash.html">Hash</a> &amp;blockHash, const uint64_t blockIndex)</td></tr>
<tr class="memdesc:a24fc9debe348d564b2b8e2d769a35ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a transaction from a block with a specific index.  <a href="classStorage.html#a24fc9debe348d564b2b8e2d769a35ca7">More...</a><br /></td></tr>
<tr class="separator:a24fc9debe348d564b2b8e2d769a35ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43a55ffd02ff44e61a3ab654e79a1d0"><td class="memItemLeft" align="right" valign="top">const std::tuple&lt; const std::shared_ptr&lt; const <a class="el" href="classTxBlock.html">TxBlock</a> &gt;, const <a class="el" href="classHash.html">Hash</a>, const uint64_t, const uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#ae43a55ffd02ff44e61a3ab654e79a1d0">getTxByBlockNumberAndIndex</a> (const uint64_t &amp;blockHeight, const uint64_t blockIndex)</td></tr>
<tr class="memdesc:ae43a55ffd02ff44e61a3ab654e79a1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a transaction from a block with a specific index.  <a href="classStorage.html#ae43a55ffd02ff44e61a3ab654e79a1d0">More...</a><br /></td></tr>
<tr class="separator:ae43a55ffd02ff44e61a3ab654e79a1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb8497c1b9b3940d6804c84ecccb2e7"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; const <a class="el" href="classBlock.html">Block</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a9cb8497c1b9b3940d6804c84ecccb2e7">latest</a> ()</td></tr>
<tr class="memdesc:a9cb8497c1b9b3940d6804c84ecccb2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the most recently added block from the chain.  <a href="classStorage.html#a9cb8497c1b9b3940d6804c84ecccb2e7">More...</a><br /></td></tr>
<tr class="separator:a9cb8497c1b9b3940d6804c84ecccb2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bab648220bc16f7d04b16892d36737"><td class="memItemLeft" align="right" valign="top"><a id="a57bab648220bc16f7d04b16892d36737" name="a57bab648220bc16f7d04b16892d36737"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>currentChainSize</b> ()</td></tr>
<tr class="memdesc:a57bab648220bc16f7d04b16892d36737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of blocks currently in the chain (nHeight of latest block + 1). <br /></td></tr>
<tr class="separator:a57bab648220bc16f7d04b16892d36737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4924e7d0cf9b90648c37eb4ae18dccc0"><td class="memItemLeft" align="right" valign="top"><a id="a4924e7d0cf9b90648c37eb4ae18dccc0" name="a4924e7d0cf9b90648c37eb4ae18dccc0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>periodicSaveToDB</b> ()</td></tr>
<tr class="memdesc:a4924e7d0cf9b90648c37eb4ae18dccc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the periodic save thread. TODO: this should be called by the constructor. <br /></td></tr>
<tr class="separator:a4924e7d0cf9b90648c37eb4ae18dccc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de117f74c94b6bef683e9ca9baf287e"><td class="memItemLeft" align="right" valign="top"><a id="a5de117f74c94b6bef683e9ca9baf287e" name="a5de117f74c94b6bef683e9ca9baf287e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>stopPeriodicSaveToDB</b> ()</td></tr>
<tr class="memdesc:a5de117f74c94b6bef683e9ca9baf287e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the periodic save thread. TODO: this should be called by the destructor. <br /></td></tr>
<tr class="separator:a5de117f74c94b6bef683e9ca9baf287e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:acd7ed7b8aeefe31a2b928407460c9dff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#acd7ed7b8aeefe31a2b928407460c9dff">pushBackInternal</a> (<a class="el" href="classBlock.html">Block</a> &amp;&amp;block)</td></tr>
<tr class="memdesc:acd7ed7b8aeefe31a2b928407460c9dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a block to the end of the chain.  <a href="classStorage.html#acd7ed7b8aeefe31a2b928407460c9dff">More...</a><br /></td></tr>
<tr class="separator:acd7ed7b8aeefe31a2b928407460c9dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5fdb319d6861d835c76cfe819b958a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a0d5fdb319d6861d835c76cfe819b958a">pushFrontInternal</a> (<a class="el" href="classBlock.html">Block</a> &amp;&amp;block)</td></tr>
<tr class="memdesc:a0d5fdb319d6861d835c76cfe819b958a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a block to the start of the chain.  <a href="classStorage.html#a0d5fdb319d6861d835c76cfe819b958a">More...</a><br /></td></tr>
<tr class="separator:a0d5fdb319d6861d835c76cfe819b958a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c74c1e829a057200eb06c6ac137e66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a06c74c1e829a057200eb06c6ac137e66">initializeBlockchain</a> ()</td></tr>
<tr class="memdesc:a06c74c1e829a057200eb06c6ac137e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the blockchain the first time the blockchain binary is booted.  <a href="classStorage.html#a06c74c1e829a057200eb06c6ac137e66">More...</a><br /></td></tr>
<tr class="separator:a06c74c1e829a057200eb06c6ac137e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2406ed80af38b6af913a7b661f2a05ed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTxBlock.html">TxBlock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a2406ed80af38b6af913a7b661f2a05ed">getTxFromBlockWithIndex</a> (const std::string_view blockData, const uint64_t &amp;txIndex)</td></tr>
<tr class="memdesc:a2406ed80af38b6af913a7b661f2a05ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a given transaction from a serialized block data string.  <a href="classStorage.html#a2406ed80af38b6af913a7b661f2a05ed">More...</a><br /></td></tr>
<tr class="separator:a2406ed80af38b6af913a7b661f2a05ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a2dda489465964490bd7ffeb752bbe20e"><td class="memItemLeft" align="right" valign="top"><a id="a2dda489465964490bd7ffeb752bbe20e" name="a2dda489465964490bd7ffeb752bbe20e"></a>
const std::unique_ptr&lt; <a class="el" href="classDB.html">DB</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>db</b></td></tr>
<tr class="memdesc:a2dda489465964490bd7ffeb752bbe20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the database that contains the blockchain's entire history. <br /></td></tr>
<tr class="separator:a2dda489465964490bd7ffeb752bbe20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937408cf51999eb5abaeffd6221be1a5"><td class="memItemLeft" align="right" valign="top"><a id="a937408cf51999eb5abaeffd6221be1a5" name="a937408cf51999eb5abaeffd6221be1a5"></a>
const std::unique_ptr&lt; <a class="el" href="classOptions.html">Options</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>options</b></td></tr>
<tr class="memdesc:a937408cf51999eb5abaeffd6221be1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the options singleton. <br /></td></tr>
<tr class="separator:a937408cf51999eb5abaeffd6221be1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5910566853ca82e4454e10943ea92968"><td class="memItemLeft" align="right" valign="top">std::deque&lt; std::shared_ptr&lt; const <a class="el" href="classBlock.html">Block</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a5910566853ca82e4454e10943ea92968">chain</a></td></tr>
<tr class="memdesc:a5910566853ca82e4454e10943ea92968"><td class="mdescLeft">&#160;</td><td class="mdescRight">The recent blockchain history, up to the 1000 most recent blocks, or 1M transactions, whichever comes first.  <a href="classStorage.html#a5910566853ca82e4454e10943ea92968">More...</a><br /></td></tr>
<tr class="separator:a5910566853ca82e4454e10943ea92968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166e9ad452dbf3d7d1f52acb66f27e36"><td class="memItemLeft" align="right" valign="top"><a id="a166e9ad452dbf3d7d1f52acb66f27e36" name="a166e9ad452dbf3d7d1f52acb66f27e36"></a>
std::unordered_map&lt; <a class="el" href="classHash.html">Hash</a>, const std::shared_ptr&lt; const <a class="el" href="classBlock.html">Block</a> &gt;, <a class="el" href="structSafeHash.html">SafeHash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>blockByHash</b></td></tr>
<tr class="memdesc:a166e9ad452dbf3d7d1f52acb66f27e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map that indexes blocks in memory by their respective hashes. <br /></td></tr>
<tr class="separator:a166e9ad452dbf3d7d1f52acb66f27e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8406bcbe869c07a3aa09fa79ff506e4f"><td class="memItemLeft" align="right" valign="top"><a id="a8406bcbe869c07a3aa09fa79ff506e4f" name="a8406bcbe869c07a3aa09fa79ff506e4f"></a>
std::unordered_map&lt; <a class="el" href="classHash.html">Hash</a>, const std::tuple&lt; const <a class="el" href="classHash.html">Hash</a>, const uint64_t, const uint64_t &gt;, <a class="el" href="structSafeHash.html">SafeHash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>txByHash</b></td></tr>
<tr class="memdesc:a8406bcbe869c07a3aa09fa79ff506e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map that indexes Tx, blockHash, blockIndex and blockHeight by their respective hashes. <br /></td></tr>
<tr class="separator:a8406bcbe869c07a3aa09fa79ff506e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d1d049e4ad0d5219c7fb9c41db973f"><td class="memItemLeft" align="right" valign="top"><a id="ac1d1d049e4ad0d5219c7fb9c41db973f" name="ac1d1d049e4ad0d5219c7fb9c41db973f"></a>
std::unordered_map&lt; <a class="el" href="classHash.html">Hash</a>, const uint64_t, <a class="el" href="structSafeHash.html">SafeHash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>blockHeightByHash</b></td></tr>
<tr class="memdesc:ac1d1d049e4ad0d5219c7fb9c41db973f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map that indexes all block heights in the chain by their respective hashes. <br /></td></tr>
<tr class="separator:ac1d1d049e4ad0d5219c7fb9c41db973f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3bac8145ecba2f6d9d333302462b9b"><td class="memItemLeft" align="right" valign="top"><a id="a7f3bac8145ecba2f6d9d333302462b9b" name="a7f3bac8145ecba2f6d9d333302462b9b"></a>
std::unordered_map&lt; uint64_t, const <a class="el" href="classHash.html">Hash</a>, <a class="el" href="structSafeHash.html">SafeHash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>blockHashByHeight</b></td></tr>
<tr class="memdesc:a7f3bac8145ecba2f6d9d333302462b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map that indexes all block hashes in the chain by their respective heights. <br /></td></tr>
<tr class="separator:a7f3bac8145ecba2f6d9d333302462b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96078fa1555a8664a65a3788fe2a9ff"><td class="memItemLeft" align="right" valign="top"><a id="aa96078fa1555a8664a65a3788fe2a9ff" name="aa96078fa1555a8664a65a3788fe2a9ff"></a>
std::unordered_map&lt; <a class="el" href="classHash.html">Hash</a>, const std::shared_ptr&lt; const <a class="el" href="classBlock.html">Block</a> &gt;, <a class="el" href="structSafeHash.html">SafeHash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>cachedBlocks</b></td></tr>
<tr class="memdesc:aa96078fa1555a8664a65a3788fe2a9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache space for blocks that will be included in the blockchain. <br /></td></tr>
<tr class="separator:aa96078fa1555a8664a65a3788fe2a9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f1ceffc355cd73684b0904469c06c0"><td class="memItemLeft" align="right" valign="top"><a id="ae8f1ceffc355cd73684b0904469c06c0" name="ae8f1ceffc355cd73684b0904469c06c0"></a>
std::unordered_map&lt; <a class="el" href="classHash.html">Hash</a>, const std::tuple&lt; const std::shared_ptr&lt; const <a class="el" href="classTxBlock.html">TxBlock</a> &gt;, const <a class="el" href="classHash.html">Hash</a>, const uint64_t, const uint64_t &gt;, <a class="el" href="structSafeHash.html">SafeHash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>cachedTxs</b></td></tr>
<tr class="memdesc:ae8f1ceffc355cd73684b0904469c06c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache space for transactions that will be included in the blockchain (tx, txBlockHash, txBlockIndex, txBlockHeight). <br /></td></tr>
<tr class="separator:ae8f1ceffc355cd73684b0904469c06c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1315a202dc6c0c724021ee5d93985034"><td class="memItemLeft" align="right" valign="top"><a id="a1315a202dc6c0c724021ee5d93985034" name="a1315a202dc6c0c724021ee5d93985034"></a>
std::shared_mutex&#160;</td><td class="memItemRight" valign="bottom"><b>chainLock</b></td></tr>
<tr class="memdesc:a1315a202dc6c0c724021ee5d93985034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex for managing read/write access to the blockchain. <br /></td></tr>
<tr class="separator:a1315a202dc6c0c724021ee5d93985034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2103500742c9a830662292b20bf475"><td class="memItemLeft" align="right" valign="top"><a id="aab2103500742c9a830662292b20bf475" name="aab2103500742c9a830662292b20bf475"></a>
std::shared_mutex&#160;</td><td class="memItemRight" valign="bottom"><b>cacheLock</b></td></tr>
<tr class="memdesc:aab2103500742c9a830662292b20bf475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to manage read/write access to the cache. <br /></td></tr>
<tr class="separator:aab2103500742c9a830662292b20bf475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb29e13abf27d9228f16767e358c639"><td class="memItemLeft" align="right" valign="top"><a id="a3bb29e13abf27d9228f16767e358c639" name="a3bb29e13abf27d9228f16767e358c639"></a>
std::thread&#160;</td><td class="memItemRight" valign="bottom"><b>periodicSaveThread</b></td></tr>
<tr class="memdesc:a3bb29e13abf27d9228f16767e358c639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread that periodically saves the blockchain history to the database. <br /></td></tr>
<tr class="separator:a3bb29e13abf27d9228f16767e358c639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8404a1e430b6efc5e2ba778b5a3f7b2"><td class="memItemLeft" align="right" valign="top"><a id="ad8404a1e430b6efc5e2ba778b5a3f7b2" name="ad8404a1e430b6efc5e2ba778b5a3f7b2"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>periodicSaveCooldown</b> = 15</td></tr>
<tr class="memdesc:ad8404a1e430b6efc5e2ba778b5a3f7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooldown for the periodic save thread, in seconds. <br /></td></tr>
<tr class="separator:ad8404a1e430b6efc5e2ba778b5a3f7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d94af86d718e7f4c34864a179773e0d"><td class="memItemLeft" align="right" valign="top"><a id="a8d94af86d718e7f4c34864a179773e0d" name="a8d94af86d718e7f4c34864a179773e0d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>stopPeriodicSave</b> = false</td></tr>
<tr class="memdesc:a8d94af86d718e7f4c34864a179773e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for stopping the periodic save thread, if required. <br /></td></tr>
<tr class="separator:a8d94af86d718e7f4c34864a179773e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Abstraction of the blockchain history. </p>
<p >Used to store blocks in memory and on disk, and helps the <a class="el" href="classState.html" title="Abstraction of the blockchain&#39;s state.">State</a> process new blocks, transactions and RPC queries. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae56a62413a2c31373f4eb07eb3f28772" name="ae56a62413a2c31373f4eb07eb3f28772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56a62413a2c31373f4eb07eb3f28772">&#9670;&nbsp;</a></span>Storage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Storage::Storage </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; <a class="el" href="classDB.html">DB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; <a class="el" href="classOptions.html">Options</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p >Automatically loads the chain from the database and starts the periodic save thread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">db</td><td>Pointer to the database. </td></tr>
    <tr><td class="paramname">options</td><td>Pointer to the options singleton. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73cf30f0a34250396f9eabee7dc5c93d" name="a73cf30f0a34250396f9eabee7dc5c93d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73cf30f0a34250396f9eabee7dc5c93d">&#9670;&nbsp;</a></span>~Storage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Storage::~Storage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p >Automatically saves the chain to the database. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4e7180a19d9e524d0d4153524ae0c7a8" name="a4e7180a19d9e524d0d4153524ae0c7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7180a19d9e524d0d4153524ae0c7a8">&#9670;&nbsp;</a></span>blockExists() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StorageStatus Storage::blockExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHash.html">Hash</a> &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a block exists anywhere in storage (memory/chain, then cache, then database). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The block hash to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum telling where the block is. </dd></dl>

</div>
</div>
<a id="a12456c8551d31bad3abaf12a35b8d985" name="a12456c8551d31bad3abaf12a35b8d985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12456c8551d31bad3abaf12a35b8d985">&#9670;&nbsp;</a></span>blockExists() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StorageStatus Storage::blockExists </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>height</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of <a class="el" href="classStorage.html#a4e7180a19d9e524d0d4153524ae0c7a8" title="Check if a block exists anywhere in storage (memory/chain, then cache, then database).">blockExists()</a> that works with block height instead of hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>The block height to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum telling where the block is. </dd></dl>

</div>
</div>
<a id="a011f9aeef1e65f3aee46fcd8ab48a7ea" name="a011f9aeef1e65f3aee46fcd8ab48a7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011f9aeef1e65f3aee46fcd8ab48a7ea">&#9670;&nbsp;</a></span>getBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt; const <a class="el" href="classBlock.html">Block</a> &gt; Storage::getBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHash.html">Hash</a> &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a block from the chain using a given hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The block hash to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the found block, or <code>nullptr</code> if block is not found. </dd></dl>

</div>
</div>
<a id="a099c1422a244d6aedef9677736e0c0d5" name="a099c1422a244d6aedef9677736e0c0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099c1422a244d6aedef9677736e0c0d5">&#9670;&nbsp;</a></span>getBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt; const <a class="el" href="classBlock.html">Block</a> &gt; Storage::getBlock </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>height</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a block from the chain using a given height. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>The block height to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the found block, or <code>nullptr</code> if block is not found. </dd></dl>

</div>
</div>
<a id="a0e8b82552263dbb3b3df59665cd65e73" name="a0e8b82552263dbb3b3df59665cd65e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8b82552263dbb3b3df59665cd65e73">&#9670;&nbsp;</a></span>getTx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::tuple&lt; const std::shared_ptr&lt; const <a class="el" href="classTxBlock.html">TxBlock</a> &gt;, const <a class="el" href="classHash.html">Hash</a>, const uint64_t, const uint64_t &gt; Storage::getTx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHash.html">Hash</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a transaction from the chain using a given hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>The transaction hash to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple with the found transaction, block hash, index and height. </dd></dl>

</div>
</div>
<a id="a24fc9debe348d564b2b8e2d769a35ca7" name="a24fc9debe348d564b2b8e2d769a35ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fc9debe348d564b2b8e2d769a35ca7">&#9670;&nbsp;</a></span>getTxByBlockHashAndIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::tuple&lt; const std::shared_ptr&lt; const <a class="el" href="classTxBlock.html">TxBlock</a> &gt;, const <a class="el" href="classHash.html">Hash</a>, const uint64_t, const uint64_t &gt; Storage::getTxByBlockHashAndIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHash.html">Hash</a> &amp;&#160;</td>
          <td class="paramname"><em>blockHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>blockIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a transaction from a block with a specific index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockHash</td><td>The block hash </td></tr>
    <tr><td class="paramname">blockIndex</td><td>the index within the block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple with the found transaction, block hash, index and height. </dd></dl>

</div>
</div>
<a id="ae43a55ffd02ff44e61a3ab654e79a1d0" name="ae43a55ffd02ff44e61a3ab654e79a1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43a55ffd02ff44e61a3ab654e79a1d0">&#9670;&nbsp;</a></span>getTxByBlockNumberAndIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::tuple&lt; const std::shared_ptr&lt; const <a class="el" href="classTxBlock.html">TxBlock</a> &gt;, const <a class="el" href="classHash.html">Hash</a>, const uint64_t, const uint64_t &gt; Storage::getTxByBlockNumberAndIndex </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>blockHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>blockIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a transaction from a block with a specific index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockHeight</td><td>The block height </td></tr>
    <tr><td class="paramname">blockIndex</td><td>The index within the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple with the found transaction, block hash, index and height. </dd></dl>

</div>
</div>
<a id="a2406ed80af38b6af913a7b661f2a05ed" name="a2406ed80af38b6af913a7b661f2a05ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2406ed80af38b6af913a7b661f2a05ed">&#9670;&nbsp;</a></span>getTxFromBlockWithIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTxBlock.html">TxBlock</a> Storage::getTxFromBlockWithIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>blockData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>txIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a given transaction from a serialized block data string. </p>
<p >Used to get only a specific transaction from a block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockData</td><td>The serialized block data string. </td></tr>
    <tr><td class="paramname">txIndex</td><td>The index of the transaction to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transaction itself. </dd></dl>
<p >Count txs until index.</p>

</div>
</div>
<a id="a06c74c1e829a057200eb06c6ac137e66" name="a06c74c1e829a057200eb06c6ac137e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c74c1e829a057200eb06c6ac137e66">&#9670;&nbsp;</a></span>initializeBlockchain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::initializeBlockchain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the blockchain the first time the blockchain binary is booted. </p>
<p >Called by the constructor. Will only populate information related to the class, such as genesis and mappings. </p>

</div>
</div>
<a id="a9cb8497c1b9b3940d6804c84ecccb2e7" name="a9cb8497c1b9b3940d6804c84ecccb2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb8497c1b9b3940d6804c84ecccb2e7">&#9670;&nbsp;</a></span>latest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt; const <a class="el" href="classBlock.html">Block</a> &gt; Storage::latest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the most recently added block from the chain. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the latest block. </dd></dl>

</div>
</div>
<a id="acd7ed7b8aeefe31a2b928407460c9dff" name="acd7ed7b8aeefe31a2b928407460c9dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7ed7b8aeefe31a2b928407460c9dff">&#9670;&nbsp;</a></span>pushBackInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::pushBackInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlock.html">Block</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a block to the end of the chain. </p>
<p >Only call this function directly if absolutely sure that <code>chainLock</code> is locked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d5fdb319d6861d835c76cfe819b958a" name="a0d5fdb319d6861d835c76cfe819b958a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5fdb319d6861d835c76cfe819b958a">&#9670;&nbsp;</a></span>pushFrontInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::pushFrontInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlock.html">Block</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a block to the start of the chain. </p>
<p >Only call this function directly if absolutely sure that <code>chainLock</code> is locked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cf199dabe022ba4ed2fa456d4dc85f8" name="a8cf199dabe022ba4ed2fa456d4dc85f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf199dabe022ba4ed2fa456d4dc85f8">&#9670;&nbsp;</a></span>txExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StorageStatus Storage::txExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHash.html">Hash</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a transaction exists anywhere in storage (memory/chain, then cache, then database). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>The transaction to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum telling where the transaction is. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5910566853ca82e4454e10943ea92968" name="a5910566853ca82e4454e10943ea92968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5910566853ca82e4454e10943ea92968">&#9670;&nbsp;</a></span>chain</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;std::shared_ptr&lt;const <a class="el" href="classBlock.html">Block</a>&gt; &gt; Storage::chain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The recent blockchain history, up to the 1000 most recent blocks, or 1M transactions, whichever comes first. </p>
<p >This limit is required because it would be too expensive to keep every single transaction in memory all the time, so once it reaches the limit, or every now and then, the blocks are dumped to the database. This keeps the blockchain lightweight in memory and extremely responsive. Older blocks always at FRONT, newer blocks always at BACK. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/core/<a class="el" href="storage_8h_source.html">storage.h</a></li>
<li>src/core/storage.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
