<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OrbiterSDK: State Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OrbiterSDK<span id="projectnumber">&#160;1</span>
   </div>
   <div id="projectbrief">Subnet from Sparq Labs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classState-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">State Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Abstraction of the blockchain's state.  
 <a href="classState.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="state_8h_source.html">state.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af644a7bf78a51943286674716d154cc5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#af644a7bf78a51943286674716d154cc5">State</a> (const std::unique_ptr&lt; <a class="el" href="classDB.html">DB</a> &gt; &amp;<a class="el" href="classState.html#ad7ca9a8a5635df6b7c40ace0db5b2830">db</a>, const std::unique_ptr&lt; <a class="el" href="classStorage.html">Storage</a> &gt; &amp;<a class="el" href="classState.html#a4eb0b23f455177c74d68606382e57534">storage</a>, const std::unique_ptr&lt; <a class="el" href="classrdPoS.html">rdPoS</a> &gt; &amp;<a class="el" href="classState.html#a177e70d002bb74845dde71ce3a8909f4">rdpos</a>, const std::unique_ptr&lt; <a class="el" href="classP2P_1_1ManagerNormal.html">P2P::ManagerNormal</a> &gt; &amp;<a class="el" href="classState.html#aa24885d108f6240f7c9a5cbee293cd8b">p2pManager</a>, const std::unique_ptr&lt; <a class="el" href="classOptions.html">Options</a> &gt; &amp;<a class="el" href="classState.html#aaa6ef1339da0790d2c38abb1109dcf63">options</a>)</td></tr>
<tr class="memdesc:af644a7bf78a51943286674716d154cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classState.html#af644a7bf78a51943286674716d154cc5">More...</a><br /></td></tr>
<tr class="separator:af644a7bf78a51943286674716d154cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab438d92b90dc18d194dbd9c9c8bab3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#afab438d92b90dc18d194dbd9c9c8bab3">~State</a> ()</td></tr>
<tr class="memdesc:afab438d92b90dc18d194dbd9c9c8bab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classState.html#afab438d92b90dc18d194dbd9c9c8bab3">More...</a><br /></td></tr>
<tr class="separator:afab438d92b90dc18d194dbd9c9c8bab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982301c2bad1fe826db29640accb7b7d"><td class="memItemLeft" align="right" valign="top">const uint256_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a982301c2bad1fe826db29640accb7b7d">getNativeBalance</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:a982301c2bad1fe826db29640accb7b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the native balance of an account in the state.  <a href="classState.html#a982301c2bad1fe826db29640accb7b7d">More...</a><br /></td></tr>
<tr class="separator:a982301c2bad1fe826db29640accb7b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bba399ab7fc870f681158ff8d854c7"><td class="memItemLeft" align="right" valign="top">const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a23bba399ab7fc870f681158ff8d854c7">getNativeNonce</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:a23bba399ab7fc870f681158ff8d854c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the native nonce of an account in the state.  <a href="classState.html#a23bba399ab7fc870f681158ff8d854c7">More...</a><br /></td></tr>
<tr class="separator:a23bba399ab7fc870f681158ff8d854c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9837990e3e5874d88298e00f925568"><td class="memItemLeft" align="right" valign="top"><a id="a7f9837990e3e5874d88298e00f925568" name="a7f9837990e3e5874d88298e00f925568"></a>
const std::unordered_map&lt; <a class="el" href="classAddress.html">Address</a>, <a class="el" href="structAccount.html">Account</a>, <a class="el" href="structSafeHash.html">SafeHash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getAccounts</b> () const</td></tr>
<tr class="memdesc:a7f9837990e3e5874d88298e00f925568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for <code>accounts</code>. Returns a copy. <br /></td></tr>
<tr class="separator:a7f9837990e3e5874d88298e00f925568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa106e5c86c8cd1cf50a95303b9280a37"><td class="memItemLeft" align="right" valign="top"><a id="aa106e5c86c8cd1cf50a95303b9280a37" name="aa106e5c86c8cd1cf50a95303b9280a37"></a>
const std::unordered_map&lt; <a class="el" href="classHash.html">Hash</a>, <a class="el" href="classTxBlock.html">TxBlock</a>, <a class="el" href="structSafeHash.html">SafeHash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getMempool</b> () const</td></tr>
<tr class="memdesc:aa106e5c86c8cd1cf50a95303b9280a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for <code>mempool</code>. Returns a copy. <br /></td></tr>
<tr class="separator:aa106e5c86c8cd1cf50a95303b9280a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd852011fd08e0d90381d814220f525"><td class="memItemLeft" align="right" valign="top"><a id="a6fd852011fd08e0d90381d814220f525" name="a6fd852011fd08e0d90381d814220f525"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getMempoolSize</b> () const</td></tr>
<tr class="memdesc:a6fd852011fd08e0d90381d814220f525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mempool's current size. <br /></td></tr>
<tr class="separator:a6fd852011fd08e0d90381d814220f525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb9826c231245e89ddf6791d2cf4c31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#abbb9826c231245e89ddf6791d2cf4c31">validateNextBlock</a> (const <a class="el" href="classBlock.html">Block</a> &amp;block) const</td></tr>
<tr class="memdesc:abbb9826c231245e89ddf6791d2cf4c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the next block given the current state and its transactions.  <a href="classState.html#abbb9826c231245e89ddf6791d2cf4c31">More...</a><br /></td></tr>
<tr class="separator:abbb9826c231245e89ddf6791d2cf4c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de031bf3cd4328caa7473f03c10954b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a8de031bf3cd4328caa7473f03c10954b">processNextBlock</a> (<a class="el" href="classBlock.html">Block</a> &amp;&amp;block)</td></tr>
<tr class="memdesc:a8de031bf3cd4328caa7473f03c10954b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the next block given current state from the network.  <a href="classState.html#a8de031bf3cd4328caa7473f03c10954b">More...</a><br /></td></tr>
<tr class="separator:a8de031bf3cd4328caa7473f03c10954b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb96567d4d00d045e06e10f04174717f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#acb96567d4d00d045e06e10f04174717f">fillBlockWithTransactions</a> (<a class="el" href="classBlock.html">Block</a> &amp;block) const</td></tr>
<tr class="memdesc:acb96567d4d00d045e06e10f04174717f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a block with all transactions currently in the mempool.  <a href="classState.html#acb96567d4d00d045e06e10f04174717f">More...</a><br /></td></tr>
<tr class="separator:acb96567d4d00d045e06e10f04174717f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba76d4c86e026911d78fcb77d8d9a5af"><td class="memItemLeft" align="right" valign="top">TxInvalid&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#aba76d4c86e026911d78fcb77d8d9a5af">validateTransaction</a> (const <a class="el" href="classTxBlock.html">TxBlock</a> &amp;tx) const</td></tr>
<tr class="memdesc:aba76d4c86e026911d78fcb77d8d9a5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if a transaction can be accepted within the current state.  <a href="classState.html#aba76d4c86e026911d78fcb77d8d9a5af">More...</a><br /></td></tr>
<tr class="separator:aba76d4c86e026911d78fcb77d8d9a5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01905069aff940eb4906fdf312a2ce33"><td class="memItemLeft" align="right" valign="top">TxInvalid&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a01905069aff940eb4906fdf312a2ce33">addTx</a> (<a class="el" href="classTxBlock.html">TxBlock</a> &amp;&amp;tx)</td></tr>
<tr class="memdesc:a01905069aff940eb4906fdf312a2ce33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a transaction to the mempool, if valid.  <a href="classState.html#a01905069aff940eb4906fdf312a2ce33">More...</a><br /></td></tr>
<tr class="separator:a01905069aff940eb4906fdf312a2ce33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f2d2092a54191583d3e8584372e712"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a80f2d2092a54191583d3e8584372e712">addValidatorTx</a> (const <a class="el" href="classTxValidator.html">TxValidator</a> &amp;tx)</td></tr>
<tr class="memdesc:a80f2d2092a54191583d3e8584372e712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="classValidator.html" title="Abstraction of a validator.">Validator</a> transaction to the <a class="el" href="classrdPoS.html" title="Abstraction of the rdPoS (Random Deterministic Proof of Stake) consensus algorithm.">rdPoS</a> mempool, if valid.  <a href="classState.html#a80f2d2092a54191583d3e8584372e712">More...</a><br /></td></tr>
<tr class="separator:a80f2d2092a54191583d3e8584372e712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc33c0a39c4eb8f25846d8623a6b3a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#aabc33c0a39c4eb8f25846d8623a6b3a9">isTxInMempool</a> (const <a class="el" href="classHash.html">Hash</a> &amp;txHash) const</td></tr>
<tr class="memdesc:aabc33c0a39c4eb8f25846d8623a6b3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a transaction is in the mempool.  <a href="classState.html#aabc33c0a39c4eb8f25846d8623a6b3a9">More...</a><br /></td></tr>
<tr class="separator:aabc33c0a39c4eb8f25846d8623a6b3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcc769697a3b38ff3d561b603999b72"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classTxBlock.html">TxBlock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a7bcc769697a3b38ff3d561b603999b72">getTxFromMempool</a> (const <a class="el" href="classHash.html">Hash</a> &amp;txHash) const</td></tr>
<tr class="memdesc:a7bcc769697a3b38ff3d561b603999b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a transaction from the mempool.  <a href="classState.html#a7bcc769697a3b38ff3d561b603999b72">More...</a><br /></td></tr>
<tr class="separator:a7bcc769697a3b38ff3d561b603999b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596b8016292281a9d2fd3010d6771d89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a596b8016292281a9d2fd3010d6771d89">addBalance</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr)</td></tr>
<tr class="memdesc:a596b8016292281a9d2fd3010d6771d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add balance to a given account.  <a href="classState.html#a596b8016292281a9d2fd3010d6771d89">More...</a><br /></td></tr>
<tr class="separator:a596b8016292281a9d2fd3010d6771d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc934938772088354861d7aee343128"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#aefc934938772088354861d7aee343128">ethCall</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, const std::string &amp;data)</td></tr>
<tr class="memdesc:aefc934938772088354861d7aee343128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulate an <code>eth_call</code> to a contract.  <a href="classState.html#aefc934938772088354861d7aee343128">More...</a><br /></td></tr>
<tr class="separator:aefc934938772088354861d7aee343128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6359b4c207a6cb9f9fddc611cb42ae0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a6359b4c207a6cb9f9fddc611cb42ae0f">estimateGas</a> (const std::tuple&lt; <a class="el" href="classAddress.html">Address</a>, <a class="el" href="classAddress.html">Address</a>, uint64_t, uint256_t, uint256_t, std::string &gt; &amp;callInfo)</td></tr>
<tr class="memdesc:a6359b4c207a6cb9f9fddc611cb42ae0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate gas for callInfo in RPC.  <a href="classState.html#a6359b4c207a6cb9f9fddc611cb42ae0f">More...</a><br /></td></tr>
<tr class="separator:a6359b4c207a6cb9f9fddc611cb42ae0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511b5a3700c64afa3688f756606666b1"><td class="memItemLeft" align="right" valign="top"><a id="a511b5a3700c64afa3688f756606666b1" name="a511b5a3700c64afa3688f756606666b1"></a>
std::vector&lt; std::pair&lt; std::string, <a class="el" href="classAddress.html">Address</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getContracts</b> () const</td></tr>
<tr class="memdesc:a511b5a3700c64afa3688f756606666b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of contract addresses and names. <br /></td></tr>
<tr class="separator:a511b5a3700c64afa3688f756606666b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a00d0b422ef23f76edd3e928f0a618534"><td class="memItemLeft" align="right" valign="top">TxInvalid&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a00d0b422ef23f76edd3e928f0a618534">validateTransactionInternal</a> (const <a class="el" href="classTxBlock.html">TxBlock</a> &amp;tx) const</td></tr>
<tr class="memdesc:a00d0b422ef23f76edd3e928f0a618534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if a transaction can be accepted within the current state.  <a href="classState.html#a00d0b422ef23f76edd3e928f0a618534">More...</a><br /></td></tr>
<tr class="separator:a00d0b422ef23f76edd3e928f0a618534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cc0483fcf98db60b076737cbf75110"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a08cc0483fcf98db60b076737cbf75110">processTransaction</a> (const <a class="el" href="classTxBlock.html">TxBlock</a> &amp;tx)</td></tr>
<tr class="memdesc:a08cc0483fcf98db60b076737cbf75110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process a transaction within a block.  <a href="classState.html#a08cc0483fcf98db60b076737cbf75110">More...</a><br /></td></tr>
<tr class="separator:a08cc0483fcf98db60b076737cbf75110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad96f1f2e70a8d01936bda8e49ccaeef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#aad96f1f2e70a8d01936bda8e49ccaeef">refreshMempool</a> (const <a class="el" href="classBlock.html">Block</a> &amp;block)</td></tr>
<tr class="memdesc:aad96f1f2e70a8d01936bda8e49ccaeef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the mempool, removing transactions that are in the given block, and leaving only valid transactions in it.  <a href="classState.html#aad96f1f2e70a8d01936bda8e49ccaeef">More...</a><br /></td></tr>
<tr class="separator:aad96f1f2e70a8d01936bda8e49ccaeef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ad7ca9a8a5635df6b7c40ace0db5b2830"><td class="memItemLeft" align="right" valign="top"><a id="ad7ca9a8a5635df6b7c40ace0db5b2830" name="ad7ca9a8a5635df6b7c40ace0db5b2830"></a>
const std::unique_ptr&lt; <a class="el" href="classDB.html">DB</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>db</b></td></tr>
<tr class="memdesc:ad7ca9a8a5635df6b7c40ace0db5b2830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the database. <br /></td></tr>
<tr class="separator:ad7ca9a8a5635df6b7c40ace0db5b2830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb0b23f455177c74d68606382e57534"><td class="memItemLeft" align="right" valign="top"><a id="a4eb0b23f455177c74d68606382e57534" name="a4eb0b23f455177c74d68606382e57534"></a>
const std::unique_ptr&lt; <a class="el" href="classStorage.html">Storage</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>storage</b></td></tr>
<tr class="memdesc:a4eb0b23f455177c74d68606382e57534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the blockchain's storage. <br /></td></tr>
<tr class="separator:a4eb0b23f455177c74d68606382e57534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177e70d002bb74845dde71ce3a8909f4"><td class="memItemLeft" align="right" valign="top"><a id="a177e70d002bb74845dde71ce3a8909f4" name="a177e70d002bb74845dde71ce3a8909f4"></a>
const std::unique_ptr&lt; <a class="el" href="classrdPoS.html">rdPoS</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>rdpos</b></td></tr>
<tr class="memdesc:a177e70d002bb74845dde71ce3a8909f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the <a class="el" href="classrdPoS.html" title="Abstraction of the rdPoS (Random Deterministic Proof of Stake) consensus algorithm.">rdPoS</a> object. <br /></td></tr>
<tr class="separator:a177e70d002bb74845dde71ce3a8909f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24885d108f6240f7c9a5cbee293cd8b"><td class="memItemLeft" align="right" valign="top"><a id="aa24885d108f6240f7c9a5cbee293cd8b" name="aa24885d108f6240f7c9a5cbee293cd8b"></a>
const std::unique_ptr&lt; <a class="el" href="classP2P_1_1ManagerNormal.html">P2P::ManagerNormal</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>p2pManager</b></td></tr>
<tr class="memdesc:aa24885d108f6240f7c9a5cbee293cd8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the <a class="el" href="namespaceP2P.html" title="Forward Declaration.">P2P</a> connection manager. <br /></td></tr>
<tr class="separator:aa24885d108f6240f7c9a5cbee293cd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6ef1339da0790d2c38abb1109dcf63"><td class="memItemLeft" align="right" valign="top"><a id="aaa6ef1339da0790d2c38abb1109dcf63" name="aaa6ef1339da0790d2c38abb1109dcf63"></a>
const std::unique_ptr&lt; <a class="el" href="classOptions.html">Options</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>options</b></td></tr>
<tr class="memdesc:aaa6ef1339da0790d2c38abb1109dcf63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the options singleton. <br /></td></tr>
<tr class="separator:aaa6ef1339da0790d2c38abb1109dcf63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74ac0798756b03f36b1aa2141d96a49"><td class="memItemLeft" align="right" valign="top"><a id="ad74ac0798756b03f36b1aa2141d96a49" name="ad74ac0798756b03f36b1aa2141d96a49"></a>
const std::unique_ptr&lt; <a class="el" href="classContractManager.html">ContractManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>contractManager</b></td></tr>
<tr class="memdesc:ad74ac0798756b03f36b1aa2141d96a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the contract manager. <br /></td></tr>
<tr class="separator:ad74ac0798756b03f36b1aa2141d96a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d61a302011b246b191d59f4ca7df8ef"><td class="memItemLeft" align="right" valign="top"><a id="a7d61a302011b246b191d59f4ca7df8ef" name="a7d61a302011b246b191d59f4ca7df8ef"></a>
std::unordered_map&lt; <a class="el" href="classAddress.html">Address</a>, <a class="el" href="structAccount.html">Account</a>, <a class="el" href="structSafeHash.html">SafeHash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>accounts</b></td></tr>
<tr class="memdesc:a7d61a302011b246b191d59f4ca7df8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map with information about blockchain accounts (<a class="el" href="classAddress.html" title="Abstraction for a single 20-byte address (e.g. &quot;1234567890abcdef...&quot;). Inherits FixedStr&lt;20&gt;.">Address</a> -&gt; <a class="el" href="structAccount.html" title="Abstraction of balance and nonce for a single account.">Account</a>). <br /></td></tr>
<tr class="separator:a7d61a302011b246b191d59f4ca7df8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc5861c673d11f72388ecad3227877a"><td class="memItemLeft" align="right" valign="top"><a id="a9bc5861c673d11f72388ecad3227877a" name="a9bc5861c673d11f72388ecad3227877a"></a>
std::unordered_map&lt; <a class="el" href="classHash.html">Hash</a>, <a class="el" href="classTxBlock.html">TxBlock</a>, <a class="el" href="structSafeHash.html">SafeHash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mempool</b></td></tr>
<tr class="memdesc:a9bc5861c673d11f72388ecad3227877a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTxBlock.html" title="Abstraction of a block transaction.">TxBlock</a> mempool. <br /></td></tr>
<tr class="separator:a9bc5861c673d11f72388ecad3227877a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab054c2dd5354a697c468331e462984"><td class="memItemLeft" align="right" valign="top"><a id="a0ab054c2dd5354a697c468331e462984" name="a0ab054c2dd5354a697c468331e462984"></a>
std::shared_mutex&#160;</td><td class="memItemRight" valign="bottom"><b>stateMutex</b></td></tr>
<tr class="memdesc:a0ab054c2dd5354a697c468331e462984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex for managing read/write access to the state object. <br /></td></tr>
<tr class="separator:a0ab054c2dd5354a697c468331e462984"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Abstraction of the blockchain's state. </p>
<p >Responsible for maintaining the current blockchain state at the current block. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af644a7bf78a51943286674716d154cc5" name="af644a7bf78a51943286674716d154cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af644a7bf78a51943286674716d154cc5">&#9670;&nbsp;</a></span>State()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">State::State </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; <a class="el" href="classDB.html">DB</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; <a class="el" href="classStorage.html">Storage</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; <a class="el" href="classrdPoS.html">rdPoS</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rdpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; <a class="el" href="classP2P_1_1ManagerNormal.html">P2P::ManagerNormal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2pManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; <a class="el" href="classOptions.html">Options</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">db</td><td>Pointer to the database. </td></tr>
    <tr><td class="paramname">storage</td><td>Pointer to the blockchain's storage. </td></tr>
    <tr><td class="paramname">rdpos</td><td>Pointer to the <a class="el" href="classrdPoS.html" title="Abstraction of the rdPoS (Random Deterministic Proof of Stake) consensus algorithm.">rdPoS</a> object. </td></tr>
    <tr><td class="paramname">p2pManager</td><td>Pointer to the <a class="el" href="namespaceP2P.html" title="Forward Declaration.">P2P</a> connection manager. </td></tr>
    <tr><td class="paramname">options</td><td>Pointer to the options singleton. </td></tr>
  </table>
  </dd>
</dl>
<p >Initialize with 0x00dead00665771855a34155f5e7405489df2c3c6 with nonce 0.</p>
<p >See ~State for encoding</p>

</div>
</div>
<a id="afab438d92b90dc18d194dbd9c9c8bab3" name="afab438d92b90dc18d194dbd9c9c8bab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab438d92b90dc18d194dbd9c9c8bab3">&#9670;&nbsp;</a></span>~State()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">State::~State </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p ><a class="el" href="classDB.html" title="Abstraction of a LevelDB database.">DB</a> is stored as following Under the DBPrefix::nativeAccounts Each key == <a class="el" href="classAddress.html" title="Abstraction for a single 20-byte address (e.g. &quot;1234567890abcdef...&quot;). Inherits FixedStr&lt;20&gt;.">Address</a> Each Value == Balance + uint256_t (not exact bytes) Value == 1 Byte (Balance Size) + N Bytes (Balance) + 1 Byte (Nonce Size) + N Bytes (Nonce). Max size for Value = 32 Bytes, Max Size for Nonce = 8 Bytes. If the nonce equals to 0, it will be <em>empty</em></p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a596b8016292281a9d2fd3010d6771d89" name="a596b8016292281a9d2fd3010d6771d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596b8016292281a9d2fd3010d6771d89">&#9670;&nbsp;</a></span>addBalance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void State::addBalance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add balance to a given account. </p>
<p >Used through HTTP RPC to add balance to a given address NOTE: ONLY TO BE USED WITHIN THE TESTNET OF A GIVEN APP-CHAIN. THIS FUNCTION ALLOWS ANYONE TO GIVE THEMSELVES NATIVE TOKENS. IF CALLING THIS FUNCTION WITHIN A MULTI-NODE NETWORK, YOU HAVE TO CALL IT ON ALL NODES IN ORDER TO BE VALID. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address to add balance to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01905069aff940eb4906fdf312a2ce33" name="a01905069aff940eb4906fdf312a2ce33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01905069aff940eb4906fdf312a2ce33">&#9670;&nbsp;</a></span>addTx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TxInvalid State::addTx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTxBlock.html">TxBlock</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>tx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a transaction to the mempool, if valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>The transaction to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum telling if the transaction is valid or not. </dd></dl>

</div>
</div>
<a id="a80f2d2092a54191583d3e8584372e712" name="a80f2d2092a54191583d3e8584372e712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f2d2092a54191583d3e8584372e712">&#9670;&nbsp;</a></span>addValidatorTx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool State::addValidatorTx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTxValidator.html">TxValidator</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a <a class="el" href="classValidator.html" title="Abstraction of a validator.">Validator</a> transaction to the <a class="el" href="classrdPoS.html" title="Abstraction of the rdPoS (Random Deterministic Proof of Stake) consensus algorithm.">rdPoS</a> mempool, if valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>The transaction to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if transaction is valid, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a6359b4c207a6cb9f9fddc611cb42ae0f" name="a6359b4c207a6cb9f9fddc611cb42ae0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6359b4c207a6cb9f9fddc611cb42ae0f">&#9670;&nbsp;</a></span>estimateGas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool State::estimateGas </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; <a class="el" href="classAddress.html">Address</a>, <a class="el" href="classAddress.html">Address</a>, uint64_t, uint256_t, uint256_t, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>callInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate gas for callInfo in RPC. </p>
<p >Doesn't really "estimate" gas, but rather tells if the transaction is valid or not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callInfo</td><td>tuple with info about the call (from, to, gasLimit, gasPrice, value, data). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the call is valid, <code>false</code> otherwise. </dd></dl>
<p >Check balance/gasLimit/gasPrice if available.</p>

</div>
</div>
<a id="aefc934938772088354861d7aee343128" name="aefc934938772088354861d7aee343128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc934938772088354861d7aee343128">&#9670;&nbsp;</a></span>ethCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string State::ethCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulate an <code>eth_call</code> to a contract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The contract address. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be sent to the contract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return of the called function as a data string. </dd></dl>

</div>
</div>
<a id="acb96567d4d00d045e06e10f04174717f" name="acb96567d4d00d045e06e10f04174717f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb96567d4d00d045e06e10f04174717f">&#9670;&nbsp;</a></span>fillBlockWithTransactions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void State::fillBlockWithTransactions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlock.html">Block</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a block with all transactions currently in the mempool. </p>
<p >DOES NOT FINALIZE THE BLOCK. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a982301c2bad1fe826db29640accb7b7d" name="a982301c2bad1fe826db29640accb7b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982301c2bad1fe826db29640accb7b7d">&#9670;&nbsp;</a></span>getNativeBalance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint256_t State::getNativeBalance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the native balance of an account in the state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address of the account to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The native account balance of the given address. </dd></dl>

</div>
</div>
<a id="a23bba399ab7fc870f681158ff8d854c7" name="a23bba399ab7fc870f681158ff8d854c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bba399ab7fc870f681158ff8d854c7">&#9670;&nbsp;</a></span>getNativeNonce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint64_t State::getNativeNonce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the native nonce of an account in the state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address of the account to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The native account nonce of the given address. </dd></dl>

</div>
</div>
<a id="a7bcc769697a3b38ff3d561b603999b72" name="a7bcc769697a3b38ff3d561b603999b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bcc769697a3b38ff3d561b603999b72">&#9670;&nbsp;</a></span>getTxFromMempool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classTxBlock.html">TxBlock</a> &gt; State::getTxFromMempool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHash.html">Hash</a> &amp;&#160;</td>
          <td class="paramname"><em>txHash</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a transaction from the mempool. </p>
<p >@params txHash The transaction <a class="el" href="classHash.html" title="Abstraction of a 32-byte hash. Inherits FixedStr&lt;32&gt;.">Hash</a>. </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the transaction, or <code>nullptr</code> if not found. We cannot directly copy the transaction, since <a class="el" href="classTxBlock.html" title="Abstraction of a block transaction.">TxBlock</a> doesn't have a default constructor, thus making it impossible to return an "empty" transaction if the hash is not found in the mempool, so we return a null pointer instead. </dd></dl>

</div>
</div>
<a id="aabc33c0a39c4eb8f25846d8623a6b3a9" name="aabc33c0a39c4eb8f25846d8623a6b3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc33c0a39c4eb8f25846d8623a6b3a9">&#9670;&nbsp;</a></span>isTxInMempool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool State::isTxInMempool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHash.html">Hash</a> &amp;&#160;</td>
          <td class="paramname"><em>txHash</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a transaction is in the mempool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txHash</td><td>The transaction hash to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the transaction is in the mempool, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a8de031bf3cd4328caa7473f03c10954b" name="a8de031bf3cd4328caa7473f03c10954b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de031bf3cd4328caa7473f03c10954b">&#9670;&nbsp;</a></span>processNextBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void State::processNextBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlock.html">Block</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process the next block given current state from the network. </p>
<p >DOES update the state. Appends block to <a class="el" href="classStorage.html" title="Abstraction of the blockchain history.">Storage</a> after processing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block to process. </td></tr>
  </table>
  </dd>
</dl>
<p >Sanity Check.</p>
<p >Process transactions of the block within the current state.</p>
<p >Process <a class="el" href="classrdPoS.html" title="Abstraction of the rdPoS (Random Deterministic Proof of Stake) consensus algorithm.">rdPoS</a> <a class="el" href="classState.html" title="Abstraction of the blockchain&#39;s state.">State</a></p>
<p >Refresh the mempool based on the block transactions;</p>
<p >Move block to storage.</p>

</div>
</div>
<a id="a08cc0483fcf98db60b076737cbf75110" name="a08cc0483fcf98db60b076737cbf75110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08cc0483fcf98db60b076737cbf75110">&#9670;&nbsp;</a></span>processTransaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void State::processTransaction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTxBlock.html">TxBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process a transaction within a block. </p>
<p >Called by <a class="el" href="classState.html#a8de031bf3cd4328caa7473f03c10954b" title="Process the next block given current state from the network.">processNextBlock()</a>. If the process fails, any state change that this transaction would cause has to be reverted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>The transaction to process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if transaction was processed, 'false' if process failed. </dd></dl>
<p >Lock is already called by processNextBlock processNextBlock already calls validateTransaction in every tx. As it calls validateNextBlock as a sanity check.</p>
<p >TODO: <a class="el" href="classContract.html" title="Native abstraction of a smart contract.">Contract</a> calling, including "payable" functions.</p>
<p >This need to change with payable contract functions</p>

</div>
</div>
<a id="aad96f1f2e70a8d01936bda8e49ccaeef" name="aad96f1f2e70a8d01936bda8e49ccaeef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad96f1f2e70a8d01936bda8e49ccaeef">&#9670;&nbsp;</a></span>refreshMempool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void State::refreshMempool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlock.html">Block</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the mempool, removing transactions that are in the given block, and leaving only valid transactions in it. </p>
<p >Called by processNewBlock(), used to filter the current mempool based on transactions that have been accepted on the block, and verify if transactions on the mempool are valid given the new state after processing the block itself. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block to use for pruning transactions from the mempool. </td></tr>
  </table>
  </dd>
</dl>
<p >No need to lock mutex as function caller (this-&gt;processNextBlock) already lock mutex. Remove all transactions within the block that exists on the unordered_map.</p>
<p >Copy mempool over</p>
<p >Verify if the transactions within the old mempool not added to the block are valid given the current state</p>
<p >Calls internal function which doesn't lock mutex.</p>

</div>
</div>
<a id="abbb9826c231245e89ddf6791d2cf4c31" name="abbb9826c231245e89ddf6791d2cf4c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb9826c231245e89ddf6791d2cf4c31">&#9670;&nbsp;</a></span>validateNextBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool State::validateNextBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlock.html">Block</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate the next block given the current state and its transactions. </p>
<p >Does NOT update the state. The block will be rejected if there are invalid transactions in it (e.g. invalid signature, insufficient balance, etc.). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block to validate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the block is validated successfully, <code>false</code> otherwise. </dd></dl>
<p >Rules for a block to be accepted within the current state <a class="el" href="classBlock.html" title="Abstraction of a block.">Block</a> nHeight must match latest nHeight + 1 <a class="el" href="classBlock.html" title="Abstraction of a block.">Block</a> nPrevHash must match latest hash <a class="el" href="classBlock.html" title="Abstraction of a block.">Block</a> nTimestamp must be higher than latest block <a class="el" href="classBlock.html" title="Abstraction of a block.">Block</a> has valid <a class="el" href="classrdPoS.html" title="Abstraction of the rdPoS (Random Deterministic Proof of Stake) consensus algorithm.">rdPoS</a> transaction and signature based on current state. All transactions within <a class="el" href="classBlock.html" title="Abstraction of a block.">Block</a> are valid (does not return false on validateTransaction) <a class="el" href="classBlock.html" title="Abstraction of a block.">Block</a> constructor already checks if merkle roots within a block are valid.</p>

</div>
</div>
<a id="aba76d4c86e026911d78fcb77d8d9a5af" name="aba76d4c86e026911d78fcb77d8d9a5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba76d4c86e026911d78fcb77d8d9a5af">&#9670;&nbsp;</a></span>validateTransaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TxInvalid State::validateTransaction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTxBlock.html">TxBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify if a transaction can be accepted within the current state. </p>
<p >Calls <a class="el" href="classState.html#a00d0b422ef23f76edd3e928f0a618534" title="Verify if a transaction can be accepted within the current state.">validateTransactionInternal()</a>, but locking the mutex in a shared manner. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>The transaction to verify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum telling if the transaction is valid or not. </dd></dl>

</div>
</div>
<a id="a00d0b422ef23f76edd3e928f0a618534" name="a00d0b422ef23f76edd3e928f0a618534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d0b422ef23f76edd3e928f0a618534">&#9670;&nbsp;</a></span>validateTransactionInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TxInvalid State::validateTransactionInternal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTxBlock.html">TxBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify if a transaction can be accepted within the current state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>The transaction to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum telling if the block is invalid or not. </dd></dl>
<p >Rules for a transaction to be accepted within the current state: Transaction value + txFee (gas * gasPrice) needs to be lower than account balance Transaction nonce must match account nonce</p>
<p >Verify if transaction already exists within the mempool, if on mempool, it has been validated previously.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/core/<a class="el" href="state_8h_source.html">state.h</a></li>
<li>src/core/state.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
